<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.4.1 by Michael Rose
  Copyright 2017 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin SEO -->









<title>Parallel programming in Haskell - 驭风万里无垠</title>




<meta name="description" content="Parallel和Concurrency的目标是一致的，然后Parallel更强调在多个物理并发处理单元（至少从OS之上的角度看如此）存在的情况下，如何最大限度地利用现有的CPU资源提高程序的性能。传统的过程式编程思维范式中，所有的操作都是顺行串行的，多核并发处理往往意味着需要对代码做大幅度的修改；而Haskell的并行编程则因为其Lazy Evaluation特性而变得简单许多 - 基于现有的代码做一些相对细微的改动就可以使得某些操作并行起来。同样由于这一Lazy特性和表达式赋值的灵活性，很多隐晦的问题也很容易随之而生。Haskell通过提供Strategy抽象将赋值策略和实际算法隔离开来，从而灵活的解决了Lazy带来的副作用。">




<meta name="author" content="Fei Yan">

<meta property="og:locale" content="en">
<meta property="og:site_name" content="驭风万里无垠">
<meta property="og:title" content="Parallel programming in Haskell">


  <link rel="canonical" href="http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/">
  <meta property="og:url" content="http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/">



  <meta property="og:description" content="Parallel和Concurrency的目标是一致的，然后Parallel更强调在多个物理并发处理单元（至少从OS之上的角度看如此）存在的情况下，如何最大限度地利用现有的CPU资源提高程序的性能。传统的过程式编程思维范式中，所有的操作都是顺行串行的，多核并发处理往往意味着需要对代码做大幅度的修改；而Haskell的并行编程则因为其Lazy Evaluation特性而变得简单许多 - 基于现有的代码做一些相对细微的改动就可以使得某些操作并行起来。同样由于这一Lazy特性和表达式赋值的灵活性，很多隐晦的问题也很容易随之而生。Haskell通过提供Strategy抽象将赋值策略和实际算法隔离开来，从而灵活的解决了Lazy带来的副作用。">



  <meta name="twitter:site" content="@skyscribe">
  <meta name="twitter:title" content="Parallel programming in Haskell">
  <meta name="twitter:description" content="Parallel和Concurrency的目标是一致的，然后Parallel更强调在多个物理并发处理单元（至少从OS之上的角度看如此）存在的情况下，如何最大限度地利用现有的CPU资源提高程序的性能。传统的过程式编程思维范式中，所有的操作都是顺行串行的，多核并发处理往往意味着需要对代码做大幅度的修改；而Haskell的并行编程则因为其Lazy Evaluation特性而变得简单许多 - 基于现有的代码做一些相对细微的改动就可以使得某些操作并行起来。同样由于这一Lazy特性和表达式赋值的灵活性，很多隐晦的问题也很容易随之而生。Haskell通过提供Strategy抽象将赋值策略和实际算法隔离开来，从而灵活的解决了Lazy带来的副作用。">
  <meta name="twitter:url" content="http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/">

  
    <meta name="twitter:card" content="summary">
    
  

  
    <meta name="twitter:creator" content="@Fei Yan">
  







  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2012-08-02T20:55:00+08:00">













<!-- end SEO -->


<link href="http://www.skyscribe.me/feed.xml" type="application/atom+xml" rel="alternate" title="驭风万里无垠 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="http://www.skyscribe.me/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->

<meta http-equiv="cleartype" content="on">
    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->
  </head>

  <body class="layout--post">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="http://www.skyscribe.me/">驭风万里无垠</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/programming/index.html">编程相关</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/notes/index.html">个人笔记</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/tools/index.html">工具相关</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/engineering/index.html">软件工程</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/design/index.html">软件设计</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/haskell/index.html">Haskell</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/cpp/index.html">C++</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/year-archive/index.html">按年份归档</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/tags/index.html">标签汇总</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/categories/index.html">所有分类</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://www.skyscribe.me/about/">关于...</a></li>
          
        </ul>
        <button><div class="navicon"></div></button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    



<div id="main" role="main">
  
  <div class="sidebar sticky">
  

<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="http://www.skyscribe.me/assets/images/me.jpg" class="author__avatar" alt="Fei Yan" itemprop="image">
      
    </div>
  

  <div class="author__content">
    <h3 class="author__name" itemprop="name">Fei Yan</h3>
    
      <p class="author__bio" itemprop="description">
        A curious programmer
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> <span itemprop="name">Hangzhou</span>
        </li>
      

      

      
        <li>
          <a href="mailto:skyscribe.yf@gmail.com">
            <meta itemprop="email" content="skyscribe.yf@gmail.com" />
            <i class="fa fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-linkedin-square" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      
        <li>
          <a href="https://www.stackoverflow.com/users/222167/fei" itemprop="sameAs">
            <i class="fa fa-fw fa-stack-overflow" aria-hidden="true"></i> Stackoverflow
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fa fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>


  
<h3>
  <a href="/categories/index.html">Categories</a>
</h3>
<div class="tagCloud">
  <ul>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/cpp/index.html">cpp(8)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/tools/index.html">tools(21)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/debugging/index.html">debugging(4)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/linux/index.html">linux(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/build/index.html">build(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/tips/index.html">tips(5)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/security/index.html">security(1)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/python/index.html">python(2)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/test/index.html">test(1)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/study/index.html">study(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/notes/index.html">notes(18)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/ruby/index.html">ruby(7)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/blog/index.html">blog(5)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/doc/index.html">doc(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/programming/index.html">programming(22)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/haskell/index.html">haskell(9)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/fp/index.html">fp(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/design/index.html">design(5)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/engineering/index.html">engineering(7)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/kotlin/index.html">kotlin(2)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/java/index.html">java(1)</a>
  </span>
  </li>
  
  </ul>
</div>


  
  </div>




  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Parallel programming in Haskell">
    <meta itemprop="description" content="Parallel和Concurrency的目标是一致的，然后Parallel更强调在多个物理并发处理单元（至少从OS之上的角度看如此）存在的情况下，如何最大限度地利用现有的CPU资源提高程序的性能。传统的过程式编程思维范式中，所有的操作都是顺行串行的，多核并发处理往往意味着需要对代码做大幅度的修改；而Haskell的并行编程则因为其Lazy Evaluation特性而变得简单许多 - 基于现有的代码做一些相对细微的改动就可以使得某些操作并行起来。同样由于这一Lazy特性和表达式赋值的灵活性，很多隐晦的问题也很容易随之而生。Haskell通过提供Strategy抽象将赋值策略和实际算法隔离开来，从而灵活的解决了Lazy带来的副作用。">
    <meta itemprop="datePublished" content="August 02, 2012">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 class="page__title" itemprop="headline">Parallel programming in Haskell
</h1>
          
            <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  5 minute read
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        <p>Parallel和Concurrency的目标是一致的，然后Parallel更强调在多个物理并发处理单元（至少从OS之上的角度看如此）存在的情况下，如何最大限度地利用现有的CPU资源提高程序的性能。传统的过程式编程思维范式中，所有的操作都是顺行串行的，多核并发处理往往意味着需要对代码做大幅度的修改；而Haskell的并行编程则因为其<strong>Lazy Evaluation</strong>特性而变得简单许多 - 基于现有的代码做一些相对细微的改动就可以使得某些操作并行起来。同样由于这一Lazy特性和表达式赋值的灵活性，很多隐晦的问题也很容易随之而生。Haskell通过提供Strategy抽象将赋值策略和实际算法隔离开来，从而灵活的解决了Lazy带来的副作用。</p>

<!--more-->
<h2 id="如何启用并行执行">如何启用并行执行</h2>

<p><em>如下方法仅使用于GHC编译器</em></p>

<p>GHC采用运行时指定的方式来引导运行时系统将程序分布在多个物理核心上执行。GHC在启动程序代码的时候，会先扫描命令行传入参数中关于运行期控制的参数，解析其选项值，然后将其从arglist中删除，即这些控制参数对程序本身而言是透明不可见的。</p>

<p>GHC运行时通过识别<code class="highlighter-rouge">+RTS</code>和<code class="highlighter-rouge">-RTS</code>来解析运行时参数，其中间的部分会被认为是控制GHC运行时的选项。对于并发而言，我们需要关注的是<code class="highlighter-rouge">-Nx</code>参数，而这里的<strong>x</strong>需要设置为CPU的核心数目。在Linux系统上，可以用如下命令获取CPU线程数目：</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>cat /proc/cpuinfo  | grep <span class="s2">"^processor"</span> | wc -l
</code></pre>
</div>

<p>当然也可以用如下的Haskell工具函数：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">GHC.Conc</span> <span class="p">(</span><span class="nf">numCapabilities</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>

<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">args</span> <span class="o">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"command line arguments: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">args</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"number of cores: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">numCapabilities</span>
</code></pre>
</div>

<p>首先编译代码的时候需要加入<code class="highlighter-rouge">-threaded</code>的选项告知编译器支持并发,然后需要在程序运行的时候传入<code class="highlighter-rouge">-N</code>:</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ghc -c NumCapabilities.hs
ghc -threaded -o NumCapabilities NumCapabilities.o 
./NumCapabilites +RTS -N4 -RTS
</code></pre>
</div>

<p>这个例子还可以表明RTS参数不会传入程序的getArgs中;此无如果传入的N个数超出物理核心数，GHC会提示需要打开<code class="highlighter-rouge">-rtsopts</code>编译选项，否则运行时拒绝执行程序代码。</p>

<h2 id="通过小幅修改代码实现并行">通过小幅修改代码实现并行</h2>

<p>对于CPU密集型的运算，一种通用的并行思路是将需要解决的问题划分为各个不相关的子部分，然后对每个子部分做分别处理，最后再归拢各个子部分的处理结果，即所谓的<strong>分治法</strong>，但是这样做同时意味着必须对实现代码作出修改 - 至少在其它非函数式语言环境中需要这么做。Haskell则提供了另外一些一个比较简单的思路：对已有的代码做一些简单转换，然后使得他们可以被并行执行。</p>

<h3 id="normal-form-和-head-normal-form">Normal Form 和 Head Normal Form</h3>

<p>在Haskell中，Normal Form即为普通的表达式赋值规则-对应的表达式会被完全赋值，而Head Normal Form 则仅仅执行到某部分的最外层构造函数就停止赋值。还有另外一种所谓Weak Head Normal Form的方式，其对数据类型的规则和Head Normal Form是一样的，仅仅在函数处理上有所<a href="Further discussion can be found on Stackoverflow: http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form">不同</a>.</p>

<h3 id="分治法的例子---quicksort">分治法的例子 - QuickSort</h3>

<p>下边是一个简单的分治法例子 - 快速排序：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">sort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">sort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="o">:</span><span class="n">greater</span>
    <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">sort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
              <span class="n">greater</span> <span class="o">=</span> <span class="n">sort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
              <span class="n">sort</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
</code></pre>
</div>

<p>对于这个朴素的例子，可以通过一些细微的变化使其并行起来：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Control.Parallel</span> <span class="p">(</span><span class="nf">par</span><span class="p">,</span> <span class="nf">pseq</span><span class="p">)</span>

<span class="n">parSort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">parSort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>    <span class="o">=</span> <span class="n">force</span> <span class="n">greater</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">force</span> <span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span>
                         <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="o">:</span><span class="n">greater</span><span class="p">))</span>
             <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">parSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
                   <span class="n">greater</span> <span class="o">=</span> <span class="n">parSort</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="n">parSort</span> <span class="kr">_</span>         <span class="o">=</span> <span class="kt">[]</span>
</code></pre>
</div>

<h4 id="新函数">新函数</h4>

<p>这里的不同之处是加入了<code class="highlighter-rouge">force</code>,<code class="highlighter-rouge">par</code>和<code class="highlighter-rouge">pseq</code>的调用:</p>
<ul>
  <li><code class="highlighter-rouge">par</code>函数会先赋值其左边表达式到WHNF，然后返回其右侧的部分。对于<code class="highlighter-rouge">par</code>而言，其操作可以和其它正在进行的赋值并行进行。</li>
  <li><code class="highlighter-rouge">pseq</code>函数会保证其左侧的表达式必定先于右侧表达式被赋值，并且默认规则是按照WHNF</li>
  <li><code class="highlighter-rouge">force</code>函数的定义如下：
    <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">force</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nb">()</span>
<span class="n">force</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">go</span> <span class="n">xs</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="nb">()</span>
  <span class="kr">where</span> <span class="n">go</span> <span class="p">(</span><span class="kr">_</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">go</span> <span class="n">xs</span>
            <span class="n">go</span> <span class="kt">[]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre>
    </div>
    <p>这里的force函数确保list类型的每一个元素都被赋值。如果去掉这里的force,那么算法本身会和顺序的方案一样，因为<code class="highlighter-rouge">pseq</code>仅仅要求左侧表达式按照WHNF来赋值，而对于list类型而言，只要第一个元素（HEAD）被赋值，那么这个左侧的赋值操作即算完毕，加入<code class="highlighter-rouge">force</code>就保证了做最后返回的部分，<code class="highlighter-rouge">greater</code>和<code class="highlighter-rouge">lesser</code>部分均已赋值完毕。</p>
  </li>
</ul>

<h4 id="性能问题">性能问题</h4>

<p>Haskell的线程代价比大部分其它语言的线程代价都要小，但是并发意味着对共享内存的访问和控制，这些开销并不是任何时候都可以忽略的。对上述程序的性能做剖析会发现，其实上述算法对每一个运算都尽量来并发直到list本身只剩下一个元素，那么多线程带来的并发开销会大于带来的好处。一种这种的方案是检测递归的深度，然后到某种程度停止并发处理，转回线性处理：</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">parSort2</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">parSort2</span> <span class="n">d</span> <span class="n">list</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span>     <span class="o">=</span> <span class="n">sort</span> <span class="n">list</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">force</span> <span class="n">greater</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">force</span> <span class="n">lesser</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span>
                         <span class="p">(</span><span class="n">lesser</span> <span class="o">++</span> <span class="n">x</span><span class="o">:</span><span class="n">greater</span><span class="p">))</span>
      <span class="kr">where</span> <span class="n">lesser</span>      <span class="o">=</span> <span class="n">parSort2</span> <span class="n">d'</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="n">x</span><span class="p">]</span>
            <span class="n">greater</span>     <span class="o">=</span> <span class="n">parSort2</span> <span class="n">d'</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">]</span>
            <span class="n">d'</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>          
            
<span class="n">parSort2</span> <span class="kr">_</span> <span class="kr">_</span>              <span class="o">=</span> <span class="kt">[]</span>
</code></pre>
</div>

<h4 id="gc的问题">GC的问题</h4>

<p>GHC的GC还是采用单线成的方式，因而在GC工作的时候，其它线程的处理都会被暂停执行，这个问题在某些情况下也是需要注意的。</p>

<h2 id="策略strategy">策略Strategy</h2>

<p>采用分治法处理并发问题的时候，不管采用何种语言，都会遇到如下的问题：</p>
<ul>
  <li>算法处理本身很容易被并发控制的细节所淹没 - 尤其算法逻辑变得复杂之后</li>
  <li>并发处理单元的粒度控制变得富有挑战 - 太大的粒度浪费CPU资源，而过小的粒度则会代理更多并发控制本身的开销</li>
</ul>

<h3 id="parallelmap-的例子和问题">ParallelMap 的例子和问题</h3>

<p>回到上边的例子，为了将传统的顺序程序改为并行，我们必须在代码中小心的插入<code class="highlighter-rouge">pseq</code>/<code class="highlighter-rouge">par</code>/<code class="highlighter-rouge">force</code>来指明整个并行方式需要如何赋值运算，甚至对于<code class="highlighter-rouge">list</code>类型，还需通过自定义的<code class="highlighter-rouge">force</code>函数来强制赋值每一个元素以保证算法的正确性,这一方式看起来无疑是非常繁琐甚至重复的。再考虑<code class="highlighter-rouge">map</code>这一很重要的函数，对于并发控制，同样需要定义一个<code class="highlighter-rouge">paralleMap</code>才能放在代码里边用:</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Control.Parallel</span> <span class="p">(</span><span class="nf">par</span><span class="p">)</span>

<span class="n">parallelMap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">parallelMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
                       <span class="kr">in</span> <span class="n">r</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="n">r</span> <span class="o">:</span> <span class="n">parallelMap</span> <span class="n">f</span> <span class="n">xs</span>
<span class="n">parallelMap</span> <span class="kr">_</span> <span class="kr">_</span>      <span class="o">=</span> <span class="kt">[]</span>
</code></pre>
</div>

<p>即使对于这个版本的实现，如果b类型本身是一个list，那么这个算法很可能还是不能真正并行起来，因为<code class="highlighter-rouge">list</code>类型的WHNF仅仅运算第一个元素；我们可能不得不新实现一个针对特殊类型的（<code class="highlighter-rouge">list</code>)的版本，甚至于对很多不同类型的<code class="highlighter-rouge">b</code>都可能需要一些特殊的处理。</p>

<p>一种想法是，我们可以引入一个指定某个类型的赋值规则的<strong>函数参数</strong>来确定某个类型的赋值方式，譬如：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">forceListAndElts</span> <span class="o">::</span> <span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="nb">()</span><span class="p">)</span><span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nb">()</span>
<span class="n">forceListAndElts</span> <span class="n">forceElt</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">forceElt</span> <span class="n">x</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">forceListAndElts</span> <span class="n">forceElt</span> <span class="n">xs</span>
<span class="n">forceListAndElts</span> <span class="kr">_</span> <span class="kr">_</span> <span class="o">=</span> <span class="nb">()</span>
</code></pre>
</div>

<p>这里的函数强制list的每一个元素都按照对应元素类型的<code class="highlighter-rouge">forceElt</code>函数赋值到对应的形式（WHNF等）。将上述想法扩展泛化就回得到<strong>Strategies</strong>：</p>

<h3 id="strategies">Strategies</h3>

<p>Haskell通过库的方式提供Strategies的支持：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">ghc</span><span class="o">&gt;:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Parallel</span><span class="o">.</span><span class="kt">Strategies</span>
<span class="n">ghc</span><span class="o">&gt;:</span><span class="n">info</span> <span class="kt">Strategy</span> 
<span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
  <span class="c1">-- Defined in `Control.Parallel.Strategies'</span>
<span class="n">ghc</span><span class="o">&gt;:</span><span class="n">info</span> <span class="kt">Eval</span> 
<span class="kr">newtype</span> <span class="kt">Eval</span> <span class="n">a</span>
  <span class="o">=</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Parallel</span><span class="o">.</span><span class="kt">Strategies</span><span class="o">.</span><span class="kt">Eval</span> <span class="p">(</span><span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span>
                                          <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span>
                        <span class="o">-&gt;</span> <span class="p">(</span><span class="o">#</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span><span class="p">,</span> <span class="n">a</span> <span class="o">#</span><span class="p">))</span>
            <span class="c1">-- Defined in `Control.Parallel.Strategiestegies'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Eval</span> <span class="c1">-- Defined in `Control.Parallel.Strategies'</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Eval</span> <span class="c1">-- Defined in `Control.Parallel.Strategies'</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">Strategy</code>是一个<code class="highlighter-rouge">typeclass</code>,对每一个类型a, <code class="highlighter-rouge">Eval</code>构造出一个具体的Strategy，而<code class="highlighter-rouge">Eval</code>本身则是个<code class="highlighter-rouge">newtype</code>,并且是个Monad/Functor实例。此外，Strategy库还定义了如下Strategy:</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">ghc</span><span class="o">&gt;:</span><span class="n">info</span> <span class="n">rwhnf</span> 
<span class="n">rwhnf</span> <span class="o">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="c1">-- Defined in   `Control.Parallel.Strategies'</span>

<span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">rnf</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="nb">()</span>
    <span class="n">rnf</span> <span class="o">=</span> <span class="n">rwhnf</span>

<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">NFData</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">NFData</span> <span class="kt">Integer</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">NFData</span> <span class="kt">Int</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">NFData</span> <span class="kt">Float</span>
<span class="c1">-- more basic types ... </span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- tuple</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="p">(</span><span class="kt">NFData</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a3</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a4</span><span class="p">,</span>
                 <span class="kt">NFData</span> <span class="n">a5</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a6</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a7</span><span class="p">,</span> <span class="kt">NFData</span> <span class="n">a8</span><span class="p">)</span> <span class="o">=&gt;</span>
             <span class="kt">NFData</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a7</span><span class="p">,</span> <span class="n">a8</span><span class="p">)</span>

<span class="c1">-- more follows ....</span>
</code></pre>
</div>
<p>Typeclass<code class="highlighter-rouge">NFData</code>抽象了所有的Strategy并且提供了<code class="highlighter-rouge">rnf</code>和<code class="highlighter-rouge">rwhnf</code>并且提供了大部分基本类型的实现，譬如常见的<code class="highlighter-rouge">Maybe</code>类型：</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">rnf</span> <span class="p">(</span><span class="kt">Nothing</span><span class="p">)</span> <span class="o">=</span> <span class="nb">()</span>
    <span class="n">rnf</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">rnf</span> <span class="n">x</span>
</code></pre>
</div>
<p>对于自定义类型，我们就可以自己依照实现自己的<code class="highlighter-rouge">rnf</code>方法。对于自定义类型，<code class="highlighter-rouge">rnf</code>必须赋值到每一个构造函数的每一个字段。</p>

<h2 id="策略和算法的解耦合">策略和算法的解耦合</h2>

<p>根据基本的Strategy,我们可以组合出更丰富的赋值方式，比如：</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">parList</span> <span class="o">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">parList</span> <span class="n">strat</span> <span class="kt">[]</span>     <span class="o">=</span> <span class="nb">()</span>
<span class="n">parList</span> <span class="n">strat</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">strat</span> <span class="n">x</span> <span class="p">`</span><span class="n">par</span><span class="p">`</span> <span class="p">(</span><span class="n">parList</span> <span class="n">strat</span> <span class="n">xs</span><span class="p">)</span>

<span class="n">parMap</span> <span class="o">::</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">parMap</span> <span class="n">strat</span> <span class="n">f</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">strat</span>
</code></pre>
</div>

<p>上述<code class="highlighter-rouge">parMap</code>的实现中，左边的算法部分仍然是相同的<code class="highlighter-rouge">map f xs</code>实现，而<code class="highlighter-rouge">using</code>函数则将左侧的实际算法和右侧的<code class="highlighter-rouge">Strategy</code>结合起来了：</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">using</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">using</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="n">x</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="n">x</span>
</code></pre>
</div>

<h3 id="mapreduce-的例子">MapReduce 的例子</h3>
<p>一个简化版本的MapReduce例子如下：</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">mapReduce</span>
    <span class="o">::</span> <span class="kt">Strategy</span> <span class="n">b</span>    <span class="c1">-- evaluation strategy for mapping</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>      <span class="c1">-- map function</span>
    <span class="o">-&gt;</span> <span class="kt">Strategy</span> <span class="n">c</span>    <span class="c1">-- evaluation strategy for reduction</span>
    <span class="o">-&gt;</span> <span class="p">([</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>    <span class="c1">-- reduce function</span>
    <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>           <span class="c1">-- list to map over</span>
    <span class="o">-&gt;</span> <span class="n">c</span>

<span class="n">mapReduce</span> <span class="n">mapStrat</span> <span class="n">mapFunc</span> <span class="n">reduceStrat</span> <span class="n">reduceFunc</span> <span class="n">input</span> <span class="o">=</span>
    <span class="n">mapResult</span> <span class="p">`</span><span class="n">pseq</span><span class="p">`</span> <span class="n">reduceResult</span>
      <span class="kr">where</span> <span class="n">mapResult</span>  <span class="o">=</span> <span class="n">parMap</span> <span class="n">mapStrat</span> <span class="n">mapFunc</span> <span class="n">input</span>
          <span class="n">reduceResult</span> <span class="o">=</span> <span class="n">reduceFunc</span> <span class="n">mapResult</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">reduceStrat</span>
</code></pre>
</div>

<p>Haskell通过引入Strategy的方式分离算法和并发控制，从而比较优雅的部分解决了这个问题（当然更好的解决需要STM的参与）。</p>

<h2 id="参考">参考</h2>
<ol>
  <li><a href="http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html">RealWorld Haskell - chapter 24</a></li>
  <li><a href="http://www.haskell.org/haskellwiki/Parallel/Reading">Haskell parrale reading</a></li>
  <li><a href="http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html">Algorithm + Strategy = Parallelism</a></li>
</ol>


        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="http://www.skyscribe.me/categories/design" class="page__taxonomy-item" rel="tag">design</a><span class="sep">, </span>
    
      
      
      <a href="http://www.skyscribe.me/categories/notes" class="page__taxonomy-item" rel="tag">notes</a><span class="sep">, </span>
    
      
      
      <a href="http://www.skyscribe.me/categories/programming" class="page__taxonomy-item" rel="tag">programming</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fa fa-fw fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2012-08-02T20:55:00+08:00">August 02, 2012</time></p>
        
      </footer>

      
<div id="related-posts">
  <h3>Related posts</h3>
  <ul>
    
      <li>
        <a href="/post/2017/06/04/kotlin-language-functional-programming/" data-score="1.3078602580600884">Kotlin语言之函数式编程</a>
      </li>
    
      <li>
        <a href="/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2/" data-score="0.4369825611963799">Agile software development - the cooperative game - 笔记 - part2</a>
      </li>
    
      <li>
        <a href="/post/2012/11/27/linuxshang-ru-he-cong-c-plus-plus-cheng-xu-zhong-huo-qu-backtracexin-xi/" data-score="0.39098479770482797">Linux上如何从C++程序中获取backtrace信息</a>
      </li>
    
      <li>
        <a href="/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4/" data-score="0.32427539438234765">Agile software development - the cooperative game - 笔记 - 4</a>
      </li>
    
      <li>
        <a href="/post/2017/06/27/excessive-null-checks-in-java-defensive-programming/" data-score="0.2567486508059612">Excessive null checks in Java Defensive Programming?</a>
      </li>
    
  </ul>
</div>


      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=skyscribe&text=Parallel programming in Haskell http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/" class="btn btn--twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/" class="btn btn--facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/" class="btn btn--google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://www.skyscribe.me/post/2012/08/02/parallel-programming-in-haskell/" class="btn btn--linkedin" title="Share on LinkedIn"><i class="fa fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="http://www.skyscribe.me/post/2012/07/23/concurrency-with-haskell/" class="pagination--pager" title="Concurrency with Haskell
">Previous</a>
    
    
      <a href="http://www.skyscribe.me/post/2012/08/12/stm-in-haskell/" class="pagination--pager" title="STM in Haskell
">Next</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
    <h4 class="page__comments-title">Leave a Comment</h4>
    <section id="disqus_thread"></section>
  
</div>

    
  </article>

  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
      <li><a href="https://twitter.com/skyscribe"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
    
      <li><a href="http://github.com/skyscribe"><i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    <li><a href="http://www.skyscribe.me/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright"><a href=https://en.wikipedia.org/wiki/Creative_Commons_license#Types_of_licenses><img src=https://upload.wikimedia.org/wikipedia/commons/d/d0/CC-BY-SA_icon.svg></a> 2017 skyscribe. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a></div>

      </footer>
    </div>

    <script src="http://www.skyscribe.me/assets/js/main.min.js"></script>




  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-101727556-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>






  
  <script type="text/javascript">
  	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  	var disqus_shortname = 'skyscribe';

  	/* * * DON'T EDIT BELOW THIS LINE * * */
  	(function() {
  		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  	})();

  	/* * * DON'T EDIT BELOW THIS LINE * * */
  	(function () {
  		var s = document.createElement('script'); s.async = true;
  		s.type = 'text/javascript';
  		s.src = '//' + disqus_shortname + '.disqus.com/count.js';
  		(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  	}());
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






  </body>
</html>
