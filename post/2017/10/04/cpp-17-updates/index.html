<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.4.1 by Michael Rose
  Copyright 2017 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin SEO -->









<title>C++17整装待发 - 驭风万里无垠</title>




<meta name="description" content="9月份对于C++社区而言绝对是个令人振奋的收获季节。">




<meta name="author" content="Fei Yan">

<meta property="og:locale" content="en">
<meta property="og:site_name" content="驭风万里无垠">
<meta property="og:title" content="C++17整装待发">


  <link rel="canonical" href="https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/">
  <meta property="og:url" content="https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/">



  <meta property="og:description" content="9月份对于C++社区而言绝对是个令人振奋的收获季节。">



  <meta name="twitter:site" content="@skyscribe">
  <meta name="twitter:title" content="C++17整装待发">
  <meta name="twitter:description" content="9月份对于C++社区而言绝对是个令人振奋的收获季节。">
  <meta name="twitter:url" content="https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/">

  
    <meta name="twitter:card" content="summary">
    
  

  
    <meta name="twitter:creator" content="@Fei Yan">
  







  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2017-10-04T00:00:00+08:00">













<!-- end SEO -->


<link href="https://skyscribe.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="驭风万里无垠 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://skyscribe.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->

<meta http-equiv="cleartype" content="on">
    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->
  </head>

  <body class="layout--post">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://skyscribe.github.io/">驭风万里无垠</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/programming/index.html">编程相关</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/notes/index.html">个人笔记</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/tools/index.html">工具相关</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/engineering/index.html">软件工程</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/design/index.html">软件设计</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/haskell/index.html">Haskell</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/cpp/index.html">C++</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/year-archive/index.html">按年份归档</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/tags/index.html">标签汇总</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/categories/index.html">所有分类</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://skyscribe.github.io/about/">关于...</a></li>
          
        </ul>
        <button><div class="navicon"></div></button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    



<div id="main" role="main">
  
  <div class="sidebar sticky">
  

<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="https://skyscribe.github.io/assets/images/me.jpg" class="author__avatar" alt="Fei Yan" itemprop="image">
      
    </div>
  

  <div class="author__content">
    <h3 class="author__name" itemprop="name">Fei Yan</h3>
    
      <p class="author__bio" itemprop="description">
        A curious programmer
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> <span itemprop="name">Hangzhou</span>
        </li>
      

      

      
        <li>
          <a href="mailto:skyscribe.yf@gmail.com">
            <meta itemprop="email" content="skyscribe.yf@gmail.com" />
            <i class="fa fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-linkedin-square" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/skyscribe" itemprop="sameAs">
            <i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      
        <li>
          <a href="https://www.stackoverflow.com/users/222167/fei" itemprop="sameAs">
            <i class="fa fa-fw fa-stack-overflow" aria-hidden="true"></i> Stackoverflow
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fa fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>


  
<h3>
  <a href="/categories/index.html">Categories</a>
</h3>
<div class="tagCloud">
  <ul>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/cpp/index.html">cpp(17)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/tools/index.html">tools(25)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/debugging/index.html">debugging(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/linux/index.html">linux(9)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/build/index.html">build(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/tips/index.html">tips(5)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/test/index.html">test(1)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/study/index.html">study(16)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/notes/index.html">notes(29)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/programming/index.html">programming(47)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/language/index.html">language(21)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/blog/index.html">blog(5)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/doc/index.html">doc(6)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/fp/index.html">fp(7)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/haskell/index.html">haskell(8)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/design/index.html">design(27)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/engineering/index.html">engineering(10)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/protocol/index.html">protocol(1)</a>
  </span>
  </li>
  
  
  
  
  <li>
  <span class="tag">
      <a href="/categories/architecture/index.html">architecture(6)</a>
  </span>
  </li>
  
  </ul>
</div>


  
  </div>




  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="C++17整装待发">
    <meta itemprop="description" content="9月份对于C++社区而言绝对是个令人振奋的收获季节。">
    <meta itemprop="datePublished" content="October 04, 2017">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 class="page__title" itemprop="headline">C++17整装待发
</h1>
          
            <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 






本文有 13693 字，大约需要 34 分钟可以读完, 创建于 2017-10-04



</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        <p>9月份对于C++社区而言绝对是个令人振奋的收获季节。</p>

<!--more-->

<p>先是在９月上旬的时候，语言标准化委员会完成了新的语言标准的<strong>草案投票并取得了全票</strong>通过（虽然有一些小的语法、修辞上的评论待修改）；
Herb Sutter第一时间在<a href="https://herbsutter.com/2017/09/06/c17-is-formally-approved/">其博客上发布了这一激动人心的消息</a>：C++2017已经获得了实质性的通过静待最终发布。
值得注意的是，这是C++这门大象一般行动缓慢的语言在变更为<a href="https://en.wikipedia.org/wiki/Software_release_train">更敏捷的火车发布模型</a>之后，第一次按照时间点准时发布大的语言版本。
之前可是有10多年才发布一个版本（说好的C++0x最终变成了十六进制年份的玩笑）导致开发者等到心凉自己造轮子的事情；而C++14是一个修复设计问题的小版本。</p>

<p>另外一个大事件则是CppCon2017社区大会的成功举办，与往常一样有一大堆的新料演讲(已经放在<a href="https://github.com/CppCon/CppCon2017">这里</a>)放了出来供社区消化、学习。</p>

<h2 id="c17">C++17</h2>
<p>作为一个按照敏捷发布模型出来的第一个大的语言版本，由于需要照顾到质量、时间节点（毕竟需要按时发布）和参考实现成熟度等因素，本来新特性不会很多。
然而作为一个语言的大版本来说，没有一定的新料自然也有滥竽充数的嫌疑；在敏捷的大背景下，谁也不愿意多等都希望马上出来一些质量够好、实现就绪马上可用的新特性；而且要不止一个，因为可供选择的编程语言实在是太多了。</p>

<p>值得庆幸的是，WG21标准化小组早在３月份就完成了新语言特性的草稿准备工作。</p>

<h3 id="语言特性">语言特性</h3>

<p>很多语法糖方面的更新，可以让程序员生产率更高，包括以下这些主要的更新</p>

<h4 id="嵌套的命名空间声明">嵌套的命名空间声明</h4>
<p>这是一个小小的改进，但足以节省大家很多敲击键盘和格式化缩进的烦恼。因为在比较大的项目中，经常用嵌套的命名空间来隔离API和类，之前我们不得不这样写</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">outer</span><span class="p">{</span>
    <span class="k">namespace</span> <span class="n">inner</span> <span class="p">{</span>
        <span class="n">namesapce</span> <span class="n">module</span> <span class="p">{</span>
            <span class="c1">//my module definitions...
</span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>或者为了节省空间（采用微软的换行风格有强迫症的更要哭了），直接缩略为</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">outer</span><span class="p">{</span> <span class="k">namespace</span> <span class="n">inner</span><span class="p">{</span> <span class="k">namespace</span> <span class="n">module</span> <span class="p">{</span>
    <span class="c1">//my module definitions...
</span><span class="p">}}}</span>
</code></pre></div></div>
<p>新标准直接允许我们写为</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">outer</span><span class="o">::</span><span class="n">inner</span><span class="o">::</span><span class="n">module</span> <span class="p">{</span>
    <span class="c1">//my module definitions...
</span><span class="p">}</span>
</code></pre></div></div>
<p>是否清爽了很多，或者有本来就应该如此的感觉？为什么没有更早支持啊。</p>

<h4 id="static_assert的消息提醒参数变为可选"><code class="highlighter-rouge">static_assert</code>的消息提醒参数变为可选</h4>
<p>这个是针对之前引入的用于与编译期间静态检查机制<code class="highlighter-rouge">static_assert</code>的一点小修正，允许其携带的消息提醒参数被忽略，以减少编译噪音。
本来这个静态断言机制可以很好地服务于编译器多态检查，如果没问题就一路继续编译下去，如果出错，则会打印一条错误信息包含在错误诊断中，并终止编译。
新的改动允许不提供该诊断信息。</p>

<h4 id="auto可以用于初始化列表的类型推导"><code class="highlighter-rouge">auto</code>可以用于初始化列表的类型推导</h4>
<p>C++11通过重用<code class="highlighter-rouge">auto</code>关键字来做自动类型推断，而C++17将其扩充到了初始化列表类型，并要求它符合特定的规则。即</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">//decltype(x) = initializer_list&lt;int&gt;:
</span><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="c1">//declytpe(y) = initializer_list&lt;int, int&gt;;
</span><span class="k">auto</span> <span class="n">x1</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">//same as x
</span><span class="k">auto</span> <span class="n">y1</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="c1">//ill-formed! Not a single element!
</span></code></pre></div></div>
<h4 id="字面量类型扩展">字面量类型扩展</h4>
<p>字面量类型具有很好的声明式风格和良好的可读性，之前的语言标准支持的类型比较有限（比如字符常量、整数、浮点常量），而C++17引入了对其他字符集的支持</p>
<ul>
  <li><code class="highlighter-rouge">u8'c-char'</code>用以支持UTF-8编码的字符常量，其类型依然是<code class="highlighter-rouge">char</code>类型，而其值则是用ISO10646编码的单个字符。</li>
  <li><code class="highlighter-rouge">u'c-char'</code>用以支持UCS2编码可以支持２个字节，内部类型是<code class="highlighter-rouge">char16_t</code>,如 <code class="highlighter-rouge">u'\U0001f34c'</code></li>
  <li><code class="highlighter-rouge">U'c-char'</code>支持４个字节的UCS4,内部类型是<code class="highlighter-rouge">char32_t</code>,内部用Unicode编码，比如<code class="highlighter-rouge">U'猫'</code></li>
</ul>

<p>浮点类型的常量声明支持了更多可读性更好的格式，下边的例子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">123.456e-67</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="mf">.1E4</span><span class="n">f</span>       <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="mf">58.</span>         <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="mf">4e2</span>         <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>会输出四种方式所声明的浮点数字如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.23456e-65
1000
58
400
</code></pre></div></div>

<h4 id="可变长模板参数中的折叠表达式">可变长模板参数中的折叠表达式</h4>

<p>C++11 引入了可变长的模板参数，大大简化了模板元编程 (为什么要改进这个 ? 因为语言的设计哲学就是追求<strong>零开销的抽象，这一切都需要强大的模板元编程能力才能二者兼得</strong>) 。
C++17 则支持在变长模板参数中使用折叠 （<code class="highlighter-rouge">fold</code> ） 或归约 (<code class="highlighter-rouge">reduce</code>) , 这两者是函数式编程中最基本的函数单元 ; 最基础的 Haskell 或者 Javascript 教程都会介绍两者 , 
可惜 C++ 才刚刚加入支持 ; 喜欢函数式编程语言的早就改换门庭了吧 :-)</p>

<p>这一新特性可以支持从一堆模板参数中，仅仅指明第一个而省略其他，也可以指明最后一个省略前边的。
这些参数中间可以用操作符来连接，编译器需要自己负责将他们按照既定的规则串联起来。</p>

<p>比如这个例子完成左折叠运算 (如注释所写)</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">all</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">//op is &amp;&amp;, pack parameters as ..., specified last parameter
</span>    <span class="k">return</span> <span class="p">(...</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">);</span> 
<span class="p">}</span>

<span class="c1">//expanded as left fold, as 
// ((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false = false
</span><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">all</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">fold</code> 操作的详细语法定义如下</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">pack</span> <span class="n">op</span> <span class="p">...)</span> <span class="c1">//unary right fold
</span><span class="p">(...</span> <span class="n">op</span> <span class="n">pack</span><span class="p">)</span> <span class="c1">//unary left fold
</span><span class="p">(</span><span class="n">pack</span> <span class="n">op</span> <span class="p">...</span> <span class="n">op</span> <span class="n">init</span><span class="p">)</span> <span class="c1">//binary right fold
</span><span class="p">(</span><span class="n">init</span> <span class="n">op</span> <span class="p">...</span> <span class="n">op</span> <span class="n">pack</span><span class="p">)</span> <span class="c1">//binary left fold 
</span></code></pre></div></div>

<p>运算符可以是所有语法已经定义的运算符或者调用操作 , 然而当我们使用特殊的运算符去带入表达式的时候，代码可能并不是那么直观 , 
下面更复杂一点的例子分别演示了使用标准输出运算符和逗号运算符的情形</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">printer</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//left fold print
</span>    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">...</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">push_back_vec</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//binary left fold, push back from left to right, init=v
</span>    <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>第一个例子中，操作绑定于标准输出流的 <code class="highlighter-rouge">&lt;&lt;</code> 运算符 ，这里使用 <code class="highlighter-rouge">universial reference</code> 可以自动转发避免拷贝。
第二个例子中，对应的操作符为成员函数调用 (<code class="highlighter-rouge">push_back</code> 调用) 。</p>

<p>如下一个例子则用编译器元编程技术实现常量的按bit字节序转换 :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile-time endianness swap based on http://stackoverflow.com/a/36937049 
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">T</span> <span class="n">bswap_impl</span><span class="p">(</span><span class="n">T</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="o">*</span><span class="n">CHAR_BIT</span> <span class="o">&amp;</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">CHAR_BIT</span><span class="p">)</span> <span class="o">|</span> <span class="p">...);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">constexpr</span> <span class="n">U</span> <span class="n">bswap</span><span class="p">(</span><span class="n">T</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bswap_impl</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">bswap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x1234u</span><span class="p">)</span><span class="o">==</span><span class="mh">0x3412u</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">bswap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x0123456789abcdefULL</span><span class="p">)</span><span class="o">==</span><span class="mh">0xefcdab8967452301ULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="constexpr-可以作用于-if-判断"><code class="highlighter-rouge">constexpr</code> 可以作用于 <code class="highlighter-rouge">if</code> 判断</h4>
<p>自从在 C++11 标准中引入以来 , <code class="highlighter-rouge">constexpr</code> 一直有诸多限制和不便，新的语言标准则在一直放宽对其的限制 , 以便提供更高的优化效率 。
简单来说 , <code class="highlighter-rouge">constexpr</code> 用于修饰可能潜在地被编译期计算赋值的函数或者变量 。</p>

<p>C++17 主要放松了之前常量表达式不可用于 <code class="highlighter-rouge">if</code> 判断的限制。它可以达到的效果是 , 对于声明为 <code class="highlighter-rouge">constexpr</code> 的条件表达式 , 
如果传入的参数在编译期没有被命中 ,  则其对应的<strong>代码块甚至可以被编译器优化</strong>掉 。</p>

<p>考虑如下的 C++14 代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Arg</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">X</span><span class="p">,</span> <span class="k">class</span><span class="err">...</span><span class="nc">Xs</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">X</span> <span class="n">x</span><span class="p">,</span> <span class="n">Xs</span><span class="p">...</span><span class="n">xs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Arg</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">xs</span><span class="p">...);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">Arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">X</span><span class="p">,</span> <span class="k">class</span><span class="err">...</span><span class="nc">Xs</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">X</span> <span class="n">x</span><span class="p">,</span> <span class="n">Xs</span><span class="p">...)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//type alias
</span><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">Arg</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span><span class="p">{};</span>

<span class="c1">// arg&lt;2&gt;(0, 1, 2, 3, 4, 5) == 2;
</span></code></pre></div></div>
<p>为了实现提取第 <code class="highlighter-rouge">N</code> 个特定的参数，我们需要大量的模板元代码以实现目的，可读性非常不友好。新的语言特性则允许我们写为</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Get</span><span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">X</span><span class="p">,</span> <span class="k">class</span><span class="err">...</span><span class="nc">Xs</span><span class="o">&gt;</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">xs</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Get</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">xs</span><span class="p">...);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>这里如果对应的分支没有被命中，那么对应的代码可以不用编译，一个明显的好处是可以减少目标代码的体积，
并减少和复杂的模板元技巧斗争的痛苦。
在 Linux GCC7.1 编译上述代码，同样的编译开关和优化选项下，新的版本目标代码体积更小一些，执行速度也略快。</p>

<h3 id="标准程序库">标准程序库</h3>
<p>标准库同时更新了一些新的基础设施，包括用于函数式编程范式的 <code class="highlighter-rouge">optional</code> 类型和类型安全的 <code class="highlighter-rouge">variant</code> 类。</p>

<h4 id="stdoptionalt"><code class="highlighter-rouge">std::optional&lt;T&gt;</code></h4>
<p>类似于 Haskell 中的 <strong>Maybe Monad</strong>，<code class="highlighter-rouge">optional</code>类用于表述一个封装类型，它要么是有初始化好的一个值，要么什么也没有。
该类型最合适的应用场景就是用于返回可能失败也可能成功的情形，这种情况下如果操作成功，那么返回的结果是一个封装过的类型安全的对象，
如果操作失败，则返回空。</p>

<p>其好处是明显提高了代码的可读性，并且提供了方便的构造函数去生成封装好的对象。同时为了便于使用，它还支持隐式转换为 <code class="highlighter-rouge">bool</code> 类型</p>
<ul>
  <li>如果其有值，则返回<code class="highlighter-rouge">true</code></li>
  <li>否则就返回<code class="highlighter-rouge">false</code></li>
</ul>

<p>出于强类型保证考虑，空值的情况下，其封装类型本质上是 <code class="highlighter-rouge">std::nullopt_t</code> 类型，并定义了一个对象 <code class="highlighter-rouge">nullopt</code>, 
标准要求其必须是一个 <code class="highlighter-rouge">constexpr</code> 修饰的编译器常量，实现可以根据具体编译器实现来自主决定。</p>

<p><code class="highlighter-rouge">optional</code>类型支持类型的值提取，用 <code class="highlighter-rouge">value_or</code> 来封装一个取值或者返回一个给定的值的操作。其用法和 
<a href="/ /post/2016/10/14/fp-support-in-java8/">Java8 的Optional</a>类有些相似，
只是它没有提供现成的链式操作封装，API不如Java的丰富。</p>

<h4 id="stdvarianttypes"><code class="highlighter-rouge">std::variant&lt;...Types&gt;</code></h4>

<p><code class="highlighter-rouge">variant</code> 类型用于表述多个不同的可能值的联合类型，任何一个时刻其值可能是给定的模板类型中的一个；初始化完成一个对象后，标准不允许动态
的申请内存。它封装的类型可以任意的对象类型，然而不允许是</p>
<ul>
  <li>引用类型</li>
  <li>数组</li>
  <li>空类型 <code class="highlighter-rouge">void</code></li>
</ul>

<p>一个简单的例子如下</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//initialize variant and hold a value of double type
</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">var</span><span class="p">{</span><span class="mf">12.0</span><span class="p">};</span>

<span class="c1">//default construct from first type, contains 0 of int type
</span><span class="k">decltype</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="n">another</span><span class="p">;</span> 
</code></pre></div></div>

<h5 id="内部参数值的访问">内部参数值的访问</h5>

<p>需要获取其封装的值的时候，可以用<code class="highlighter-rouge">std::get</code>来获取，由于任意时刻其值可能是给定类型的一种，
当对应的值的当前类型和期望获取的类型不匹配时，<code class="highlighter-rouge">get</code> 操作使用 <code class="highlighter-rouge">std::bad_variant_access</code> 异常来传递错误。
<code class="highlighter-rouge">get</code>操作提供两种类型的提取方法，一种是使用索引位置获取，此时可以用<code class="highlighter-rouge">auto</code>类型完成自动类型推导；另外一种方式是使用类型作为模板参数。</p>

<p>标准库也提供了查询操作可以让调用者检查给定的<code class="highlighter-rouge">variant</code>是否当前持有一个给定的类型的值而不抛出异常。
<code class="highlighter-rouge">variant</code> 类型支持<code class="highlighter-rouge">hash</code>操作，因此它可以被放置在 <code class="highlighter-rouge">unordered_map</code> 中作为索引。</p>

<h5 id="赋值">赋值</h5>

<p><code class="highlighter-rouge">variant</code>对象可以被赋值为新的<code class="highlighter-rouge">varant</code> 对象，然而其赋值语义却略微复杂一些，规则是首先判断两者是否同是variant类型，如果是则做如下判断</p>
<ul>
  <li>如果传入的对象和自身都没有持有任何具体值，则什么也不做</li>
  <li>否则如果传入的对象没有持有值但是自身有值，则销毁内部持有的对象并标记自身为不持有值</li>
  <li>否则，判断传入的对象的可能的值类型是否和自身可能持有的值类型完全一致，如果一致则取出传入的对象的值，放入本对象中</li>
  <li>否则对传入的值的可能类型进行检查，如果其类型满足可以被不抛异常的拷贝或者不抛异常的移动，则调用对应类型的<code class="highlighter-rouge">emplace</code>操作</li>
  <li>否则等价于对给定类型加一层 <code class="highlighter-rouge">variant</code> 封装之后的赋值操作</li>
</ul>

<p><code class="highlighter-rouge">variant</code> 对象也支持重新赋值为一个非<code class="highlighter-rouge">variant</code>类型的新值；其赋值逻辑是先从所有的可能的类型中使用类型重载解析来决定可以被转换的类型，
然后判断当前的对象中是否已经持有和选出的类型相同的值 (因为任意时刻其持有的值可能是动态可变的) ，如果是则调用转发赋值；
否则判断是否能用传入参数类型构造出选中的类型的值（可以不抛异常地构造新值或者选中的类型没有不抛异常的移动构造函数），
如果有则相当于对给定类型调用<code class="highlighter-rouge">emplace</code>操作；
否则就用<code class="highlighter-rouge">variant</code>类型封装传入的参数，再调用前述的两个<code class="highlighter-rouge">variant</code>类型的赋值处理逻辑尝试赋值。</p>

<p>考虑如下的例子</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">variant</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">//holds nothing
</span><span class="n">v1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="c1">//construct string and save it
</span>
<span class="n">variant</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">;</span>
<span class="n">v2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="c1">//Error! Resolution fails!
</span>
<span class="n">variant</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">;</span>
<span class="n">v3</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="c1">//choose bool, v3 contains true
</span></code></pre></div></div>
<p>第二个赋值中，由于选不出一个唯一的重载版本赋值，这里最终会编译出错。第三个赋值中，bool 类型被选中作为 <code class="highlighter-rouge">const char*</code> 的接收类型。</p>

<h5 id="特殊的-monostate">特殊的 <code class="highlighter-rouge">monostate</code></h5>
<p>由于<code class="highlighter-rouge">variant</code>类型要求第一个值类型必须可以默认构造，对于不满足默认构造的类型值，如果想将其放入<code class="highlighter-rouge">variant</code>中，则需要下一番功夫。
标准库提供了一个特殊的 <code class="highlighter-rouge">monostate</code> 类型用来处理情况，从而我们可以将其放在第一个类型参数处应对上述情况。
即给定如下定义</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyData</span> <span class="p">{</span>
    <span class="n">MyData</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">v_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//std::varinat&lt;MyData, OtherType&gt; v; wouldn't compile!
</span></code></pre></div></div>

<p>我们可以采用变通的方法构造期望的<code class="highlighter-rouge">variant</code>为 <code class="highlighter-rouge">std::variant&lt;std::monostate, MyData, OtherType&gt;</code>；
这样默认构造出来的对象其实包含了一个空的<code class="highlighter-rouge">monostate</code>对象。</p>

<h5 id="stdvisit函数"><code class="highlighter-rouge">std::visit</code>函数</h5>
<p>该函数其实封装了visitor模式，用于调用一个给定的函数到一系列<code class="highlighter-rouge">variant</code>对象上，其签名如下</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Visitor</span><span class="p">,</span> <span class="k">class</span><span class="err">...</span> <span class="nc">Variants</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="cm">/*result of vis call*/</span> <span class="n">visit</span><span class="p">(</span><span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">vis</span><span class="p">,</span> <span class="n">Variants</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">vars</span><span class="p">);</span>
</code></pre></div></div>
<p>如下的例子可以打印所有的对象</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">var_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">var_t</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7l</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">"hello!"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>
<span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div>
<p>结合上面的<code class="highlighter-rouge">constexpr if</code> 我们可以模拟出类似 Haskell 的类型匹配代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//helper 
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AlwaysFalse</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span>

<span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">declytype</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's a int with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's a long with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's a double with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"It's a string with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">AlwaysFalse</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"non-exhaustive value!"</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="字符串及工具函数">字符串及工具函数</h4>
<p>C++17 将之前放在 <code class="highlighter-rouge">experimental</code> 空间中的 <code class="highlighter-rouge">string_view</code> 正式标准化，放入了 <code class="highlighter-rouge">std</code> 命名空间中。
顾名思义，<code class="highlighter-rouge">string_view</code> 类提供了对某个 <code class="highlighter-rouge">string</code> (或者 C 的数组)  的一个只读的视图，程序员自己必须保证所引用的 <code class="highlighter-rouge">string</code> 对象是有效的。</p>

<p><code class="highlighter-rouge">std::to_chars</code> 和 <code class="highlighter-rouge">std::from_chars</code> 则提供了对字符串和数值类型的相互转换，转换结果存放在一个结构体中，此结构体包含一个指针位置和一个错误码，
如果发生错误，则可以检查转换进行到哪个位置发生了错误。出于性能的考虑，这些转换函数会忽略本地化设置也不会抛出任何异常。
典型的应用场景是诸如XML或者JSON的转换等。</p>

<h2 id="cppcon2017">CppCon2017</h2>
<p>作为一个紧凑的技术社区大会，很多精彩的演讲材料放出来，各行各业的大牛纷纷登台分享；一个明显的趋势是现代的C++社区更加关注泛型编程和模板元编程，
并更加探索语言所能达到的极限。这里仅挑两个个人感兴趣的琢磨一下。</p>

<h3 id="constexpr-的威力"><code class="highlighter-rouge">constexpr</code> 的威力</h3>
<p>Ben Deane 和 Jason Turner 提出了一个大胆的想法，期望<strong>用编译期计算的方法</strong>自动地从一个JSON常量字符串生成一个C++的对象出来，也就是如下的伪代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">jsv</span>
    <span class="o">=</span> <span class="s">R"({
    "feature-x-enabled": true,
    "value-of-y": 1729,
    "z-options": {"a": null,
    "b": "220 and 284",
    "c": [6, 28, 496]}
    })"</span><span class="n">_json</span><span class="p">;</span>

<span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">jsv</span><span class="p">[</span><span class="s">"feature-x-enabled"</span><span class="p">])</span> <span class="p">{</span>
<span class="c1">// code for feature x
</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">// code when feature x turned off
</span><span class="p">}</span>
</code></pre></div></div>

<h4 id="目标">目标</h4>

<p>显然他们想到了<code class="highlighter-rouge">constexpr</code>给出的<strong>更高的执行效率、更清晰的代码、更少跨平台折磨的承诺</strong>；进而他们回顾了C++历史上重要版本对 <code class="highlighter-rouge">constexpr</code> 从诞生到逐步完善过程中
的特性和限制，进而提出了2个需要解决上述问题的重要挑战</p>
<ul>
  <li>如何采用<strong>一致的数据结构</strong>来表示 JSON 数据</li>
  <li>如何解析json串</li>
</ul>

<p>从Json的数据要素上来看，无非是空值、bool类型、字符串、数组和字典类型的组合，而字典类型则本身又包含了值类型，因而我们需要递归处理，
并且需要<strong>设法将<code class="highlighter-rouge">constexpr</code> 应用到所有这些结构</strong>上，才能保证编译期和运行期可以采用一致的算法。</p>

<h4 id="原型">原型</h4>
<p>最简单的地方显然是从字符串类型入手，而且 <code class="highlighter-rouge">string_view</code> 看起来是个不错的选项，可惜某些成员函数不支持 <code class="highlighter-rouge">constexpr</code>, 于是他们自己动手。。。
造了一个类似的 <code class="highlighter-rouge">static_string</code> 并且对所有的函数加上了<code class="highlighter-rouge">constexpr</code>， 看起来还是一切顺利。
接下来一个数据结构是数组，最自然的选择当然是<code class="highlighter-rouge">vector</code> 了， 内部可以用 C++11 中引入的 <code class="highlighter-rouge">std::array</code> 来做，非常清晰自然。
<code class="highlighter-rouge">vector</code>的挑战首先来自于 <code class="highlighter-rouge">push_back</code>，一个疑似的 <code class="highlighter-rouge">std::next() </code> 的bug被挖出来了，在GCC7.2的实现中，
它的一个内部成员是无法用 <code class="highlighter-rouge">constexpr</code> 的方式来构造。</p>

<p>接下来的部分是关于 <code class="highlighter-rouge">map</code> 这一类似的数据结构的，否则我们就没法处理字典类型了。
有人可能问为什么不能用 <code class="highlighter-rouge">std::pair</code> 类型呢？原因仍然是 <strong>既有实现的限制</strong> 导致没法用了，因为它内部有个赋值操作不支持 <code class="highlighter-rouge">constexpr</code>。</p>

<p>搞定了数据结构的部分，剩下的就是算法了；你重写了一些基本容器，当然也需要搞定算法了。
初始版本的自定义容器虽然支持各种<code class="highlighter-rouge">constexpr</code> 操作，但他们还不支持运行时缩放（注意编译器运行也是一个特殊的运行时）并且大小是固定的。
他们想到的可能的改进之道是，封装对象到<code class="highlighter-rouge">std::optional</code> 中去，和改进 <code class="highlighter-rouge">allocator</code> 使其也可以被模板化运算。</p>

<p>解决了这些，剩下的就是解析给定的JSON字符串了。最容易的思路还是从简单的解析器开始，而最简单的解析器莫过于匹配一个给定的字符了。
这一项准备工作完成了对 lambda 表达式的optional封装和 <code class="highlighter-rouge">constexpr</code> 化处理。</p>

<p>有了这个解析器，那么其它复杂一点的对字符串处理的解析就不难完成，譬如匹配某些字符中的一个，可以组合字符串函数和字符匹配解析器完成。
不匹配任何一个字符的解析，或者解析匹配给定字符串都可以迎刃而解。不难看出，这一思路是<strong>函数式编程的组合式思路</strong>。
进而他们将这些<strong>基本的函数式编程特性</strong>借用过来，使用组装得到更为强大的解析器，即使用 <code class="highlighter-rouge">fmap</code> / <code class="highlighter-rouge">bind</code> / <code class="highlighter-rouge">|</code> /<code class="highlighter-rouge">combine</code>,
余下的部分就如砍瓜切菜，上面贴出一些 <code class="highlighter-rouge">Haskell</code> 函数，下面就比葫芦画瓢写 C++ 代码出来。</p>

<h4 id="改进和完善">改进和完善</h4>

<p>很快一个可以工作的基本原型就有了，基本的概念验证宣告结束；当然也有一些问题出来。
第一个技术性的问题，JSON的数字其实不是一个 <code class="highlighter-rouge">int</code> 类型（详情可以翻看JSON的语法定义），乃至JSON的字符串也不能很好的表示为 <code class="highlighter-rouge">string_view</code> ,
第三个问题则是漫长的编译时间（模板元编程的通病）了；幸好一些优化的手段被发掘出来缓解这些问题。</p>

<h4 id="总结">总结</h4>

<p>最后作者们给出了一些结论</p>
<ul>
  <li><strong>所有的标准容器和算法其实都有潜力</strong>被改写为 <code class="highlighter-rouge">constexpr</code> 友好的</li>
  <li>标准库的设施需要通过 <code class="highlighter-rouge">constexpr</code> 的测试来发现问题，这里已经发现了几个</li>
  <li>许多迭代器算法和结构需要改写为 <code class="highlighter-rouge">constexpr</code></li>
  <li><code class="highlighter-rouge">lambda</code> 表达式的 <code class="highlighter-rouge">constexpr</code> 释放了很多未来的扩展空间</li>
</ul>

<h3 id="自动假设系统架构中的现代c规范">自动假设系统架构中的现代C++规范</h3>

<p>Jan Babst探索了自动驾驶领域(AutoSAR)对新的C++编程语言的使用并给出了他们的编程规范和使用建议，非常值得思考和借鉴。</p>

<h4 id="背景">背景</h4>

<p>现代的自动驾驶对软件的需求显著有别于传统的汽车控制软件；传统上来说汽车上的软件系统更像是相互隔离的“孤岛”式系统；各个软件模块各司其职即可。
自动驾驶则需要更多的互操作和中心控制，其<strong>软件架构更接近于一个小型的分布式系统</strong>，同时对性能和时延有极高的要求，稍有延迟则可能引起严重的后果，
这是一个C++占有极大优势的领域，毕竟C++的设计哲学是零成本的抽象。
更多信息可以查看开放自动驾驶系统架构的<a href="www.autosar.org">官方网站</a>。</p>

<p>Jan大概简述了这一领域为什么期望现代的C++语言：尽管很多嵌入式开发软件仍然在使用老旧的C++版本，ISO的安全标准建议最好使用更为现代的技术；
新的开发者当然更喜欢一门现代一点的语言而不是20年前的语言（Bjarne也说过需要像学习一门新语言一样学习现代C++），
更不必说新的C++规范提供了很多标准的简化特性诸如自动类型推导、一致的初始化列表、可变长参数模板、并发和并行支持等。
简而言之，不管是从吸引开发者的角度还是提高代码生产率的角度看，使用<strong>新标准都好处多多，嵌入式领域也不例外</strong>。</p>

<h4 id="编程规范">编程规范</h4>
<p>接下来的部分就是对编程规范的选择和思考了，详细的文档在<a href="https://www.autosar.org/fileadmin/files/standards/adaptive/17-03/general/specs/AUTOSAR_RS_CPP14Guidelines.pdf">这里</a>,
这里Jan介绍了一些重要的规则及为什么这样选择。</p>

<h5 id="是否坚持单一返回">是否坚持单一返回</h5>
<p>函数里面是否允许只有一个地方返回，是一个C/C++里很有争议的话题；C++语言的自动析构和异常机制使得这一问题更加突出。
保守的策略是坚持函数只能在一个地方返回以避免多返回带来的不确定行为和维护难题，原因是多处返回和GOTO是一样的，
而伟大的Dijkstra几十年前就提出了有名的论断给GOTO判了死刑，不是吗？</p>

<p>该标准的前一个版本（2008版，在C++11引入之前）是明确建议单一返回原则的，并且将可能抛异常的情况视作例外规则，
认为异常处理过程不属于返回点；这本质上是自相矛盾的，属于无奈之举。</p>

<p>新的版本里他们认为这条应该被废弃并允许多处返回，因为<strong>如果使用RAII机制，那么天然就会有多个地方的返回处理</strong>；
只要想想自定义对象的析构是应用层代码自己写的就明白，外部使用者在退出作用域的时候就隐式地引入了不同的处理。</p>

<p>代码的复杂性是另外一个问题，强制单一返回势必引入许多额外的条件判断和退出控制逻辑，使得代码的可读性急剧下降，
有时候很难看清楚应该被重点关注的业务逻辑。变量未被初始化引入的未定义行为在复杂的逻辑掩盖下，甚至很难被直接发现；
这些在无形之中都提高了软件维护的成本。</p>

<p>综合来考虑，还是<strong>允许可以在多处返回</strong>好，代码的清晰度会极大提高，方便代码评审和长期维护。</p>

<h5 id="异常的使用">异常的使用</h5>
<p>是否允许使用异常是另外一个极具争议的话题，一方面有Google不许使用异常的先例在前，另一方面的现实情况是，
现代的标准语言库自身就大量使用了异常来处理各个边边角角的情况。
同时 <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-errors">Core Guideline</a> 建议使用异常来传递错误。</p>

<p>AuotSAR的做法是可以使用异常，只要满足</p>
<ul>
  <li>不强制用异常来做错误报告</li>
  <li>不能假设代码可以忽略异常</li>
  <li>正确使用它并在合适的地方用，譬如<strong>不能用异常来控制业务逻辑</strong></li>
  <li>在main函数出需要捕获所有可能的异常，避免默认的coredump引起线上事故</li>
</ul>

<p>其它一些关于异常的思考还包括，如何避免异常的滥用，比如如果函数所作的事情可以正常继续下去，就不要使用异常；
异常安全保证的考虑方面，不强制很高的安全保证等级，仅支持基本的安全约束，因为<strong>写出异常安全的代码在C++里面是极其复杂的</strong>，
只要想想Herb Sutter在这方面也写了三本书就知道其中的水有多深了。</p>

<p>性能损失上的考量，这个其实是和你所用的编译器密切相关的。幸运的是GCC和Clang这两大主流编译器都提供了保证，
在异常没有被触发的情况下，基本<strong>可以做到没有额外开销</strong>。同时他们的规范还额外谨慎地加上了如下</p>
<ul>
  <li>最坏的可能情况必须被仔细分析</li>
  <li>最坏情况下，行为必须是确定的</li>
</ul>

<h5 id="动态内存分配">动态内存分配</h5>
<p>这又是一个嵌入式开发中绕不开的基本问题：很多传统的嵌入式开发都是不允许动态申请和释放内存的；
然而这在现代的C++语言中是几乎不可能的任务，因为标准语言库自身会默默分配、释放内存。
有采用极端策略的规范禁止使用标准库，那么你的工程师得花费大量的时间造一些质量低劣的轮子。
AutoSAR的策略是允许使用动态内存分配，前提是仔细的使用。</p>

<p>首先一个需要考虑的问题是内存泄漏，应对之道是尽可能使用RAII机制来封装，不使用裸的new/delete;毕竟标准库中的智能指针可以满足所有的情况。
内存碎片的问题，可以使用订制内存分配器的方法来缓解，而Jan认为默认的分配器已经足够好了；没有特殊原因可以先从标准库提供的开始；
因为过早优化是万恶之源，怎样界定优化是否太早还是恰当其实是个复杂的问题。
分配器的执行时间必须是确定可分析的是另外一个需要保证的地方；默认的分配器满足这个约束，如果自己订制分配器，那么必须也满足这个要求，
否则会带来意料不到的后果。</p>

<h5 id="其它一些语言特性">其它一些语言特性</h5>

<p>Jan 也谈到了其他一些考虑的特性，这里简要记述一些重要的。</p>

<p>现代C++最显著的特性之一就是lambda表达式和函数式编程的支持；他们的策略是可以使用，但是应该谨慎使用</p>
<ul>
  <li>必须显示指定lambda中需要捕获的上下文变量，避免可能的对象生存期的诡异问题</li>
  <li>总是显示列出参数列表，即使是空函数；这样可以极大提高代码的可读性</li>
  <li>禁止嵌套的lambda表达式，因为可读性实在太差了</li>
</ul>

<p>自动类型推导是另外一个有趣的语言特性，然而其对代码可读性的影响可以是有好有坏，同样需要谨慎使用</p>
<ul>
  <li>可以用在函数调用返回参数的类型声明上</li>
  <li>或者声明一个非基本类型并且这个类型写起来比较臃肿时</li>
</ul>

<p>AutoSAR也禁用了一些标准库设施以便提高代码的可维护性，譬如基本的原子类型、线程和同步原语等都不让在应用层代码中使用，
也许是考虑到应用层代码的程序员大多很难驾驭这些复杂的语言特性吧。</p>

<h2 id="参考和引用">参考和引用</h2>
<ol>
  <li><a href="https://hackernoon.com/a-tour-of-c-17-if-constexpr-3ea62f62ff65">A tour of C++ 17: if constexpr</a></li>
  <li><a href="en.cppreference.com">CPP Reference</a></li>
  <li><a href="https://github.com/CppCon/CppCon2017">CppCon 2017 Github Repo</a></li>
</ol>

        
      </section>

      <div class="relatedPosts">

    <h2>相关文章</h2> 
    <hr/>
    <ul>

    
    
    

    
        

        

        
            <li>
                <a href="/post/2019/11/04/cpp-memory-model-and-order/">现代C++的内存模型和高性能的多线程编程</a>
            </li>
            
            
        

    
        

        

        
            <li>
                <a href="/post/2019/10/06/fuchsia-kernel-ziron-concepts/">Google的新操作系统Fuchsia的内核设计</a>
            </li>
            
            
        

    
        

        

        
            <li>
                <a href="/post/2019/10/04/reduce-cpp-template-overhead/">reduce-cpp-template-overhead</a>
            </li>
            
            
        

    
        

        

        
            <li>
                <a href="/post/2019/10/01/microservice-with-cpp/">微服务开发：C++语言是否真的不适用？</a>
            </li>
            
            
        

    
        

        

        
            <li>
                <a href="/post/2019/08/24/learn-kubernetes-again/">重学Kubernetes - 读张磊的《深度剖析Kubernetes》</a>
            </li>
            
            
        

    
        

        

        
            <li>
                <a href="/post/2019/07/21/from-borg-to-kubernetes/">读Google著名的分布式设计论文－从Borg到Kubernetes的演进</a>
            </li>
            
            
                
    </ul>

</div>


      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="https://skyscribe.github.io/tags/cpp" class="page__taxonomy-item" rel="tag">cpp</a><span class="sep">, </span>
    
      
      
      <a href="https://skyscribe.github.io/tags/fp" class="page__taxonomy-item" rel="tag">fp</a><span class="sep">, </span>
    
      
      
      <a href="https://skyscribe.github.io/tags/language" class="page__taxonomy-item" rel="tag">language</a><span class="sep">, </span>
    
      
      
      <a href="https://skyscribe.github.io/tags/programming" class="page__taxonomy-item" rel="tag">programming</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="https://skyscribe.github.io/categories/cpp" class="page__taxonomy-item" rel="tag">cpp</a><span class="sep">, </span>
    
      
      
      <a href="https://skyscribe.github.io/categories/language" class="page__taxonomy-item" rel="tag">language</a><span class="sep">, </span>
    
      
      
      <a href="https://skyscribe.github.io/categories/programming" class="page__taxonomy-item" rel="tag">programming</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fa fa-fw fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2017-10-04T00:00:00+08:00">October 04, 2017</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=skyscribe&text=C++17整装待发 https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/" class="btn btn--twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/" class="btn btn--facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/" class="btn btn--google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://skyscribe.github.io/post/2017/10/04/cpp-17-updates/" class="btn btn--linkedin" title="Share on LinkedIn"><i class="fa fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


    </div>

    
      <div class="page__comments">
  
  
      <section id="static-comments">
        
          <!-- Start static comments -->
          <div class="js-comments">
            
          </div>
          <!-- End static comments -->

          <!-- Start new comment form -->
          <div class="page__comments-form">
            <h4 class="page__comments-title">Leave a Comment</h4>
            <p class="small">Your email address will not be published. Required fields are marked <span class="required">*</span></p>
            <form id="new_comment" class="page__comments-form js-form form" method="post" action="https://api.staticman.net/v2/entry/skyscribe/my-new-blog-source/master/comments">
              <div class="form__spinner">
                <i class="fas fa-spinner fa-spin fa-3x fa-fw"></i>
                <span class="sr-only">Loading...</span>
              </div>

              <div class="form-group">
                <label for="comment-form-message">Comment <small class="required">*</small></label>
                <textarea type="text" rows="3" id="comment-form-message" name="fields[message]" tabindex="1"></textarea>
                <div class="small help-block"><a href="https://daringfireball.net/projects/markdown/">Markdown is supported.</a></div>
              </div>
              <div class="form-group">
                <label for="comment-form-name">Name <small class="required">*</small></label>
                <input type="text" id="comment-form-name" name="fields[name]" tabindex="2" />
              </div>
              <div class="form-group">
                <label for="comment-form-email">Email address <small class="required">*</small></label>
                <input type="email" id="comment-form-email" name="fields[email]" tabindex="3" />
              </div>
              <div class="form-group">
                <label for="comment-form-url">Website (optional)</label>
                <input type="url" id="comment-form-url" name="fields[url]" tabindex="4"/>
              </div>
              <div class="form-group hidden" style="display: none;">
                <input type="hidden" name="options[slug]" value="cpp-17-updates">
                <label for="comment-form-location">Not used. Leave blank if you are a human.</label>
                <input type="text" id="comment-form-location" name="fields[hidden]" autocomplete="off"/>
                <input type="hidden" name="options[reCaptcha][siteKey]" value="">
                <input type="hidden" name="options[reCaptcha][secret]" value="">
              </div>
              <!-- Start comment form alert messaging -->
              <p class="hidden js-notice">
                <strong class="js-notice-text"></strong>
              </p>
              <!-- End comment form alert messaging -->
              <div class="form-group">
                <div class="g-recaptcha" data-sitekey=""></div>
              </div>
              <div class="form-group">
                <button type="submit" id="comment-form-submit" tabindex="5" class="btn btn--primary btn--large">Submit Comment</button>
              </div>
            </form>
          </div>
          <!-- End new comment form -->
          
        
      </section>
    
</div>

    
  </article>

  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
      <li><a href="https://twitter.com/skyscribe"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
    
      <li><a href="http://github.com/skyscribe"><i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    <li><a href="https://skyscribe.github.io/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright"><a href=https://en.wikipedia.org/wiki/Creative_Commons_license#Types_of_licenses><img src=https://upload.wikimedia.org/wikipedia/commons/d/d0/CC-BY-SA_icon.svg></a> 2019 skyscribe. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a></div>

      </footer>
    </div>

    <script src="https://skyscribe.github.io/assets/js/main.min.js"></script>




  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-101727556-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>










  </body>
</html>
