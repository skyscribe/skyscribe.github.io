<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://www.skyscribe.me/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.skyscribe.me/" rel="alternate" type="text/html" /><updated>2018-03-10T16:00:54+08:00</updated><id>http://www.skyscribe.me/</id><title type="html">驭风万里无垠</title><subtitle>汇小流以成江海，积跬步以至千里</subtitle><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><entry><title type="html">C++17整装待发</title><link href="http://www.skyscribe.me/post/2017/10/04/cpp-17-updates/" rel="alternate" type="text/html" title="C++17整装待发" /><published>2017-10-04T00:00:00+08:00</published><updated>2017-10-04T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/10/04/cpp-17-updates</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/10/04/cpp-17-updates/">&lt;p&gt;9月份对于C++社区而言绝对是个令人振奋的收获季节。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;先是在９月上旬的时候，语言标准化委员会完成了新的语言标准的&lt;strong&gt;草案投票并取得了全票&lt;/strong&gt;通过（虽然有一些小的语法、修辞上的评论待修改）；
Herb Sutter第一时间在&lt;a href=&quot;https://herbsutter.com/2017/09/06/c17-is-formally-approved/&quot;&gt;其博客上发布了这一激动人心的消息&lt;/a&gt;：C++2017已经获得了实质性的通过静待最终发布。
值得注意的是，这是C++这门大象一般行动缓慢的语言在变更为&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_release_train&quot;&gt;更敏捷的火车发布模型&lt;/a&gt;之后，第一次按照时间点准时发布大的语言版本。
之前可是有10多年才发布一个版本（说好的C++0x最终变成了十六进制年份的玩笑）导致开发者等到心凉自己造轮子的事情；而C++14是一个修复设计问题的小版本。&lt;/p&gt;

&lt;p&gt;另外一个大事件则是CppCon2017社区大会的成功举办，与往常一样有一大堆的新料演讲(已经放在&lt;a href=&quot;https://github.com/CppCon/CppCon2017&quot;&gt;这里&lt;/a&gt;)放了出来供社区消化、学习。&lt;/p&gt;

&lt;h2 id=&quot;c17&quot;&gt;C++17&lt;/h2&gt;
&lt;p&gt;作为一个按照敏捷发布模型出来的第一个大的语言版本，由于需要照顾到质量、时间节点（毕竟需要按时发布）和参考实现成熟度等因素，本来新特性不会很多。
然而作为一个语言的大版本来说，没有一定的新料自然也有滥竽充数的嫌疑；在敏捷的大背景下，谁也不愿意多等都希望马上出来一些质量够好、实现就绪马上可用的新特性；而且要不止一个，因为可供选择的编程语言实在是太多了。&lt;/p&gt;

&lt;p&gt;值得庆幸的是，WG21标准化小组早在３月份就完成了新语言特性的草稿准备工作。&lt;/p&gt;

&lt;h3 id=&quot;语言特性&quot;&gt;语言特性&lt;/h3&gt;

&lt;p&gt;很多语法糖方面的更新，可以让程序员生产率更高，包括以下这些主要的更新&lt;/p&gt;

&lt;h4 id=&quot;嵌套的命名空间声明&quot;&gt;嵌套的命名空间声明&lt;/h4&gt;
&lt;p&gt;这是一个小小的改进，但足以节省大家很多敲击键盘和格式化缩进的烦恼。因为在比较大的项目中，经常用嵌套的命名空间来隔离API和类，之前我们不得不这样写&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;namesapce&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//my module definitions...
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者为了节省空间（采用微软的换行风格有强迫症的更要哭了），直接缩略为&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//my module definitions...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;新标准直接允许我们写为&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//my module definitions...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;是否清爽了很多，或者有本来就应该如此的感觉？为什么没有更早支持啊。&lt;/p&gt;

&lt;h4 id=&quot;static_assert的消息提醒参数变为可选&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static_assert&lt;/code&gt;的消息提醒参数变为可选&lt;/h4&gt;
&lt;p&gt;这个是针对之前引入的用于与编译期间静态检查机制&lt;code class=&quot;highlighter-rouge&quot;&gt;static_assert&lt;/code&gt;的一点小修正，允许其携带的消息提醒参数被忽略，以减少编译噪音。
本来这个静态断言机制可以很好地服务于编译器多态检查，如果没问题就一路继续编译下去，如果出错，则会打印一条错误信息包含在错误诊断中，并终止编译。
新的改动允许不提供该诊断信息。&lt;/p&gt;

&lt;h4 id=&quot;auto可以用于初始化列表的类型推导&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;可以用于初始化列表的类型推导&lt;/h4&gt;
&lt;p&gt;C++11通过重用&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;关键字来做自动类型推断，而C++17将其扩充到了初始化列表类型，并要求它符合特定的规则。即&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//decltype(x) = initializer_list&amp;lt;int&amp;gt;:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//declytpe(y) = initializer_list&amp;lt;int, int&amp;gt;;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//same as x
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//ill-formed! Not a single element!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;字面量类型扩展&quot;&gt;字面量类型扩展&lt;/h4&gt;
&lt;p&gt;字面量类型具有很好的声明式风格和良好的可读性，之前的语言标准支持的类型比较有限（比如字符常量、整数、浮点常量），而C++17引入了对其他字符集的支持&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u8'c-char'&lt;/code&gt;用以支持UTF-8编码的字符常量，其类型依然是&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;类型，而其值则是用ISO10646编码的单个字符。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u'c-char'&lt;/code&gt;用以支持UCS2编码可以支持２个字节，内部类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;char16_t&lt;/code&gt;,如 &lt;code class=&quot;highlighter-rouge&quot;&gt;u'\U0001f34c'&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;U'c-char'&lt;/code&gt;支持４个字节的UCS4,内部类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;char32_t&lt;/code&gt;,内部用Unicode编码，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;U'猫'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浮点类型的常量声明支持了更多可读性更好的格式，下边的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;123.456e-67&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;.1E4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;58.&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4e2&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;会输出四种方式所生命的浮点数字&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.23456e-65
1000
58
400
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;可变长模板参数中的折叠表达式&quot;&gt;可变长模板参数中的折叠表达式&lt;/h4&gt;
&lt;p&gt;C++11引入了可变长的模板参数，大大简化了模板元编程，而C++17则支持在变长模板参数中使用折叠或归约(函数式编程中的基本范式),
可以支持从一堆模板参数中，指明第一个而省略其他，也可以指明最后一个省略前边的。这些参数中间可以用操作符来连接，编译器需要自己负责将他们按照既定的规则串联起来。&lt;/p&gt;

&lt;p&gt;比如这个例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;//op is &amp;amp;&amp;amp;, pack parameters as ..., specified last parameter
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//expanded as left fold, as 
// ((true &amp;amp;&amp;amp; true) &amp;amp;&amp;amp; true) &amp;amp;&amp;amp; false = false
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细的定义如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//unary right fold
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//unary left fold
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//binary right fold
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//binary left fold 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个更复杂一点的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//left fold print
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_back_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//binary left fold, push back from left to right, init=v
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;// compile-time endianness swap based on http://stackoverflow.com/a/36937049 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bswap_impl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CHAR_BIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CHAR_BIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_unsigned_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bswap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bswap_impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push_back_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push_back_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;static_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bswap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1234u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3412u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bswap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0123456789abcdefULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xefcdab8967452301ULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;#&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;标准程序库&quot;&gt;标准程序库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;stdoptionalt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;h4 id=&quot;stdvarianttypes&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::variant&amp;lt;...Types&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;h2 id=&quot;cppcon2017&quot;&gt;CppCon2017&lt;/h2&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="cpp" /><category term="language" /><category term="fp" /><summary type="html">9月份对于C++社区而言绝对是个令人振奋的收获季节。</summary></entry><entry><title type="html">数据访问与管理技术的演进</title><link href="http://www.skyscribe.me/post/2017/09/24/data-management-evolution/" rel="alternate" type="text/html" title="数据访问与管理技术的演进" /><published>2017-09-24T00:00:00+08:00</published><updated>2017-09-24T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/09/24/data-management-evolution</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/09/24/data-management-evolution/">&lt;p&gt;数据访问和管理是软件设计需要解决的一项非常关键而又基础的问题;从早期的大型Unix应用开始，到基于C/S架构的商业应用，
乃至在互联网大潮中取得压倒性优势的基于B/S架构的企业应用，对于如何管理、访问、保存、检索、备份、维护数据这一基本问题，
无数先辈们创造了丰富多样的技术选项，然而随着行业潮流的变换，不同的技术依然在它各自适应的领域闪耀这光芒。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;数据访问管理技术的关键要素&quot;&gt;数据访问、管理技术的关键要素&lt;/h2&gt;
&lt;p&gt;到目前为止，几乎所有的软件依然是工作在冯诺依曼设定的计算机架构之上,因而从&lt;strong&gt;最微观的粒度看,运算器、控制器、存储设备互相配合&lt;/strong&gt;完成形形色色的任务。
各色复杂的软件都要在此基础上做更高层次的抽象和封装，才能完成复杂度更高的任务。程序语言、编译器和各种各样的库函数、中间件等则都围绕着该基本模型来处理高层次的领域相关问题。&lt;/p&gt;

&lt;p&gt;由于最底层的硬件要么具有访问速度快但易失性的特点，要么是访问速度慢但可以持续保存很长时间；同时硬件在长时间工作的情况下总会面临各种各样的失败。
面向业务问题的计算机&lt;strong&gt;软件必须要被仔细设计以隔离上述问题，使得用户觉得失败永远不可能发生&lt;/strong&gt;（或者至少是现实意义上的不会失败）。
这对数据的访问和管理技术提出了很高的挑战&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据容量在需要的情况下能尽可能地大，甚至是可以&lt;strong&gt;按需动态扩展&lt;/strong&gt;；传统上基于单机的数据存储模型被扩展到可以被存储在地理上分散的网络节点&lt;/li&gt;
  &lt;li&gt;数据访问的延时需要满足特定的场景需求；由于数据可能被存放在不同的设备上，不同的存储设备有不同的访问性能和时延特性&lt;/li&gt;
  &lt;li&gt;多用户同时访问的一致性：复杂的应用总会允许有逻辑上同时访问数据的需求，如果是访问同样的数据或者相互有逻辑关联的数据，用户不应该得到不一致的数据状态&lt;/li&gt;
  &lt;li&gt;数据的可靠性：在任何硬件失效的情况下，数据的丢失总是应该被尽量杜绝的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些目标、挑战有些是互相矛盾的，因此在现有的技术条件下并没有出现过一种一招通吃的方案，各色各样的技术方案都会在某些方面有所取舍。
只是在同样的取舍考虑下，优秀的技术能比它的竞争对手们做的更为出色。&lt;/p&gt;

&lt;h2 id=&quot;前关系数据库时期的数据结构和文件方案&quot;&gt;前“关系数据库”时期的数据结构和文件方案&lt;/h2&gt;
&lt;p&gt;在20世纪70年代关系数据库理论出现之前，软件已经被用于解决很多形形色色的问题了， 这个时期其实并没有专门针对数据管理的特定技术。&lt;/p&gt;

&lt;h3 id=&quot;基于操作系统和基本库的思路&quot;&gt;基于操作系统和基本库的思路&lt;/h3&gt;
&lt;p&gt;需要管理和访问数据的时候，最基本的方案就是依赖操作系统和编程语言提供的基础设施了。
这种场景下数据的访问&lt;strong&gt;基本是没有很强的结构化特性&lt;/strong&gt;的，软件的规模也不是太大，因而直接依赖于底层的机制也算够用了。&lt;/p&gt;

&lt;p&gt;数据组织上基本以常用的数据结构为主，从最简单的顺序数组，到稍微复杂一点的链表结构，乃至树形结构、跳表、哈希表等依赖于计算机内部存储（处理器寄存器乃至内存）的高效数据机构。这些数据组织方式特别适合于规模不大的数据管理；
其优点是数据的访问和存取都比较高效，然而其限制也比较明显，数据量比较大的时候，就必须找数据持久化存储的方法。&lt;/p&gt;

&lt;p&gt;一种最简单的方式是将数据用文件的方式写入到外部存储设备中；然后在需要的时候在从外部设备加载回来。
数据量超过内部存储容量（或者超出预先分配的空间）的时候，可以用选择性的方式将某些数据换回到外部设备中。&lt;/p&gt;

&lt;h3 id=&quot;问题和挑战&quot;&gt;问题和挑战&lt;/h3&gt;
&lt;p&gt;带来的挑战是如何选择合适的算法来确定什么时候需要将数据保存到外部存储设备，或者何时需要将数据加载到内存中。
另外一个难题是如果&lt;strong&gt;存储设备出错了，应该怎样应对这些错误&lt;/strong&gt;?对操作系统和通用的库函数来说，这可是应用程序自己的责任。
由于应用程序的处理逻辑和数据管理、控制逻辑是放在一起的，这些异常处理和策略选择会使软件的逻辑复杂度大大提高。&lt;/p&gt;

&lt;h4 id=&quot;数据抽象能力和校验&quot;&gt;数据抽象能力和校验&lt;/h4&gt;
&lt;p&gt;因为操作系统和函数库提供了非常基本的抽象，数据结构之上所承载的数据格式定义，以及数据内容之间的相互关联关系都需要应用程序自己负责维护。
当有大量类似关系的数据需要在多个地方处理和保存的时候，就会出现明显的代码重复并引入额外的维护想难题。&lt;/p&gt;

&lt;p&gt;一个可行的方案是当程序的规模变得比较大的时候，提供统一的应用层封装库最为基础设施给开发人员使用；
不足之处是维护这样的&lt;strong&gt;通用基础设施的技术复杂度比一般的上层程序逻辑要复杂&lt;/strong&gt;，需要考虑到很多负责的异常情况并有很强的适应性以匹配各种期望的场景。
还有一种考虑是可以购买第三方成熟的中间件系统以减小维护成本；不利之处是系统出了问题的时候，仍然需要对所使用的软件有很深入的了解才能快速解决复杂问题；
尤其当实际场景对安全性或者法律合规方面有比较打顾虑的时候，第三方软件的成熟度可能成为一个极大的问题，
有时候如果这些第三方软件的设计缺陷没有被及早发现的话，后果可能更加难以承受。&lt;/p&gt;

&lt;h4 id=&quot;存储设备特性和性能考量&quot;&gt;存储设备特性和性能考量&lt;/h4&gt;
&lt;p&gt;另外一个挑战是当数据容量变得特别巨大的时候，不可避免的需要将存储设备放在不同的物理机器上，
然后通过网络通信协议的方式（比如NFS）将远端机器上的文件系统挂载在本地机器上；使本地机器以为它是在控制“本地”的文件;
而微观上所有的操作都是通过一个网络通信通道（socket）加上对应的控制协议和数据搬运协议来完成。&lt;/p&gt;

&lt;p&gt;从寄存器到内存到磁盘再到网络磁盘，数据的容量是越来越大，然而其性能和延迟也急速下降；对CPU寄存器的访问可能几个时钟周期就可以完成（虽然其容量很小），
对内存的一次读写需要的时间就会达到几十乃至数百倍，访问本地磁盘的延时往往是毫秒级甚至几十毫秒；当文件被用NFS的方式映射到本地的时候，
一次访问的时间可能在数十毫秒乃至数秒；因为&lt;strong&gt;网络层的封装可能是很厚重的，往往一个简单的操作可能后台需要好几次消息的来回&lt;/strong&gt;才能完成。
如果网络出现拥堵或者中间设备出现故障，系统行为将变得更加难以预料。&lt;/p&gt;

&lt;p&gt;这些时间上的开销给软件开发带来了诸多挑战 - 长时间的延时（要么是库函数调用要么是系统调用）导致同步调用变得效率底下，甚至抵消了多线程编程带来的便利。
由于太多阻塞的操作导致处理器使用率底下，更高的吞吐率难以达到，我们不得不借助于异步编程技术来分割应用程序的逻辑。&lt;/p&gt;

&lt;h4 id=&quot;编程模型和协作的挑战&quot;&gt;编程模型和协作的挑战&lt;/h4&gt;
&lt;p&gt;可惜的是，因为IO行为的差异引发的编程模型的转化是的软件的可维护行大大降低。
试想一个简单的业务逻辑因为需要访问外部存储设备而被分割成２个任务，丢在２个不同的线程调度器里，通过IO完成的callback事件关联在一起；
这比基于内存数据的顺序处理逻辑复杂多了。&lt;/p&gt;

&lt;p&gt;虽然函数式编程模型或者Reactor模型可以应对这一设计挑战，但是仅仅因为数据访问的原因而变更熟悉的编程模型并不是在很多场景下都可以被轻易接受；
毕竟软件开发是依赖于人的集体智力活动。&lt;/p&gt;

&lt;h3 id=&quot;对软件设计和架构的影响&quot;&gt;对软件设计和架构的影响&lt;/h3&gt;
&lt;p&gt;这些&lt;strong&gt;非功能的属性会极大影响到应用程序的逻辑设计&lt;/strong&gt;；软件设计人员不得不在开发的早期阶段谨慎选择，以免掉入性能不足的漩涡最后不得不重写代码。
本来软件的抽象是为了解决应用领域的复杂问题，隔离底层的细节，不幸的是&lt;strong&gt;当底层细节的不同影响到了程序整体的行为的时候，这种关注点分离的方式就很难凑效&lt;/strong&gt;。
尽管有各种各样的限制，在很多复杂度不是很高的场景下，基于操作系统和基础设施的数据管理方案仍然是最直观且最优的选择。
只要切记在合适的时机依据需求的变化切换到更合适的方案上来即可；要么是变更的成本不大可以直接修改代码完成之，要么是一开始的时候设计好数据访问的隔离，
才与适配器的模式隔离数据访问部分。&lt;/p&gt;

&lt;h2 id=&quot;基于严格结构化的关系数据库技术sql&quot;&gt;基于严格结构化的关系数据库技术(SQL)&lt;/h2&gt;

&lt;p&gt;关系数据库技术自从上个世纪７０～８０年代诞生以来便得到了业界的青睐；其&lt;strong&gt;清晰的模型和严格的数学理论论证&lt;/strong&gt;深刻地征服了各个主要的IT厂商，
其采用专门的属于来规范数据的定义和各种功能、非功能属性，学院式的精心设计预先考虑到了各种各样可能出现的问题。&lt;/p&gt;

&lt;h3 id=&quot;基本机制和思路&quot;&gt;基本机制和思路&lt;/h3&gt;
&lt;p&gt;关系数据库理论采用结构化的方式定义数据，严格的区分数据定义、处理的范围和边界。
数据库管理系统作为专门的软件系统隔离了数据的定义、操作；应用程序通过预先定义的接口JDBC/ODBC等接口访问数据库系统。&lt;/p&gt;

&lt;h4 id=&quot;数据定义&quot;&gt;数据定义&lt;/h4&gt;
&lt;p&gt;数据的&lt;strong&gt;结构抽象用schema来表述，逻辑上所有的数据都是满足给定schema的二维表&lt;/strong&gt;，每一行是一条记录；所有的记录都具有相同的列。
每一行数据的相同列具有相同的定义和约束；每一行数据中的某些列作为访问的关键列（称为键）。这些列有些可以为空有些则必须不能为空。
对数据的访问则以行为单位，可以进行增加、删除、修改等变更性操作和根据某些条件进行查询。
&lt;strong&gt;数据的完整性校验可以通过在数据发生变更的时候依靠数据库系统软件的自动检查&lt;/strong&gt;来完成。&lt;/p&gt;

&lt;p&gt;数据表之间可以有丰富多样的相互关联(通过主键、外键设置)，从而支持在查询的时候跨越多个表进行复杂的检索。
为了便于应用逻辑处理，关系数据库系统还提供了虚拟的表（称之为视图），这些虚拟的表结构可以基于底层实际的”物理记录表”信息的变化而自动更新；
触发器则支持设置类似于应用程序指定的“自动操作”，当对应的数据被更新的时候，触发器会被自动运行。&lt;/p&gt;

&lt;p&gt;通常情况下，复杂的业务数据&lt;strong&gt;可以依据不同的范围来隔离&lt;/strong&gt;，可以放在不同的数据库中，也可以放在同一个数据库的不同数据表中。
多个数据表之间的逻辑关联关系用关系代数来描述，一般不同的数据表之间有相对的关联，
比如某个表的某一列也出现在另外一个表中作为另外一个表的主键，这样查询的时候，可以将两个表联合起来提供单个表不能提供的丰富信息。&lt;/p&gt;

&lt;p&gt;数据表之间的关系用数据库范式来描述，严格的关系数据库理论定义了多种关系范式，用以描述信息的冗余度、结构化程度；不同的范式可以大概表征数据一致性的维护难度。
&lt;strong&gt;复杂的范式往往也会带来性能开销和处理复杂度&lt;/strong&gt;，因此商业的应用程序中一般出于性能考虑不会采用很高的范式。&lt;/p&gt;

&lt;h4 id=&quot;数据查询和sql语言&quot;&gt;数据查询和SQL语言&lt;/h4&gt;
&lt;p&gt;关系数据库系统一个最引人注目的特性是提供了一个关于数据定义的结构化模型和&lt;strong&gt;接近于自然语言的领域特定语言SQL&lt;/strong&gt;，并将其和关系代数理论紧密结合在一起。
SQL语言采用了类似于英语的语法，以数据查询为中心同时兼顾增加、删除和修改操作，
并支持对数据集的聚集、归并、分类、排序等常见的操作，实现了对数据管理和访问的细节隔离，使得&lt;strong&gt;应用程序仅仅需要关注于数据操作的意图&lt;/strong&gt;即可。&lt;/p&gt;

&lt;p&gt;SQL是面向数据操纵和访问用户的接口语言，数据库管理系统可以优化用户提供的SQL查询，转换成性能最好的内部实现。
这也是DSL的好处，整个数据库管理系统&lt;strong&gt;通过精心定义的查询语言将接口和实现分离&lt;/strong&gt;开；应用程序可以专注于业务逻辑的实现，而数据库关系系统可以专注于数据的管理和维护。
这也是计算机科学一直采用的基本的分而治之的思路－分割问题领域，然后在各个击破之。
从这个意义上来说，关系数据库系统提供了&lt;strong&gt;良好的抽象和职责分离&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;查询优化和索引&quot;&gt;查询优化和索引&lt;/h4&gt;
&lt;p&gt;由于商业数据库的数据往往数据量非常大，可能被保存很长时间，因此大部分时候，绝大部分数据都是被保存在磁盘中（甚至是网络磁盘）并在需要的时候读取进来加载进内存中给用户使用。大部分时候，用户的查询操作比修改操作要多得多，因此查询的性能是至关重要的。&lt;/p&gt;

&lt;p&gt;虽然数据很多，但是&lt;strong&gt;某个时候用户需要访问的可能只是一小部分数据，怎样快速地检索&lt;/strong&gt;到对应的数据并提供给用户就变得至关重要。
关系数据库系统一般是通过在数据表上建立索引表来实现的，同时基于成熟的B+数数据结构，保证经过少数几次的磁盘IO读写操作就可以定位到具体的数据记录存储快，然后将对应的块读出操作系统内存中去。
这也潜在的要求数据库系统组织&lt;strong&gt;数据存储的时候，需要按照记录块的方式&lt;/strong&gt;将其存储在外部设备中；并最好和操作系统的虚拟内存所支持的页面大小保持对齐，尽可能减少磁盘的读写次数和寻道时间。&lt;/p&gt;

&lt;p&gt;当数据量特别大以至于简单的索引表也无法加载进内存的时候，可能需要建立多级索引结构，用一个新的结构指向某一部分数据的索引表在磁盘上存储的位置；而只是将最顶层的索引表放在内存中。
查询的时候，则需要先通过一级索引找到对应小范围数据记录对应的索引的存储位置，通过一次额外的磁盘操作加载二级索引，然后通过二级索引的数检索操作，找到对应的数据块的物理位置。&lt;/p&gt;

&lt;p&gt;实际情况下，往往通过少数几次的IO操作（通过B+树的算法保证）便可定位到实际的数据并将其加载入内存中，减少慢速IO对性能的不利影响。&lt;/p&gt;

&lt;h4 id=&quot;事务及acid属性&quot;&gt;事务及ACID属性&lt;/h4&gt;
&lt;p&gt;作为数据的访问接口，SQL定义了复杂的查询接口以适应复杂的数据访问、管理需求；然而深入到最底层，细粒度的数据访问仍然要落实到二维数据表的某一个行记录上。
由于这些单一的行是操作的最小粒度，数据库处理系统必须要保证对记录的访问在外部用户看来总是处于合理的状态。&lt;/p&gt;

&lt;p&gt;譬如一个用户打算修改某记录的一个列值，而另外一个用户可能同时打算删除该记录，那么&lt;strong&gt;两个用户可能是并行在使用数据库&lt;/strong&gt;，数据库系统必须保证两者的操作返回之后，数据库系统人然处于一个自然的状态；
要么某个用户操作成功返回修改生效，另外一个用户得到失败的反馈，要么２者都失败需要某一方尝试重试，要么数据库系统在内部实现某种机制保证至少一个成功一个失败。
当实际操作的SQL语句牵扯到多个数据表操作的时候，一致性保证将变得更为困难。因为从并发控制的角度来看，只要牵扯到同一个数据的读写，既要保证读到的数据不能是中间状态，也要保证写入之后数据库中的状态需要恰好是刚刚写入的值。&lt;/p&gt;

&lt;p&gt;关系数据库系统&lt;strong&gt;用事务作为数据操作的基本单元的抽象&lt;/strong&gt;，一个事务用来封装一次对数据库的操作；关系数据库系统用内部机制保证事物操作满足四个基本的属性&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;原子性(Atomicy)：事务操作必须像是在一个最基本的操作中完成的，执行过程中不会被另外一个打断&lt;/li&gt;
  &lt;li&gt;一致性(Consistency)：一个事务被提交执行前后，数据库系统中所有的相关数据仍然处于一致性的状态，要么数据被按照事务期望的方式被修改（事务被执行），要么完全保持原样（事务撤销）&lt;/li&gt;
  &lt;li&gt;隔离性(Isolation)：各个事务的执行和调度对应用程序是不可见的；从事务提交者的角度来看，好像就他自己在使用数据库系统&lt;/li&gt;
  &lt;li&gt;持久性(Durablility)：事务操作的结果是持久有效的，即使是发生了故障或者重启，已经发生的修改必须被永久保存下去；不允许数据丢失情况的发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ACID是关系数据库系统的基本特征，甚至于不支持ACID特性的数据库软件都不被认为是关系数据库软件；它被各大数据库厂商广泛地支持和实现。&lt;/p&gt;

&lt;h3 id=&quot;问题和挑战-1&quot;&gt;问题和挑战&lt;/h3&gt;

&lt;p&gt;ACID里边&lt;strong&gt;最为关键和复杂的就是一致性和持久性&lt;/strong&gt;，尤其是当数据库系统的访问可能来自与网络的时候，由于延时的增加以及不可预期的复杂事务可能被远程调度执行，如何&lt;strong&gt;高效、公平地实现事务的一致性控制&lt;/strong&gt;，又不引起性能的急剧恶化是个巨大的挑战。
从数据持久性角度来看，数据库系统作为一个应用软件本身是运行在操作系统的用户空间，而真正将数据的更新落地到非易失性存储设备需要经历上层的IO调度到操作系统内核空间的控制和数据搬运，操作系统内核的实现和磁盘驱动的读写等等一系列异步操作，
数据库系统需要始终保证&lt;strong&gt;任何一个环节出错，数据总是能恢复到正确的状态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了实现这些复杂特性，很多数据库厂商（譬如Oracle）会通过修改操作系统驱动甚至内核等方式在可用性和性能之间进行折中。
同时为了提高可用性并兼顾性能，某些数据库系统会&lt;strong&gt;要求有非常好的单机性能&lt;/strong&gt;，使用具有高级特性的磁盘存储设备等。&lt;/p&gt;

&lt;h4 id=&quot;和面行对象软件系统的集成难题&quot;&gt;和面行对象软件系统的集成难题&lt;/h4&gt;
&lt;p&gt;关系数据库理论早于面向对象技术出现，然而软件开发领域内面向对象技术则在80~90年代迅速席卷了行业的大部分角落。
应用程序上层用面向对象技术写成的特点注定了当它需要去访问数据的时候，&lt;strong&gt;中间提供隔离的层次需要协调两者模型上的不一致&lt;/strong&gt;：
面向对象技术组织数据操作的方式是通过继承、封装和多态来提供抽象能力，而数据库技术的组合方式是基于SQL查询。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORM技术&lt;/a&gt;被发明出来用以实现传统的&lt;a href=&quot;https://www.martinfowler.com/books/eaa.html&quot;&gt;企业应用架构&lt;/a&gt;中的对象和关系模型的映射，虽然&lt;strong&gt;有一些复杂的框架技术来缓解这一难题&lt;/strong&gt;，总归是显得复杂而臃肿。
好在Java语言用类型注解的方式提供了相对优雅的解决方案，从而通过少数几行代码就可以注入约束和检查，大大减小了数据访问层的负担。&lt;/p&gt;

&lt;h4 id=&quot;扩展性的挑战&quot;&gt;扩展性的挑战&lt;/h4&gt;
&lt;p&gt;由于商业数据库有很大的数据需要存储和使用，当系统需要动态扩展以支持更多的业务量的时候，&lt;strong&gt;单实例、中心化的数据库系统往往能为扩展性的瓶颈&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;维护数据一致性的代价越来越大，因为分布式数据库系统的扩展和优化需要面对&lt;a href=&quot;http://robertgreiner.com/2014/08/cap-theorem-revisited/&quot;&gt;CAP理论&lt;/a&gt;的限制：要么保证可用性牺牲一致性，要么保证一致性牺牲可用性。
当有２个并发的用户访问数据库系统的时候，既保证数据的一致性，又保存高度的可用性会成为巨大的挑战,即如下的情况，在没有异常发生的时候N1的更新很容易通过网络同步、复制的方式被N2看到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.julianbrowne.com/assets/attachments/brewers-cap-theorem/images/scenario-1.png&quot; alt=&quot;normal case&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当网络发生异常的时候，就会出现不一致&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.julianbrowne.com/assets/attachments/brewers-cap-theorem/images/scenario-2.png&quot; alt=&quot;network failure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;网络分割是无法妥协的，因为没有足够强大的机器来维持足够好的单机器性能;分布式应用基本无法在实际中妥协了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;No set of failures less than total network failure is allowed to cause the system to respond incorrectly.&lt;/p&gt;

  &lt;p&gt;— &lt;a href=&quot;http://www.julianbrowne.com/article/viewer/brewers-cap-theorem&quot;&gt;Partition Tolerance as defined by Gilbert &amp;amp; Lynn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似于两阶段提交算法等分布式事务(2PC)处理机制从理论的角度看起来很美好，实际应用中却因为性能过于低下而被束之高阁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成本和投入产出比&lt;/strong&gt;也是需要考虑的显示因素，因为传统的关系数据库系统需要强大的专有硬件（如磁盘RAID、EMC专业存储方案）来保证较高的可靠性和可用性。
在互联网技术日益发展深入的背景下，企业需要尽量控制IT支撑环境的成本，并快速部署给用户，并&lt;strong&gt;需要技术架构和实现能随着业务量的增加而快速演进&lt;/strong&gt;，传统的将数据库作为独立中间件部署的方式因为太厚重而慢慢被边缘化了。&lt;/p&gt;

&lt;h2 id=&quot;非结构化数据和nosql技术&quot;&gt;非结构化数据和NoSQL技术&lt;/h2&gt;
&lt;p&gt;21世纪头十年互联网技术的严谨为提非结构化数据(即键值数据库系统)蓬勃发展的土壤。从关系数据库理论的角度来看，没有提供ACID支持的数据库甚至都不叫数据库系统；
然而新世纪IT技术对越来越多行业的深入改造带来了数量巨大的数据；而很多数据并不是天然具有很强的结构化特性；将他们强赛进关系数据库系统中会带来臃肿的设计、复杂的模型以及地下的性能。&lt;/p&gt;

&lt;h3 id=&quot;基本思路&quot;&gt;基本思路&lt;/h3&gt;
&lt;p&gt;NoSQL技术从简化数据管理的角度来解决这一难题：一方面我们有大量的数据需要存储，这些数据之间没有非常强的相互关联；另外一方面对这些数据的访问可能有很高的并发需求和扩展性需求。
&lt;strong&gt;既然关系数据库提供的东西远远多于实际需要的，何不将这些复杂的功能向上移动到应用程序问题域&lt;/strong&gt;内？
这样数据库系统仅仅需要管理没太多逻辑结构的数据，并提供足够好的并发访问性能、可扩展性、可靠性；而将怎样使用数据交给应用程序去处理？
毕竟最了解数据使用场景的还是上层应用程序。&lt;/p&gt;

&lt;h3 id=&quot;数据管理特性和元数据&quot;&gt;数据管理特性和元数据&lt;/h3&gt;
&lt;p&gt;NoSQL其实不是一类技术的统称，而是不采用强结构化形式管理数据的一大堆数据管理技术的集合。
不同的方案提供不同的技术实现，并呈现出不同的特性；从简单的基于纯粹Key-Value对的大数据集合到能够提供一些稍微复杂一点的如关联映射、集合类型的多类型数据管理系统3（典型如Redis），
乃至提供一些比较复杂的&lt;a href=&quot;https://en.wikipedia.org/wiki/Document-oriented_database&quot;&gt;面向文档&lt;/a&gt;的数据结构（相比SQL可以认为是半结构化）以及较强检索能力的中间型数据库（典型的如MongoDB提供了复杂的json互操作特性);总体上可谓是&lt;a href=&quot;https://en.wikipedia.org/wiki/NoSQL#Types_and_examples_of_NoSQL_databases&quot;&gt;百花齐放&lt;/a&gt;，各有千秋。&lt;/p&gt;

&lt;h3 id=&quot;亮点&quot;&gt;亮点&lt;/h3&gt;
&lt;p&gt;大部分NoSQL技术都提供了很高的性能和强大的集群管理能力，其处理能力想对于传统的关系数据库有很大的提升。
之所以如此，是因为它从技术上打破了传统SQL要求的复杂限制，专注于自身特定的数据定义模型和特点，有针对性地最大化使用计算机硬件。&lt;/p&gt;

&lt;p&gt;同时大部分NoSQL技术设计的时候就考虑到了可能出错的情况，不再假设底层的硬件本身具有很高的性能，而是通过自身软件的设计达到较高的可用性和可靠度。譬如Redis本身常常被作为缓存系统使用，而其自身的持久化机制在合理配置的情况下，可以保证数据在１秒内内一定会被写入磁盘，从而尽可能减少数据丢失。&lt;/p&gt;

&lt;h3 id=&quot;nosql的折中&quot;&gt;NoSQL的折中&lt;/h3&gt;
&lt;p&gt;基于纯粹的KV关系的数据库系统对数据的具体结构接近与一无所知；从应用程序的角度看，它似乎仅仅是提供了数据操作层面的虚拟关联表。
其好处是很容易达到很高的性能，但不足之处是，应用程序&lt;strong&gt;如何合理地管理键的模式&lt;/strong&gt;是一个比较打的挑战。&lt;/p&gt;

&lt;p&gt;提供复杂结构的NoSQL的好处是应用层程序的负担比较小，因为一些常见的结构化操作已经有了不错的支持，可以直接调用即可。
美中不足的是，这样的方案的性能往往也不是那么好，优化起来也会比较困难，因为数据的存储管理也相对比较复杂，如MongoDB采用树结构来保存数据，不深入其底层实现做针对性的优化就比较困难一些。&lt;/p&gt;

&lt;h3 id=&quot;挑战&quot;&gt;挑战&lt;/h3&gt;
&lt;p&gt;NoSQL自然也不是银弹，它也有它自己的问题需要应对；尤其是当它的用户企图将具有很强结构化特征的数据塞进去的时候：应用程序用来维护这些数据之间的关联关系就会变得异常复杂。&lt;/p&gt;

&lt;p&gt;另外一个比较麻烦的事情&lt;strong&gt;是NoSQL的不同提供者具有不同的特性&lt;/strong&gt;，应用程序想从一种切换到另外一种就远远没有传统的SQL来的方便;很可能你需要某个数据库的高级特性在另外一个数据库中就不存在了。
这也是&lt;strong&gt;缺乏类似于SQL语言这类DSL的不足&lt;/strong&gt;;比如Redis定义了类似通配符的模糊查询键值的方式，并提供了类似于一个Key关联多个属性的数据控制原语；换到MongoDB上我们就需要不同的方式来解决类似的问题。&lt;/p&gt;

&lt;p&gt;这些复杂的数据操作可能在应用程序层面来看又比较常见和繁琐，以至于使用&lt;strong&gt;纯粹的NoSQL会让人产生退回到SQL出现之前的混沌时代的错觉&lt;/strong&gt;！这当然也不是NoSQL的错，因为从来就没有银弹；合适的方案才是最好的；而怎样决定什么样的方案才是最好的？
当然是需要一句具体的业务场景来确定了。&lt;/p&gt;

&lt;h3 id=&quot;base理论&quot;&gt;BASE理论&lt;/h3&gt;
&lt;p&gt;NoSQL解决&lt;a href=&quot;https://www.cs.cornell.edu/Projects/mrc/IEEE-CAP.16.pdf&quot;&gt;数据一致性和高可用的CAP矛盾&lt;/a&gt;的方案是所谓的&lt;a href=&quot;http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/&quot;&gt;BASE方法&lt;/a&gt;，它常常被错误的想象为是ACID的对立面&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;基本可用而不是高可用(Base Availability) 强调数据库系统并不总是返回高度可用的数据，某些情况下可能出错或者不返回，或者返回不一致的数据；应用程序比系显式地处理这些情况&lt;/li&gt;
  &lt;li&gt;弱状态或不稳定状态（Soft state)表明数据的状态可能在不断发生变化，以至于传统关系数据库的这种事务回滚或者提交的状态则不复存在。这些都是为了应对最终一致性的目标。&lt;/li&gt;
  &lt;li&gt;最终一致性约束(Evenutal consistency)保证数据的更新经过一段时间的处理在没有后续输入的情况下可以达到一致状态；但是中间的不一致性状态仍然对应用程序是可见的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本上&lt;strong&gt;这些特性都是为最终一致性服务的&lt;/strong&gt;；数据库系统不再强制保证很强的一致性，而是由应用程序本身负责中间不一致状态的处理。
好处是性能可以得到极大提高，因为数据库系统不需要采用很复杂的策略来保证每一项数据的高度可靠和一致，没有复杂的同步、锁策略，开销自然少；
不利之处是应用程序需要仔细处理失败的情况，这在很多时候也是一个公平的折中，因为最了解数据特性的毕竟是上层程序本身。&lt;/p&gt;

&lt;h2 id=&quot;微服务架构下的数据演进和newsql&quot;&gt;微服务架构下的数据演进和NewSQL&lt;/h2&gt;
&lt;p&gt;随着云计算技术的深入发展和容器技术的广泛应用，微服务风格的架构技术变得愈发流行起来。
按照微服务设计的思路，传统的分层、单体、集中式的架构方式被&lt;strong&gt;分布式去中心化、按照业务领域分隔&lt;/strong&gt;以及轻量级的接口为特征的架构方式所取代。
同时鉴于以上这些NoSQL技术的种种不足并不能一招通吃，&lt;strong&gt;传统的SQL技术又被人们重新重视起来使用在合适的场景&lt;/strong&gt;中；
在一个一个具体的服务内部，SQL所定义的查询语言作为完美的数据操作接口仍然有极大的魅力，我们依然可以继续享用它而不需要因为复杂的数据操作而增加应用程序的逻辑复杂度。&lt;/p&gt;

&lt;p&gt;最显著的不同在于，服务是较为细粒度的、以业务逻辑功能为核心的一个一个小的独立的进程。&lt;strong&gt;数据也会根据此思路进行分割管理&lt;/strong&gt;，而不再统一的放在一个大的数据库中。
从整个系统的角度看，数据的交换和同步是通过服务之间的协议接口进行的，因而这些协议要求必须是轻量级的，以减少数据序列化、反序列化的开销。
因为&lt;strong&gt;微服务的高可用是通过同时运行多个副本外加负载均衡等分布式技术&lt;/strong&gt;来实现的，服务之间的耦合必须是很松散的；分布式一致性的问题采用的依然是最终一致性的思路。&lt;/p&gt;

&lt;p&gt;这种新的结合了传统SQL接口来管理本地数据，用部分NoSQL思路来处理系统一致性的方式又被成为NewSQL,甚至于NoSQL又被重新宣称为是Not Only SQL的缩略词。
显然在计算机科学领域，从来就没有一招打遍天下的技术，数据管理领域也不外如是。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no single development, in either technology or management technique, which by itself promises even one order of magnitude [tenfold] improvement within a decade in productivity, in reliability, in simplicity.&lt;/p&gt;

  &lt;p&gt;– Fred Books, 1986&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;业界因为商业、宣传等各种原因，会在某个技术刚刚崭露头角的时候宣称可以包治百病(否则也不会引人注意得到发展)；
经过比较长时间的洗礼&lt;strong&gt;最终会回到其本源应用到其最合适的场合&lt;/strong&gt;，而怎样鉴别什么样的场合使用什么样的技术，依然是软件开发者、架构师最大的挑战之一。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="architecture" /><category term="database" /><category term="microservice" /><summary type="html">数据访问和管理是软件设计需要解决的一项非常关键而又基础的问题;从早期的大型Unix应用开始，到基于C/S架构的商业应用， 乃至在互联网大潮中取得压倒性优势的基于B/S架构的企业应用，对于如何管理、访问、保存、检索、备份、维护数据这一基本问题， 无数先辈们创造了丰富多样的技术选项，然而随着行业潮流的变换，不同的技术依然在它各自适应的领域闪耀这光芒。</summary></entry><entry><title type="html">架构服务化的一点思考</title><link href="http://www.skyscribe.me/post/2017/08/29/thinking-on-service-architecture/" rel="alternate" type="text/html" title="架构服务化的一点思考" /><published>2017-08-29T00:00:00+08:00</published><updated>2017-08-29T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/08/29/thinking-on-service-architecture</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/08/29/thinking-on-service-architecture/">&lt;p&gt;微服务是个非常热门的话题，最近几年随着互联网的深入演进和云计算的逐渐普及，几乎所有的公司、技术社区、组织都是言必谈微服务；
似乎没有微服务都不好意思说自己能保持技术能力的与时俱进了。这厢微服务还没有完全在实践中铺开，那边潮头Amazon又挑起了无服务器架构的大旗，引来无数人的关注。
本文试图对这些概念和架构思想做一简单的分析和梳理。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;服务架构的前世今生&quot;&gt;服务架构的前世今生&lt;/h2&gt;
&lt;p&gt;考虑到微服务其实仍然是基于服务的架构方式，既然有“微”则必然有“宏”与之对应;只是之前大家都是直接叫基于服务的架构而已。&lt;/p&gt;

&lt;h3 id=&quot;没有服务的架构&quot;&gt;没有服务的架构&lt;/h3&gt;
&lt;p&gt;在软件工程的早期洪荒时代，所有的软件都是按照最原始的模块化思路组织和开发的;那时候编程语言基本是C/C++的，各个子部分之间采用头文件的方式来模拟相互之间的接口，源代码文件作为实现之间的隔离。
这种情况下，各个逻辑&lt;strong&gt;子部分的约束基本是比较弱的&lt;/strong&gt;，要么是依赖于组织内部的约定，要么是依赖于一些比较hack的方式。
这种方式可以认为是基于内部API和调用约定的无服务的架构方式。应用程序要么是独立组织的，要么是通过API定义好接口，然后各个模块分别开发，再统一连接起来形成最终的可执行程序。&lt;/p&gt;

&lt;p&gt;这么做的弊端非常明显，因为接口的定义极大地影响系统集成的效率，以至于各个模块独立开发的时候没什么问题，一旦到了集成阶段则困难重重，迟迟不能发布出来。
个人觉得这个问题的本质在于，&lt;strong&gt;完美的API定义是非常困难的&lt;/strong&gt;，需要极高的技术能力和对问题业务领域的深刻分析。&lt;/p&gt;

&lt;h3 id=&quot;unix编程哲学&quot;&gt;Unix编程哲学&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy&quot;&gt;Unix哲学&lt;/a&gt;倡导如下的核心实践如下&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Write programs that do one thing and do it well.&lt;/li&gt;
    &lt;li&gt;Write programs to work together.&lt;/li&gt;
    &lt;li&gt;Write programs to handle text streams, because that is a universal interface.&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;–Mcllory, inventor of Unix pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它推崇用多进程和管道的方式开发复杂应用，每个小程序负责一件事儿，进程之间采用管道链接输入和输出。
由于程序之间的输入和输出缺乏统一的规范化，&lt;strong&gt;Unix哲学推荐用基于文本的进程间接口&lt;/strong&gt;来组织程序，以便调试和分析、诊断等。&lt;/p&gt;

&lt;p&gt;美中不足的是，它对于&lt;strong&gt;具体怎么实践这些基于文本的接口&lt;/strong&gt;却没有统一的建议或规定，文本格式却是需要被程序去理解的，其中应该包含这负责的业务逻辑而不是简单的计算机字符串，简单按照这种设计哲学去开发应用程序依然是困难重重。&lt;/p&gt;

&lt;p&gt;另外一个难题是，Unix程序都假设是基于单个物理机器的运行环境，因为早期的Unix都是大型机，它无法预料到后期廉价PC的崛起。
各种围绕本地IPC机制设计的管道、系统信号等通信方式和TCP/IP的网络环境有很大的差异，导致代码并不能很好的复用。&lt;/p&gt;

&lt;p&gt;然而Unix设计哲学所推荐的这种&lt;strong&gt;系统职责分割方式和基于文本的协议交互对后来的微服务有巨大的影响&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;分布式对象技术&quot;&gt;分布式对象技术&lt;/h3&gt;
&lt;p&gt;90年代后期，微软提出了组件化开发的COM以及DCOM开发模型，使用接口来达到软件复用，最终程序通过接口定义和动态链接和查找实现分布式开发。
而Java社区则走向了分布式对象的模式，提出了JavaEE并和C++社区的CORBA对象代理技术兼容。
这种情况下，对象分布式技术的着眼点是基于OOA分析的划分。&lt;/p&gt;

&lt;h3 id=&quot;soa架构&quot;&gt;SOA架构&lt;/h3&gt;

&lt;p&gt;JavaEE提出也提出了基于服务的架构方式，它在很多场合也往往被成为&lt;strong&gt;Big Web Service&lt;/strong&gt;,其典型特征如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;复杂的系统被分割为一个一个相互通信的接口&lt;/li&gt;
  &lt;li&gt;使用WSDL来定义服务和服务之间的接口的通信&lt;/li&gt;
  &lt;li&gt;该&lt;strong&gt;通信方式是基于HTTP+XML+SOAP封装&lt;/strong&gt;，消息模型为&lt;strong&gt;基于请求/响应&lt;/strong&gt;的RPC模型，其中定义了消息通信的消息结构和通信端点抽象;
支持通过工具将WSDL转换为对应的代码，简化接口编码、解码的工作量&lt;/li&gt;
  &lt;li&gt;高级特性支持安全、服务注册和发现，以及多版本向后兼容等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SOA极大地提高了企业应用开发的效率，采用SOA架构的软件曾被认为是面向未来的，当时的业界对SOA的期望一如今天对微服务的期许。&lt;/p&gt;

&lt;p&gt;它的&lt;strong&gt;缺陷在于过于笨重&lt;/strong&gt;，部分原因在于XML本身的臃肿和复杂;实际场景中可能用于XML/SOAP解析和校验的开销变得过于巨大以至于性能很糟糕。
XML过于臃肿的特性导致大家追求通过压缩消息来节省网络带宽以优化性能，然而压缩和解压反而需要消耗额外的CPU资源。
另一部分则是因为JAX-WS规范的一些高级特性是可选的，而&lt;strong&gt;某些特性是由跳过了HTTP协议直接在SOAP中实现&lt;/strong&gt;的;然而HTTP协议本身也提供了丰富的特性，弃之不用自然会导致资源的浪费。&lt;/p&gt;

&lt;p&gt;此外基于RPC的通信方式并不是在所有方式下都适合，因为其隐含的模型是同步的请求、响应;实际的业务逻辑都直接定义在这些接口中，造成&lt;strong&gt;业务逻辑和接口直接产生了依赖&lt;/strong&gt;。如果频繁的因为需求变动导致WSDL接口定义变更，后向兼容又会变成一个沉重的负担。当然这个也是基于服务的方式必须要面对的问题。&lt;/p&gt;

&lt;h3 id=&quot;web技术的发展和restful架构风格&quot;&gt;WEB技术的发展和RESTful架构风格&lt;/h3&gt;
&lt;p&gt;WEB技术在最近20年也经历了深刻的发展，从基于B/S模型的厚后端模型为起点，到基于Ajax（XML）技术的风靡一时，再到REST风格的以资源为中心的厚客户端模型，越来越多的业务逻辑被搬到了前端处理，MVC模型最终占据了大部分应用场景。&lt;/p&gt;

&lt;p&gt;RESTful风格的架构强调使用HTTP协议本身的语义模型，用HTTP的方法来描述资源的CRUD操作，用URL来规范操作的资源，
接口定义上&lt;strong&gt;采用资源为中心的方式有效地减小了和业务流处理的耦合&lt;/strong&gt;，相比传统的RPC方式相比，前后段的交互方式与业务流程的耦合更小，更有利于前后段独立发展。&lt;/p&gt;

&lt;h3 id=&quot;领域驱动开发&quot;&gt;领域驱动开发&lt;/h3&gt;
&lt;p&gt;Eric Evans通过他划时代的《领域驱动设计》一书将面向对象技术推向了新的深度;通过提倡业务统一语言，领域对象的识别和绑定上下文的分析等技术，
实现了&lt;strong&gt;软件架构能更好地随着业务的的变更而低成本的演进&lt;/strong&gt;这一需求。
恰当的领域职责划分，以及领域专家和软件技术专家的通力合作和互相理解更容易生产出可维护、易扩展、更容易拥抱实际商业环境变化的系统。&lt;/p&gt;

&lt;h3 id=&quot;软件开发方法学和云计算基础设施革命&quot;&gt;软件开发方法学和云计算基础设施革命&lt;/h3&gt;
&lt;p&gt;敏捷软件开发和持续集成等实践在过去的近20年几乎席卷了软件开发领域的大部分角落。
&lt;strong&gt;持续发布以及DevOps运动&lt;/strong&gt;则进一步减小了软件开发的反馈周期，深刻地改变了大部分传统软件测试人员的工作方式和线上运维的成本结构。&lt;/p&gt;

&lt;p&gt;传统的先设计，再编码内部测试，最后再搞一个旷日持久的大集成及系统测试的开发模式再也不能适应追求快速响应的企业软件市场。
&lt;strong&gt;更快的设计、测试、发布上线速度&lt;/strong&gt;，成为影响企业成败的一个关键因素之一。&lt;/p&gt;

&lt;p&gt;云计算技术的日趋成熟将企业开发从传统厚重的基础设施维护工作中解放了出来。
以往那种设计实现一个企业应用系统需要考虑诸多服务器部署、存储、安全、运营维护等一系列复杂的底层细节被少数提供云服务的大公司统一按需提供和管理;
商业公司可以将研发精力聚焦在业务逻辑的部分更快地将产品推向市场，这也是&lt;strong&gt;社会分工更加深化&lt;/strong&gt;的结果。
容器技术（docker为代表）的飞速发展和原生云应用软件概念在不损失性能的情况下标准化了基础设施的管理和编排，极大地简化了中间件以及第三方组件的复用过程。&lt;/p&gt;

&lt;h2 id=&quot;站在巨人肩上的微服务&quot;&gt;站在巨人肩上的微服务&lt;/h2&gt;
&lt;p&gt;从某些方面看，微服务架构可谓是站在巨人的肩上诞生的新的弄潮儿;
它是在面向对象深入发展到领域驱动设计的基础上，随着WEB技术的深度发展和RESTful的日益流行而自然产生的。其特点和要求如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;采用&lt;strong&gt;业务领域特点来划分服务边界&lt;/strong&gt;，其基本思路是DDD的&lt;/li&gt;
  &lt;li&gt;服务的&lt;strong&gt;粒度要尽量的小&lt;/strong&gt;，符合Unix的编程哲学，每个服务只做一件事并将其做好;有的建议是一个服务最好能被一个小的开发团队（比如Scrum的5～7人模型）负责分析、设计、开发、测试、发布等所有工作。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每个服务是一个进程&lt;/strong&gt;，对外提供基于RESTful风格的HTTP服务（也有基于Protobuf的gRPC微服务框架）&lt;/li&gt;
  &lt;li&gt;服务接口提供多个版本，每个服务负责自己的向后兼容性，方便&lt;strong&gt;独立开发和部署&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;服务的&lt;strong&gt;设计本身需要预先考虑到可能的错误&lt;/strong&gt;情况，从设计的角度需要预料到错误发生是一种正常情况&lt;/li&gt;
  &lt;li&gt;服务本身需要&lt;strong&gt;无状态，便于扩展&lt;/strong&gt;;需要预料到服务示例可能有多个副本同时在运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些隐含的假设还有&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;添加新服务的代价很低&lt;/strong&gt;，往往数小时之多数天就可以添加一个新的服务并能和现有系统集成在一起&lt;/li&gt;
  &lt;li&gt;服务的拆分需要和业务模型、领域划分想匹配;软件技术专家和业务领域专家能够紧密合作，快速变更;这是领域驱动开发的预设条件之一&lt;/li&gt;
  &lt;li&gt;采用敏捷开发技术和&lt;strong&gt;团队最熟悉的编程语言、框架及技术栈&lt;/strong&gt;，但是也不宜过多;否则团队的合作又会变得难以掌控&lt;/li&gt;
  &lt;li&gt;组织开发结构和服务的拆分能互相匹配，减小组织沟通成本，最好是组建跨职能的团队;这也是由康威定律所决定的&lt;/li&gt;
  &lt;li&gt;采用服务发现和监控机制，以及负载均衡设施便于处理分布式应用场景，业务流的追踪和监控也会是新的挑战（想对于传统架构）&lt;/li&gt;
  &lt;li&gt;基于容器技术&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;微服务是银弹吗&quot;&gt;微服务是“银弹”吗&lt;/h2&gt;
&lt;p&gt;正如Fred Brooks在1986年所语言的那样，软件开发从来没有出现一个满盘通吃的银弹;
虽然Brooks只是比较保守地估计了其后十年的情况，然而最近30年的行业发展依然没有见证银弹的出现。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;there is no single development, in either technology or management technique, which by itself promises even one order of magnitude [tenfold] improvement within a decade in productivity, in reliability, in simplicity.&lt;/p&gt;

  &lt;p&gt;– Fred Brooks, 1986&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不少人满怀希望的认为微服务会打破常规，变成大家梦寐以求的神器，然而我们也见证了太多类似这种预言的屡次落空。
目前业内主流的观点依然是，微服务不是银弹;企业仍然需要谨慎地依据实际场景谨慎选择使用。&lt;/p&gt;

&lt;h3 id=&quot;先决条件&quot;&gt;先决条件&lt;/h3&gt;
&lt;p&gt;微服务的实施有很多先决条件，需要技术决策者仔细考虑。&lt;/p&gt;

&lt;p&gt;首当其冲的是企业的组织结构是否和微服务的拆分和设计想匹配。
如果团队之间的沟通结构存在很多的层级和结构，微服务的设计和演进的速度就会严重受到影响。
团队之间有明显的层级汇报或者审批关系会使情况变得更复杂，因为服务的自治性受到巨大的威胁。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.”&lt;/p&gt;

  &lt;p&gt;— M. Conway&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外一个不得不考虑的因素是&lt;strong&gt;企业的敏捷开发、持续集成以及发布的能力&lt;/strong&gt;。
如果企业的基础设施不够完善，不能尽快地对开发过程给予反馈，快速迭代难以为继，开发人员很快就会陷入困境，因为整个系统的测试和集成难度相比传统架构更高了。
没有足够的持续交付能力，微服务落地自然很容易变成无缘之水。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开发人员的技术能力，以及选用的技术框架、编程语言&lt;/strong&gt;是否适合成员的技术背景也会成为一个巨大的挑战。
最好的情况是，能够开发微服务的团队至少也能够应付中对规模的单体应用。
目前的开发生态更加倡导多语言的混合团队，使得每个团队可以选用自己擅长、喜欢的技术更快的开发自己的微服务，然而这样做也是好坏参半。
&lt;strong&gt;软件开发活动归根结底是人的活动&lt;/strong&gt;，人员的能力不能匹配技术的需求，或者有过多的技术栈以至于超出大部分成员的能力等情况，都需要慎重对待。&lt;/p&gt;

&lt;p&gt;正如Martin Fowler在他的&lt;a href=&quot;https://www.martinfowler.com/bliki/MicroservicePrerequisites.html&quot;&gt;《微服务架构的先决条件》&lt;/a&gt;一文中所指出的那样，能力因素是个至关重要的决定因素。
&lt;img src=&quot;https://www.martinfowler.com/bliki/images/microservicePrerequisites/sketch.png&quot; alt=&quot;microservice_competence&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何实施&quot;&gt;如何实施&lt;/h3&gt;
&lt;p&gt;鉴于以上讨论到的这些“坑”，微服务并不是任何时候、任何组织都可以开展;应用微服务同样需要讲究天时、地利、人和。组织的敏捷程度和自动化能力，沟通结构，人员的技术配备能力都缺一不可。&lt;/p&gt;

&lt;p&gt;Martin Fower建议的方式是我们总是&lt;strong&gt;可以从传统的单体架构&lt;/strong&gt;开始，采用演进式设计的思路逐步过度到微服务架构。
等到我们&lt;strong&gt;对系统对应的问题域有更深刻的理解&lt;/strong&gt;之后，可以自然地按照领域驱动设计的思路仔细地划分服务粒度和范围，将服务拆分出来。&lt;/p&gt;

&lt;p&gt;毕竟微服务是基于分布式环境的设计风格，而分布式的设计总是会有各种各样的复杂挑战需要仔细解决。
如果需要解决的业务领域有很高的实时性要求或者大规模、高并发的需求，拆分和设计的时候更需要小心分析，大胆假设加上仔细的设计和验证。正如Martin在企业应用架构模式中所说的&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;First Law of Distributed Object Design: “don’t distribute your objects”&lt;/p&gt;

  &lt;p&gt;– Martin Fower, &lt;a href=&quot;https://www.martinfowler.com/books/eaa.html&quot;&gt;Patterns of Enterprise Application Architecture&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="design" /><category term="architecture" /><category term="SOA" /><category term="microservice" /><category term="monolith" /><summary type="html">微服务是个非常热门的话题，最近几年随着互联网的深入演进和云计算的逐渐普及，几乎所有的公司、技术社区、组织都是言必谈微服务； 似乎没有微服务都不好意思说自己能保持技术能力的与时俱进了。这厢微服务还没有完全在实践中铺开，那边潮头Amazon又挑起了无服务器架构的大旗，引来无数人的关注。 本文试图对这些概念和架构思想做一简单的分析和梳理。</summary></entry><entry><title type="html">用Java Flight Recorder来调优JVM性能</title><link href="http://www.skyscribe.me/post/2017/08/22/performance-tuning-with-java-flight-recorder/" rel="alternate" type="text/html" title="用Java Flight Recorder来调优JVM性能" /><published>2017-08-22T00:00:00+08:00</published><updated>2017-08-22T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/08/22/performance-tuning-with-java-flight-recorder</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/08/22/performance-tuning-with-java-flight-recorder/">&lt;p&gt;随着Java程序在后端压倒性的普及，其性能本身早已经无人质疑；然而一个经常不为人道的事实是，Java平台上的程序不是天然就具有很高的性能；
因为Java语言显著降低了程序员的准入门槛，真正到系统性能这一块，仍然需要大量的调试和优化，即所谓的JVM性能调优。&lt;/p&gt;

&lt;p&gt;Java Flight Recorder（后文简称JFR）是Oracle官方推出的商业环境的性能调优利器；其本身对运行期系统的侵入性很小，同时又能提供相对准确和丰富的运行期信息；
合理使用改工具可以极大地提高工作效率。本文就个人工作环境中的一些实际使用情况做一简单的总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;基本工作模型和采样&quot;&gt;基本工作模型和采样&lt;/h2&gt;

&lt;p&gt;JFR本身是基于周期性对JVM虚拟机的运行状况进行采样记录的，其采样的频率可以通过其参数传入;只是需要留意的是，采样间隔越小对系统的性能干扰就越大。
和传统的JProfiler/VisualVM这些基于JMX的工具所不同的是，JFR记录的信息是&lt;strong&gt;近似而非精确&lt;/strong&gt;的；当然大部分情况下这些&lt;strong&gt;模糊性信息就足够说明问题&lt;/strong&gt;了。
对于大部分场景下，这些近似信息反而可以更容易发现一些真正的问题。&lt;/p&gt;

&lt;p&gt;要想使得JFR能够产生采样信息，首先需要确保你采用的JVM是Oracle的JVM，否则JFR也不认识虚拟机的内部工作机制；此外还需要在JVM的启动参数中开启商业特性的开关，
并开启JFR；相关选项很容易在官方文档里找到，这里就不赘述了。
额外需要注意的一点是，你必须有&lt;strong&gt;Oracle的商业使用许可&lt;/strong&gt;，否则是不能用的。&lt;/p&gt;

&lt;p&gt;开启JFR选项后，有两种方式可以产生采样文件以便时候分析&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在启动参数里指定启动后即开启采样；这种方式对于想分析启动时候性能的情况非常有用；只要在参数中指定采样间隔，时间以及保存的文件路径即可&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jcmd&lt;/code&gt;的JFR命令来按需产生采样；该方式更适合在程序启动之后按需产生采样。Oracle JDK自带的Java Mission Control程序可以挂在本机上运行的Java程序上做观测，
本质上也是这种机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;产生的采样文件可以在本地机器上使用Java Mission Control工具打开做事后分析。&lt;/p&gt;

&lt;h2 id=&quot;哪些信息被采样保存&quot;&gt;哪些信息被采样保存&lt;/h2&gt;
&lt;p&gt;基本上所有有用的信息都被保存下来了；最主要的概要信息保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;General/Overview&lt;/code&gt;里边。&lt;/p&gt;

&lt;h3 id=&quot;general面板&quot;&gt;General面板&lt;/h3&gt;

&lt;p&gt;以下是一个具体的CPU在某段时间出现繁忙的例子，这种采样在繁忙的后端服务器上可能是比较常见的，因为大部分情况下我们需要&lt;strong&gt;尽可能占尽可用的CPU时间来追求更高的吞吐率&lt;/strong&gt;。
当然如果CPU已经满负载运行，而吞吐量又不太理想的时候，详细深入的分析就变得更为重要。
&lt;img src=&quot;/assets/images/jfr/jfr_overview.jpg&quot; alt=&quot;an example program's overview with hot cpu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先映入眼帘的是一个常常的时间轴和系统时间图，开始时间和结束时间都可以按需选择；
如果选定了synchronize selection,则所有的&lt;strong&gt;信息显示都会随着选择范围的变化而实时刷新&lt;/strong&gt;。
这一机制非常灵活有用，因为很多时候我们都需要根据基本分析和直觉印象去选择某些特点的时间来对比观察。譬如在追求高吞吐率的场合，发现CPU没有用满但是吞吐率有上不去的时候，
可以选择CPU有锯齿的地方，详细去查看特定的时间点内发生了什么。&lt;/p&gt;

&lt;p&gt;接下来的三个大大的仪表盘会给出Java的堆内存、CPU使用、GC停顿时间的平均值和最大值；从而可以看到系统在给定时间内，JVM的内存/GC情况和CPU利用概况。&lt;/p&gt;

&lt;p&gt;最下方的部分则会显示一个更详尽的CPU使用图表曲线，在任何一个时间点（依采样频率而定）机器总的CPU利用率、JVM和用户程序在用户态、内核态的CPU使用情况。
对于追求高吞吐率的后端程序而言，这些信息值得仔细查看。&lt;/p&gt;

&lt;p&gt;最后一部分则显示了JVM的概要信息，包括其启动时间，JVM的具体版本等。除了这个概要页面，还有2个总体的标签页，分别显示具体的JVM命令行选项（包括默认没有设置但是传入给JVM的项），
JRE环境的属性和变量，采样记录信息如线程上下文切换计数的时间间隔等；这些信息在分析一些具体的性能参数的时候，是很重要的参考。&lt;/p&gt;

&lt;h3 id=&quot;内存面板&quot;&gt;内存面板&lt;/h3&gt;
&lt;p&gt;由于Java中的内存分配和回收是JVM帮助程序员做的，Java性能调优的很大一部分工作是和内存调优密切相关的。
内存面板则是根据运行期的采样数据将JVM的GC相关的数据汇聚显示出来；和其它的类似，同样是顶层的时间轴曲线可以依据选择来同步其他图表。&lt;/p&gt;

&lt;p&gt;中间的部分显示详尽的内存使用概览，包括总共可用的机器物理内存、已经使用的物理内存、提交给OS的堆空间、已经使用的对空间等。
锯齿状的曲线就是已经使用的堆空间随着GC的活动而动态变化的历史。如果图表中出现&lt;strong&gt;比较粗的“柱子”&lt;/strong&gt;图样，则表明GC的工作情况需要具体仔细查看了。&lt;/p&gt;

&lt;p&gt;最下栏则显示了当前GC的配置情况，如初始、最大的堆空间大小，不同的代的空间分配、GC活动的统计技术以及空间分配的概要情况。
大部分情况下，我们更多关注运行过程中间的&lt;strong&gt;GC统计指标&lt;/strong&gt;，包括总共的收集次数，最小、最大以及平均的停顿时间；
这些数值当然都是越小越好了；因为任何的GC活动都会挤占应用程序的可用资源。&lt;/p&gt;

&lt;h4 id=&quot;gc活动信息和收集细节&quot;&gt;GC活动信息和收集细节&lt;/h4&gt;
&lt;p&gt;一些额外有效而更细节的信息则会显示在单独的标签页中，包括这么几类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;垃圾收集详细信息：所有的GC活跃情况，以ID为标号详细地显示出对应的停顿时间，收集的类型，回收的原因，开始/结束时间，以及统计性的最长停顿时间等。
这些信息很多和&lt;strong&gt;具体的GC算法是密切相关&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;GC的停顿情况：同样针对的是每一个GC活动，针对具体的回收事件，对具体引用类型的收集停顿间隔以及相应停顿处理活动的开始时间信息等；
虽然不能看出具体的回收对象，但也足以看出大概的整体停顿比例和时间，对耗时的GC活动&lt;strong&gt;做定性的分析&lt;/strong&gt;还是足够有用的&lt;/li&gt;
  &lt;li&gt;对象引用情况：简要的显示了某次GC活动的时候，各种类型的对象引用的个数，可以辅助上一项，提供了更细节一点的数量统计&lt;/li&gt;
  &lt;li&gt;堆空间的变化情况：回收前后的堆空间情况，和&lt;code class=&quot;highlighter-rouge&quot;&gt;jstat&lt;/code&gt;提供的信息一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是上面同一个采样的GC信息，其中可以看出GC的活动对于CPU繁忙时段的贡献是不大的，基本可以排除GC对性能的影响
&lt;img src=&quot;/assets/images/jfr/jfr_memory_gc.jpg&quot; alt=&quot;GC activities&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;详尽的gc时间统计信息&quot;&gt;详尽的GC时间统计信息&lt;/h4&gt;
&lt;p&gt;GC时间统计页面则从时间的角度给出各个GC的代在收集过程中所占用的时间，最小、最长、平均停顿等。
这些统计同样是按照新生代、老生代、以及所有的收集活动耗费的时间来呈现的。同样这些信息&lt;strong&gt;和具体的GC算法是密切相关&lt;/strong&gt;的，需要根据GC算法的配置来综合使用。&lt;/p&gt;

&lt;p&gt;同样是上面的程序运行期的一个采样，其GC时间信息如下
&lt;img src=&quot;/assets/images/jfr/jfr_memory_gc_times.jpg&quot; alt=&quot;GC times information&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述采样表面，大部分GC活动事件属于新生代GC，即回收临时对象的常规动作；老生代GC仅仅有3次，并且占用的时间并不算长。
注意这里采用的是G1 GC算法，&lt;strong&gt;老生代的回收并不会完全阻塞应用程序线程的运行&lt;/strong&gt; - 具体的时间信息可以结合应用程序的log时间戳打印综合确认。&lt;/p&gt;

&lt;h4 id=&quot;gc算法相关的具体配置细节&quot;&gt;GC算法相关的具体配置细节&lt;/h4&gt;
&lt;p&gt;GC算法的参数配置则可以在其相邻的标签页找到，它给出了更为详尽的算法配置参数，包括&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;新生代、老生代对应的收集算法&lt;/li&gt;
  &lt;li&gt;并发收集的线程个数 （可能对某些算法不适用）&lt;/li&gt;
  &lt;li&gt;是否开启并发收集&lt;/li&gt;
  &lt;li&gt;是否允许应用程序显式地调用GC&lt;/li&gt;
  &lt;li&gt;GC被允许运行的时间占所有可用CPU时间的比率的上限值（G1等新型的GC算法支持这种约束，防止GC过分活 跃）&lt;/li&gt;
  &lt;li&gt;各个代的空间信息，包括初始空间大小、最小对空间大小、最大空间大小，以及对空间的地址大小、指针压缩情况和对象对齐情况（对&lt;strong&gt;64位的Java程序尤为重要&lt;/strong&gt;）。
新生代的配置还会提供诸如TLAB空间占用的情况和配置，以及默认隔多长时间会将仍然在引用的对象挪到老生代等信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同样是上面的采样，其GC配置信息如下
&lt;img src=&quot;/assets/images/jfr/jfr_memory_gc_cfg.jpg&quot; alt=&quot;GC parameters configuration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上这些复杂的信息对于深入的内存分析和针对是非常宝贵的;
譬如如果应用程序中生存期较长的对象并不多（面向对象设计提倡&lt;strong&gt;大部分的运行期对象是朝生夕死&lt;/strong&gt;），然而老生代却有比较大的压力，
就要怀疑是否是部分关键逻辑运行时间过长，导致经过数次新生代回收之后，仍然没有被释放出去，从而导致进入老生代被老生代的回收活动处理。&lt;/p&gt;

&lt;h3 id=&quot;代码面板&quot;&gt;代码面板&lt;/h3&gt;

&lt;p&gt;代码面板则是基于采样得到的信息的代码执行情况给出统计分析结果。
需要注意的是，所有的数据都是依据具体的采样点，具体的&lt;strong&gt;线程当时正在运行的的函数调用栈的具体状态来计数&lt;/strong&gt;并累加的。&lt;/p&gt;

&lt;p&gt;比如某个调用栈有10次被捕获到，那么相应的栈上的所有的函数的计数都会被记为10；这样得到的结果和&lt;strong&gt;实际代码的CPU占用率比较类似&lt;/strong&gt;，但是并不完全精确。
所有的百分比数值都是相对百分比，其计算方法是用当前函数的采样数和整体（线程或全局CPU采样数）的采样数相除。&lt;/p&gt;

&lt;h4 id=&quot;代码概览&quot;&gt;代码概览&lt;/h4&gt;
&lt;p&gt;概览页面会显示按照Java的包情况统计的采样数和相对总体的百分比；可以按照具体的列点击排序。最下边的视图则显式热点的类列表。
同样这些视图都可以根据选定的时间间隔来同步数据，使得我们可以方便的按照具体时间来分别查看CPU被占用在什么地方。&lt;/p&gt;

&lt;p&gt;对于上述的程序运行采样，以下是其代码概要视图
&lt;img src=&quot;/assets/images/jfr/jfr_code_overview.jpg&quot; alt=&quot;code overview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出在给定的CPU热点时间，有超过20%的采样都提取到了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util&lt;/code&gt;包的活跃样本，紧随其后的是一个Guava的工具函数包以及用户程序的一个基础工具库。
热点的类统计中，Java基本的Array类更是占据前列，这个在大规模的Java程序中是很常见的情况，同时也使得&lt;strong&gt;深入的分析变得困难&lt;/strong&gt;而又必要，
因为对Java基础库或API的调用是被层层封装过的。&lt;/p&gt;

&lt;h4 id=&quot;热点方法&quot;&gt;热点方法&lt;/h4&gt;

&lt;p&gt;热点方法标签则提供了基于调用栈的采样排序情况，可以点击具体的调用栈展开，具体查看可疑热点的调用情况从而做针对性的深入优化。
同样地对于上述的采样，其热点方法如下
&lt;img src=&quot;/assets/images/jfr/jfr_code_hot_methods.jpg&quot; alt=&quot;hot methods&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然繁忙的CPU活动依然发生在Java API的内部，排在第一的是Stream API的pipeline操作，逐级展开JDK的封装，最终还是能找到应用程序的调用点。
同时每一个调用栈的右侧会显示对应的采样数和百分比。
这里的Stream操作会在运行的时候被多个上层函数所调用，则每个调用栈极其采样个数都被显示出来，可以顺势点开查看详情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于80/20原则&lt;/strong&gt;，一般收效最大的是仅仅对占比最大的函数栈进行针对性优化；同时如果上一级函数的调用和字函数的采样个数不一致，说明函数内部的其它代码也需要仔细查看。
最麻烦的情况是80/20原则不太明显的时候；此时我们&lt;strong&gt;必须对多个可能的热点方法&lt;/strong&gt;做优化，耗费的精力和时间就会更多。&lt;/p&gt;

&lt;p&gt;回头看这个具体的例子，排行第一和第二的两个栈的采样数基本差不多，CPU时间耗费在哪里看起来似乎不是很明显;这是因为对应的采样是已经优化了一部分之后的中间结果。
令人惊讶的是，Guava的Interner API也占用了相当多的CPU时间；在CPU已经满的情况下，针对性的优化就要麻烦一些。&lt;/p&gt;

&lt;h4 id=&quot;热点的调用栈&quot;&gt;热点的调用栈&lt;/h4&gt;

&lt;p&gt;调用栈试图提供了和上述热点方法类似的信息，所不同的是其调用栈情况聚合了所有的API情况，譬如多个线程的同一个底层方法调用会被聚合在一起；
这样更容易从一个系统性的视角去理解程序实际运行时候的概况。&lt;/p&gt;

&lt;p&gt;回到这个具体的采样样本，其热点调用栈如下
&lt;img src=&quot;/assets/images/jfr/jfr_code_calltrace.jpg&quot; alt=&quot;call trace&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出大部分的CPU样本落在&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread::run&lt;/code&gt;方法中，这在多线程的后端程序中是最正常不过的情形了。具体展开来看，大部分的时间花费在了Netty的管线处理中；
由于Netty的管线处理是采用调用链的方式逐级深入的，调用栈展开起来比较繁琐一点；最终展开的时候，可以看出这里的大部分CPU花费在了消息解码上。&lt;/p&gt;

&lt;h3 id=&quot;线程面板&quot;&gt;线程面板&lt;/h3&gt;
&lt;p&gt;如今几乎所有的后端Java程序都是基于多线程的，运行期同时有数十乃至上百个线程在多核CPU上执行也是屡见不鲜的。
各色各样的第三方框架、库都会创建各种&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorServie&lt;/code&gt;实例，依据负载情况动态的创建或者调度线程。&lt;/p&gt;

&lt;p&gt;线程面板从JVM线程的角度来分析采样的数据。其概要面板同样提供了最基本的CPU情况，并且支持根据时间选择来刷新其它标签页视图数据、表信息等。
其线程信息则显示线程数量的历史信息，包括后台线程和活跃线程数等信息。&lt;/p&gt;

&lt;h4 id=&quot;热点线程&quot;&gt;热点线程&lt;/h4&gt;
&lt;p&gt;热点的线程显示在该标签页中，其中包含了丰富的信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jfr/jfr_threads_hot_threads.jpg&quot; alt=&quot;hot threads&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最上边的面板中显示地给出了线程上下文切换的频率；换算为多核的CPU就很容易看出来是否对应的采样时间内，CPU在忙于做上下文切换。
如果开启了很多个用户线程，这些线程又有比较粗粒度的锁，那么上下文切换的开销就很客观需要考虑优化。
比如这个例子中，在8个CPU核参与运算的情况下，CPU切换在2500多，平均Linux的10ms的时间片内，平均每个线程切换了3次多，属于比较正常的情况。&lt;/p&gt;

&lt;p&gt;具体的热点线程数据和其调用栈情况，可以依据采样计数排序后详细查看。这个例子中，String的&lt;code class=&quot;highlighter-rouge&quot;&gt;append&lt;/code&gt;操作消耗了大量的CPU，这个也算是大规模应用程序常见的情况。&lt;/p&gt;

&lt;h4 id=&quot;线程竞争&quot;&gt;线程竞争&lt;/h4&gt;
&lt;p&gt;同样是上边的运行其采样，线程的竞争情况视图为我们提供了更多关于CPU繁忙时候各个线程抢占CPU时间片的大概情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jfr/jfr_threads_contention.jpg&quot; alt=&quot;contention&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里依据具体的CPU事件，JFR为我们提供了三个子视图来呈现多线程运行期的细节信心&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;竞争锁情况，按照其阻塞CPU运行的时间排序，分别显示了各个锁在给定的时间周期内等待的次数，最长、平均、总共的时间。一般时间越长需要优化的空间会越大，因为很多CPU时间被浪费在频繁等待和获取锁上边。具体的运行其堆栈可以在下方的细节视图中具体查看&lt;/li&gt;
  &lt;li&gt;被阻塞的线程信息，列举了这些等待获取锁的线程的信息，时间、堆栈等&lt;/li&gt;
  &lt;li&gt;阻塞其他线程的线程信息，和上一个类似，只是显示的是占有共享锁而阻塞了别人的线程的相关信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;时延和锁竞争情况&quot;&gt;时延和锁竞争情况&lt;/h4&gt;
&lt;p&gt;线程的时延信息则从运行期所采样到的操作等待时间长短的维度呈现一些排序和统计信息，同样可以依据其数目、平均等待时间以及最长时间等因素来排序查看对应的运行其堆栈情况，如下图
&lt;img src=&quot;/assets/images/jfr/jfr_threads_latency.jpg&quot; alt=&quot;threads latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程锁信息则反馈一些基于Java锁对象为中心的时间信息，对于同一个锁对象指针（底层地址空间的指针）其关联的所有线程的追踪信息，并显示出多个关联线程被采样到的次数信息。&lt;/p&gt;

&lt;p&gt;由于这些统计信息是基于操作系统内存地址的，&lt;strong&gt;垃圾收集算法可能在运行清理操作的时候拷贝对象从而使得指针被重写，因此该信息不是非常可靠&lt;/strong&gt;,尤其是GC比较活跃的时候，某些应该被计数在内的线程活动会被计数到不同的实例上。幸运的是，JFR同样对给定的时间段内GC的活动情况给了个概要视图呈现在最下方。
&lt;img src=&quot;/assets/images/jfr/jfr_threads_lock.jpg&quot; alt=&quot;threads locks&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;线程dump情况&quot;&gt;线程Dump情况&lt;/h4&gt;
&lt;p&gt;JFR会依据采样配置情况，定期保留当前所有线程的调用栈信息;由于堆栈保存对实际运行程序的影响比较大，JFR的默认策略是很长时间才会取样一次调用栈信息。&lt;/p&gt;

&lt;p&gt;对于时间比较短的采样，这个页面的信息很可能是空的。如果确定有必要（比如怀疑某些线程僵死的情况，可以通过设置采样参数让JFR提取更多的信息。&lt;/p&gt;

&lt;h3 id=&quot;io情况&quot;&gt;IO情况&lt;/h3&gt;
&lt;p&gt;对于后端应用程序来说，系统性能的提升和IO活动密切相关因为大部分的程序运行瓶颈在IO上，
即&lt;strong&gt;快速的CPU处理速度和缓慢的IO活动之间的不可调和的矛盾&lt;/strong&gt;往往导致应用程序性能的下降;然而大部分的后端应用的&lt;strong&gt;目标是追求更高的吞吐率&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当吞吐量上不去，而CPU的运行曲线又不太平稳（譬如有很多锯齿）的情况下，往往是IO的处理浪费了宝贵的运行时间;
此时只要查看IO的情况，减少对程序逻辑的阻塞即可快速提升性能。
如果CPU已经用满，而吞吐率又不太理想，则优化起来就困难重重了;当然这种情况下IO的行为还是值得查看的，
因为不恰当的IO锁或者过多的IO操作仍然可能有潜力去挖掘，只是更加困难一些。&lt;/p&gt;

&lt;p&gt;IO事件按照其访问速度的差异一可以大概分为如下几类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;本地磁盘文件读写操作：其速度和物理磁盘的特性、文件系统以及程序所使用的API、框架等密切相关。典型地如频繁的log操作可能引起额外的小量的IO操作，如果这些操作是阻塞的，则程序的性能会下降比较厉害&lt;/li&gt;
  &lt;li&gt;网络文件系统操作:这类场景往往对应用程序的逻辑是做了隔离的，但是在复杂多变的网络环境下很容易引起性能的急剧恶化;遇到这种情况尽快分析出原因是很关键的。&lt;/li&gt;
  &lt;li&gt;网络通信读写（通过基于TCP/IP的各类协议的程序逻辑信息交换)：和网络文件操作类似，不同的是和应用层协议的设计和模式密切相关，对于大的系统而言，定位和分隔问题的边界是必不可少的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JFR对这些时间都分类列出其操作的时间信息，方便我们进一步定位和分析IO方面的问题。大部分情况下，IO里给出的信息都要结合线程乃至内存的情况综合判断。&lt;/p&gt;

&lt;h3 id=&quot;系统信息和事件&quot;&gt;系统信息和事件&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="tuning" /><category term="java" /><category term="debugging" /><category term="performance" /><summary type="html">随着Java程序在后端压倒性的普及，其性能本身早已经无人质疑；然而一个经常不为人道的事实是，Java平台上的程序不是天然就具有很高的性能； 因为Java语言显著降低了程序员的准入门槛，真正到系统性能这一块，仍然需要大量的调试和优化，即所谓的JVM性能调优。</summary></entry><entry><title type="html">TCP服务端socket会丢连接的诡异问题及思考</title><link href="http://www.skyscribe.me/post/2017/07/14/missing-connections-by-socket-accept/" rel="alternate" type="text/html" title="TCP服务端socket会丢连接的诡异问题及思考" /><published>2017-07-14T00:00:00+08:00</published><updated>2017-07-14T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/07/14/missing-connections-by-socket-accept</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/07/14/missing-connections-by-socket-accept/">&lt;p&gt;最近在跟踪项目的性能测试的过程中，发现了一个奇怪的问题：&lt;strong&gt;Netty服务器端新建的Channel的数目比Tcpdump抓包得到的经历过三次握手成功的连接数要少&lt;/strong&gt;：
总有几个连接从抓包来看成功，然后Netty并没有为其分配Channel。直观上来看，似乎是Netty的处理问题值得怀疑，似乎是用于接受新连接的线程池堵塞了。&lt;/p&gt;

&lt;p&gt;深入追踪下去，发现问题不在Netty身上，而是&lt;strong&gt;操作系统没有通过IO事件反馈给&lt;/strong&gt;应用程序(Netty)导致了丢连接的情况出现。经过更深层次的思考后，
问题之所以出现，还与我们的协议设计不太合理有关。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;问题发现和定位&quot;&gt;问题发现和定位&lt;/h2&gt;

&lt;p&gt;项目的服务器端和客户端之间采用的是基于&lt;strong&gt;TCP长连接&lt;/strong&gt;的应用层自定制协议；协议的基本工作流程如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;服务端监听在事先设置的服务端口上；用Netty的&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerBootstrap&lt;/code&gt;来封装服务器端的监听&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;处理;其内部封装了&lt;code class=&quot;highlighter-rouge&quot;&gt;listen&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;等底层API&lt;/li&gt;
  &lt;li&gt;针对每个连接上来的客户端，Netty会创建一个新的SocketChannel,其初始化方法中会初始化应用层的协议处理
（即一些列的&lt;code class=&quot;highlighter-rouge&quot;&gt;ChannelHandler&lt;/code&gt;对象）来负责对应连接上的IO事件以及应用层逻辑&lt;/li&gt;
  &lt;li&gt;连接建立成功后，客户端会处于Idle状态，&lt;strong&gt;等待服务器端发起第一条消息&lt;/strong&gt;，初始化应用层握手。&lt;/li&gt;
  &lt;li&gt;客户端收到握手消息后，确认相关信息，之后即进入正常的协议交互处理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;项目的初始设计目标是需要处理&lt;strong&gt;最多20000条并发连接&lt;/strong&gt;;这个性能指标应该说不算特别高，因为业界早就实现了从&lt;a href=&quot;https://qunfei.wordpress.com/2016/09/20/from-c10k-to-c100k-problem-push-over-1000000-messages-to-web-clients-on-1-machine-simultaneously/&quot;&gt;C10K到C100K&lt;/a&gt;的跨越。
当然任何&lt;strong&gt;性能指标如果不加以测试的话，都是假把式&lt;/strong&gt;。为了验证该目标，我们设计了&lt;strong&gt;针对性的性能测试模拟器&lt;/strong&gt;, 并设计了一个测试并发建链接的测试用例；
其目的是模拟多个逻辑上没有依赖的客户端同时发地发起大量的连接，验证服务器端是否能满足预设计的健壮性和可靠性要求。&lt;/p&gt;

&lt;p&gt;当上述第二步模拟器端以每秒近1000条连接的配置从本地环回端口(loopback)发起并发连接的时候，实际走到第三步的连接数有&lt;strong&gt;一定的概率&lt;/strong&gt;少于1000个，
而模拟器端显示所有的连接都成功建立。所有的网络通信都是从127.0.0.1这个本机IP地址在不同的应用程序之间周转的，可以直接排除网络不稳定的干扰。&lt;/p&gt;

&lt;h3 id=&quot;对模拟器和python的傲慢与偏见&quot;&gt;对模拟器和Python的傲慢与偏见&lt;/h3&gt;

&lt;p&gt;由于模拟器的主框架是用Python语言写成的，一开始大家都怀疑是否是&lt;a href=&quot;http://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/&quot;&gt;Python性能缺陷的原罪&lt;/a&gt;导致的；
毕竟Python的性能一直为人诟病；只是任何怀疑都必须找到切实的证据，必须做小心的分析和求证；具体到这个问题上，还是找一些中间的分析结果来的容易一些。&lt;/p&gt;

&lt;p&gt;两端都查了一堆的log之后最终也没有太多实质性的发现，最后大家还是决定看tcpdump的抓包，并过滤TCP协议的初始握手包更为简单直接，
只是过滤器的设置稍微复杂一点；google一下不难找到。&lt;/p&gt;

&lt;h3 id=&quot;网络协议分析是最强有力而值得信赖的&quot;&gt;网络协议分析是最强有力而值得信赖的&lt;/h3&gt;
&lt;p&gt;Tcpdump的抓包分析表明，每次这些连接全部都建立成功了,统计TCP握手的3个步骤的时候，
不管是初始的SYN(0)包，还是服务器返回的SYN(0)+ACK(1)包，以及第三次握手的ACK(1)包都完全发送成功。
这也就意味着，从TCP/IP传输层的角度来看，第二步其实已经全部完成。客户端是无辜的。&lt;/p&gt;

&lt;p&gt;问题就仅可能出现在服务器端了；接下来就是尝试修改Netty的源码加入更多的打印来观察其是否调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;ChannelInitializer&lt;/code&gt;对连接上来的客户端初始化ChannelHandler。
仔细看下来，居然是Initializer的数目就根本不对。
难道是Netty的实现有问题吗?作为一个在开源业界关注度如此之高的一个项目，我们采用的还是其非常成熟的4.0版，出现这种低级错误的可能性实在太小；虽然一切皆有可能。&lt;/p&gt;

&lt;h3 id=&quot;排除netty的嫌疑&quot;&gt;排除Netty的嫌疑&lt;/h3&gt;

&lt;p&gt;稍微阅读Netty的代码后，发现并没有特别的逻辑漏洞 - 它默认采用的是异步IO模型，用&lt;code class=&quot;highlighter-rouge&quot;&gt;select/poll&lt;/code&gt;模型来做连接的多路复合(Multiplexer);即使有传说中的&lt;a href=&quot;https://github.com/netty/netty/issues/2616&quot;&gt;CPU空跑的问题&lt;/a&gt;,看了代码之后发现对应的问题在新版本中早已fix掉了。&lt;/p&gt;

&lt;p&gt;保险起见，我们又尝试&lt;a href=&quot;http://netty.io/wiki/native-transports.html&quot;&gt;换默认的NioEventLoop为Linux本身的Epoll&lt;/a&gt;，问题依然没有得到解决。从行为上来说，
epoll机制也仅仅能解决效率高低的问题，&lt;strong&gt;并不应该解决行为不一致&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;p&gt;回想到我们采用的线程模型上，server socket上的事件循环还承担着应用层程序和协议栈交互的任务（我们通过UserEvent的方式向对应的pipeline上发事件来避免数据同步），
默认的单线程处理这些应用层事件的处理方式是否会导致效率低下也是一个值得验证的点；等到增大了线程数之后，问题依旧没有什么眉目。
和上面的处理机制类似，这样的方式也只是从效率的思路出发尝试解决问题，&lt;strong&gt;逻辑上依然是无法解决行为不一致&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;h3 id=&quot;从操作系统的角度分析&quot;&gt;从操作系统的角度分析&lt;/h3&gt;

&lt;p&gt;转了一圈，发现问题还是出在&lt;code class=&quot;highlighter-rouge&quot;&gt;listen&lt;/code&gt;调用和&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;的交接的地方；这里实际的TCP行为是发生在Linux的内核空间的；逻辑上其内部也是有个类似的异步队列，
对进来的TCP连接请求，内核会设置相关的socket状态，分配相关的数据结构，自动完成TCP协议的握手过程，待到握手完毕之后，将这个连接成功事件通知给应用层（select/epoll)；
然后应用层可以检查对应的socket读事件，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;获取新的socket文件描述符。&lt;/p&gt;

&lt;p&gt;这一系列过程都是异步的，并且跨用户空间处理和内核空间调度。
确定了可能出问题的地方，查找的方向就比较明确了；只需要找找可能影响server socket的行为就可以了。
此时一个可以的关于SO_BACKLOG的设置引起了我们的注意,因为这里设置的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;，尝试调大这个参数后，丢连接的情况突然消失了。&lt;/p&gt;

&lt;h3 id=&quot;检查socket选项---backlog设置&quot;&gt;检查socket选项 - &lt;code class=&quot;highlighter-rouge&quot;&gt;backlog&lt;/code&gt;设置&lt;/h3&gt;

&lt;p&gt;上述的参数是从Java的API中继承来的，实际设置的时候，其实也是传给了JDK的对应的参数；引用JDK的参数说明&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is refused.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里比较奇怪的是，当队列满了之后，从抓包的角度来看，&lt;strong&gt;对应的连接并没有被拒绝&lt;/strong&gt;，而是显示连接成功了！如果后续没有任何数据交换(&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;receive&lt;/code&gt;)的话，
对应的socket(以及操作系统分配的相关资源)其实也悄然泄露了?可是真会有这么低级的问题吗？&lt;/p&gt;

&lt;p&gt;既然有此疑惑，还是仔细翻阅一下Linux的&lt;code class=&quot;highlighter-rouge&quot;&gt;listen&lt;/code&gt;的manpage为好；搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;backlog&lt;/code&gt;选项,对应的说明如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.&lt;br /&gt;
If a connection request arrives when the queue is full, the client &lt;strong&gt;may receive an error&lt;/strong&gt; with
an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, &lt;strong&gt;the request may be ignored&lt;/strong&gt;
so that a later reattempt at connection succeeds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不确定这是否是一个bug，因为客户端测并没有检测到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;ECONNREFUSED&lt;/code&gt;的错误而是显示连接成功。
StackOverflow上有人提了&lt;a href=&quot;https://stackoverflow.com/questions/37609951/why-i-dont-get-an-error-when-i-connect-more-sockets-than-the-argument-backlog-g&quot;&gt;类似的问题&lt;/a&gt;，
合理的解释是，因为TCP支持重传，所以该请求&lt;strong&gt;仅仅是被忽略了&lt;/strong&gt;，直到下一次连接过来的时候，对应的连接会直接成功！&lt;/p&gt;

&lt;p&gt;要保证这样能工作，操作系统也必然需要在某些地方保存已经分配好的socket（以及相关的数据结构）以便下次可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;取到。&lt;/p&gt;

&lt;h3 id=&quot;如何解决和避免再次发生&quot;&gt;如何解决和避免再次发生&lt;/h3&gt;
&lt;p&gt;对设计用来处理比较高的并发处理请求的服务器程序来说，设置&lt;code class=&quot;highlighter-rouge&quot;&gt;backlog&lt;/code&gt;选项为比较小的值是个比较糟糕的主意，更容易”踩上这个坑”。也许这也是默认情况下，
Linux将这个值设置为128的原因；如果想修改它，最好&lt;strong&gt;设置的比128更大一些&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;由于这种情况在连接状态的backlog缓冲满了之后，再有新连接完成三次握手之后就可能出现，设置再大的值，理论上来说都不是足够保险;除非我们能提前预测或者限制客户端的行为，
避免大量的并发连接上来，或者让客户端能检测到这种情况。&lt;/p&gt;

&lt;p&gt;考虑到实际环境中，&lt;strong&gt;这种情况出现的概率还是很低的&lt;/strong&gt;，只有在基于内网的模拟器环境下，才会有这么“巧合”的情况出现;
在不能修改客户端行为的情况下，将该选项的值修改大一些即可有效地降低其出现的几率。&lt;/p&gt;

&lt;p&gt;要想彻底解决这个问题，单单从socket层面来看，应该是吃力不讨好的事情，因为行为的不一致发生在
操作系统的系统调用和用户程序的交互的地方；一个可行的思路是从更高层的应用层及时检测这种情况；这样的解决方案需要应用协议层面的特别处理才行。&lt;/p&gt;

&lt;h2 id=&quot;对协议设计的影响&quot;&gt;对协议设计的影响&lt;/h2&gt;
&lt;p&gt;由于问题发生的场景比较特殊一点，具体来说有以下必要条件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;多个客户端在短时间内发起大量的并发连接&lt;/li&gt;
  &lt;li&gt;服务器端接收新连接的&lt;strong&gt;内部队列长度设置比较小&lt;/strong&gt;，以至于某些完成握手的连接在客户端重试的时候直接返回成功&lt;/li&gt;
  &lt;li&gt;这些由于队列满而引入的默默完成的连接不被服务器应用程序所知道（没有新的IO读事件）&lt;/li&gt;
  &lt;li&gt;连接建立&lt;strong&gt;成功之后，客户端处于静默状态，等待服务器端发起第一条消息&lt;/strong&gt;，从而从应用逻辑角度看，双方进入了“死锁”状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实从根本上解决该问题的方式是避免第四个条件的出现；有两种方式可以凑效&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;永远保持让客户端发送第一条协议消息，或者&lt;/li&gt;
  &lt;li&gt;客户端在连接建立之后即发送业务层的心跳 - 这一机制在应用层有心跳支持的情况下变得更清晰&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一点额外的总结和感想&quot;&gt;一点额外的总结和感想&lt;/h2&gt;
&lt;p&gt;做技术的很容易对某些特定的技术产生“宗教式”的虔诚或“魔鬼式”的憎恶，技术偏见也会由此产生，并蒙蔽我们的视野，导致我们掉进一些坑里。
一开始的时候我们对Python的想当然的偏见耽误了不少的时间来检查是否模拟器的实现是否出了问题；幸好我们及时发现这种直觉上的错误；
顺利找到问题的根源。&lt;/p&gt;

&lt;p&gt;看起来很复杂的问题，根源往往在很小的一个基础的知识点上；
对操作系统底层处理机制的积累和对基本TCP/IP协议的实现的了解极大地节约了我们分析和解决问题而耗费的时间。
这些最基本的东西，其重要性怎么强调都不为过，应该作为程序员的基本功保持长期不懈怠。&lt;/p&gt;

&lt;p&gt;应用层网络协议的设计和实现上；&lt;strong&gt;遵循惯例和技术直觉&lt;/strong&gt;(Least Surprise)总是没有太大错误；当初我们设计协议的时候，选择让客户端等待服务器发送第一条消息，
虽然有一些感觉奇怪的地方，由于其它种种原因，当时没有仔细去考虑；最终在做性能测试的时候，就有问题爆出来狠狠地咬了我们一口。
幸好这类问题还没有被真正的客户所发现就被我们“扼杀”在实验室测试中！&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="linux" /><category term="programming" /><category term="netty" /><category term="java" /><category term="debugging" /><category term="design" /><summary type="html">最近在跟踪项目的性能测试的过程中，发现了一个奇怪的问题：Netty服务器端新建的Channel的数目比Tcpdump抓包得到的经历过三次握手成功的连接数要少： 总有几个连接从抓包来看成功，然后Netty并没有为其分配Channel。直观上来看，似乎是Netty的处理问题值得怀疑，似乎是用于接受新连接的线程池堵塞了。</summary></entry><entry><title type="html">Excessive null checks in Java Defensive Programming?</title><link href="http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming/" rel="alternate" type="text/html" title="Excessive null checks in Java Defensive Programming?" /><published>2017-06-27T00:00:00+08:00</published><updated>2017-06-27T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming/">&lt;p&gt;最近在参与某开发小组的&lt;a href=&quot;https://atendesigngroup.com/blog/group-code-reviews&quot;&gt;团体代码审查&lt;/a&gt;会的时候，发现组内的一线开发工程师对于何时应该做空指针检查并没有很清晰的认识；然而这在Java社区里早已经是个老生常谈的争论 。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;按照最偷懒的做法 (毕竟&lt;a href=&quot;http://threevirtues.com/&quot;&gt;懒惰是伟大程序员的美德&lt;/a&gt;之一)，可以对使用的对象不做检查，那么万一该指针为空，则运行期抛出的空指针异常&lt;strong&gt;默认行为就会将程序给crash掉&lt;/strong&gt;，你的用户会很不高兴，你公司的客户会不高兴乃至投诉你的研发老板，你的老板会更加不高兴甚至于愤怒以至于半夜将你叫起来加班解决问题；试想当你拖着睡眼惺忪的躯壳爬到办公室查看日志，迷迷糊糊一看，原来是有个地方的对象引用是null指针，没有做判断导致JVM退出了。那么最自然的方案是添加个判断了，原来的代码可能是&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在被改成了&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;后边可能出现了新的问题，那么你可能依法炮制，继续加上更多的分支判断。对于简单的代码片段而言这样做没什么问题，足够清晰易懂；只是实际的业务逻辑代码可能布满了各种各样的业务判断，再掺入这类判断代码，&lt;strong&gt;可维护性立刻直线下降&lt;/strong&gt;。这时候可能有个聪明的程序员跳出来说，我们不是有&lt;a href=&quot;https://en.wikipedia.org/wiki/Defensive_programming&quot;&gt;防御性编程&lt;/a&gt;大法吗，可以来的更彻底一些，&lt;strong&gt;干脆对所有的传入对象做空指针检查&lt;/strong&gt;不就可以了吗？&lt;/p&gt;

&lt;p&gt;乍看起来似乎很有道理，转而仔细想一下就会发现这里&lt;strong&gt;有很大的隐患&lt;/strong&gt;。上述的检查其实对每一次对象的调用其&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclomatic_complexity&quot;&gt;复杂度&lt;/a&gt;就会增加1，实际的业务代码里，一个类往往&lt;strong&gt;引用了很多对象&lt;/strong&gt;，每次都要去做判断很快使代码变得难以维护，尤其是考虑到一些稍微复杂一些的方法可能有多个出口的情况，条件判断的增多会直接导致内部状态变得难以分析。本质上对某个方法的实现上下文来说，当前&lt;strong&gt;所有的成员对象和传入的上下文参数对象&lt;/strong&gt;是否为null的状态都需要按照这个策略去来判断，在没有明确的前置条件约束的情况下，具体实现的业务逻辑会被埋藏在各种繁杂的空指针检查中难以理清。&lt;/p&gt;

&lt;p&gt;显然对所有的对象引用做空指针检查不是一个明智的主意。那么是否有什么方法可以减少这些检查或者有其它的提高可读性的变通之道吗？&lt;/p&gt;

&lt;h2 id=&quot;哪些情况需要判断空指针&quot;&gt;哪些情况需要判断空指针&lt;/h2&gt;

&lt;p&gt;为了探讨这个问题，我们可以详细列举一些可能需要判断的情况逐一分析一番就能做到心中有数了。因为Java语言中一切皆是对象(当然基本类型不算)，所有对象都由某个class给构造出来，所以我们&lt;strong&gt;仅仅需要讨论class中涉及到的对象&lt;/strong&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;成员对象-field&quot;&gt;成员对象 (field)&lt;/h3&gt;
&lt;p&gt;一个Java类的基本元素是其成员引用 (其实是对象指针) ，因为从成员对象开始探讨是个不错的主意。Java语言本身允许两种类型的成员对象：&lt;/p&gt;

&lt;h4 id=&quot;在构造中被初始化过的成员对象&quot;&gt;在构造中被初始化过的成员对象&lt;/h4&gt;
&lt;p&gt;构造中初始化的对象，其是否为null指针其实跟该类的设计密切相关，因为构造方法是对象”出生”的地方；其实现直接决定了构造出来的对象的内部状态。这种情况下，对象是否为null是个&lt;strong&gt;比较关键的设计决策&lt;/strong&gt;之一。&lt;/p&gt;

&lt;p&gt;对于这些纯粹是被使用到的对象(即其生存周期不由本class决定)，&lt;strong&gt;只接受合法的构造参数并确保总是生成带有非null引用&lt;/strong&gt;的成员对象，会大大减少类内部需要检查空指针的情况。这样类的职责也很容易做到单一而明确；对应的其它方法里边就无需判断某个成员对象是否为null，当然如果其他的方法中会修改某个成员为null，那么情况会变得复杂 - 当然这种情况下出现的时候，往往意味着某些方法之间在使用成员对象来存储中间状态，很可能这些方法之间的隐式依赖需要仔细分析重构。&lt;/p&gt;

&lt;p&gt;如果构造方法中的传入&lt;strong&gt;参数非法而导致某些成员对象没法被正常构造&lt;/strong&gt;出来，那么我们的确可以采用防御式编程的思路，在构造里抛出来异常即可。当然这里有些Java语言特殊的情况需要仔细考虑，譬如是否需要抛出&lt;strong&gt;待检查异常&lt;/strong&gt;还是非检查异常；并且在抛出异常的时候需要仔细小心留意没有资源泄露的情况，因为Java里没有C++中的RAII的概念，如果抛异常前已经分配的资源没有合适的释放(必须是手动的), 那么&lt;strong&gt;调用者永远也没有办法处理&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;尽管有以上诸多细微之处需要留意，在构造方法中考虑好对象的初始状态约束，是减少不必要的null指针检查的第一步(可能也是非常关键的一步)。&lt;/p&gt;

&lt;h4 id=&quot;没有在构造中初始化的成员对象&quot;&gt;没有在构造中初始化的成员对象&lt;/h4&gt;
&lt;p&gt;没有在构造中初始化的成员对象，可以有几种不同的情况。然而毕竟&lt;strong&gt;不能确保初始化对象的方法在什么时候被调用&lt;/strong&gt;了(除非有合适的设计约束)，因此成员方法中用到该对象的地方，都需要做空指针检查，否则就有可能出现意外的异常。当然详细的分析一下具体的场景也有助于我们做更深入的分析。&lt;/p&gt;

&lt;p&gt;一种常见的典型场景是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法来初始化的对象，从纯粹面向对象设计的角度来考虑，简单的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法其实是&lt;strong&gt;破坏封装&lt;/strong&gt;的，应该尽量避免。然而一种合理的情况是希望解决类之间的环形初始化依赖的情况，譬如依赖注入框架中的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter injection&lt;/code&gt;；当然环形依赖的情况之所以出现，往往意味着没有仔细的遵循&lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;基于接口编程&lt;/a&gt;的原则。即使需要用，也应该尽量避免滥用。&lt;/p&gt;

&lt;p&gt;还有一种常见的情形是在两个相互关联的方法之间传递中间状态；这种情形还可以再仔细甄别 - 如果是在两个共有方法之间共享状态，那么需要仔细考虑为何不在构造方法中设置好初始状态，也许&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern#Java&quot;&gt;空对象模式&lt;/a&gt;是个值得考虑的好主意。如果是在两个私有方法或者是一个公有方法和其内嵌的私有方法之间传递状态，那么往往意味着代码的实现出现了&lt;strong&gt;坏味道&lt;/strong&gt;，因为方法实现之间传递隐式状态很可能意味着本&lt;strong&gt;类的职责过多需要拆分&lt;/strong&gt;出来新的类，或者是用空指针来传递控制流程迁移，这类不必要的空指针检查完全可以避免；因为私有方法可以看作是实现细节的隐藏，在实现内部具体的状态迁移都应该是严格受控的，要么通过合理的参数来传递，要么考虑好具体场景而不宜随意传递可能为空的对象。&lt;/p&gt;

&lt;h3 id=&quot;静态成员对象-field&quot;&gt;静态成员对象 (Field)&lt;/h3&gt;

&lt;p&gt;静态对象是个和全局变量类似的问题，其初始化的时机其实已经超出了具体类对象的范围，会和其他的类产生&lt;strong&gt;明显的强耦合&lt;/strong&gt;。因而静态成员对象应该尽量去避免，如果真要使用，确保其生存期被正确的管理，譬如使用依赖注入框架等。&lt;/p&gt;

&lt;h3 id=&quot;方法传入参数对象&quot;&gt;方法传入参数对象&lt;/h3&gt;
&lt;p&gt;方法传入的参数对于方法的实现体而言是外部输入，因此也值得仔细判断。&lt;/p&gt;

&lt;h4 id=&quot;公有方法中的参数对象&quot;&gt;公有方法中的参数对象&lt;/h4&gt;
&lt;p&gt;显然共有方法中引入的参数对象是由调用者指定的，方法实现中需要考虑好什么样的参数是允许的，是否允许空指针传入；如果不期望空指针传入，那么可以在&lt;strong&gt;类设计中考虑进去并写入JavaDoc&lt;/strong&gt;，用具体上下文信息封装一个合适的异常传递给调用者，并保证方法调用前后，类的状态仍然是合理而符合预期的。如果允许方法中的某些参数对象为null，并依据是否为null执行不同的行为，那么建议应该尽量避免这样的设计, 空指针控制业务流程和常规的直觉不符,完全可以通过其他方式传入，或者增加新的公有方法或重载版本。仔细考虑之后，仍然决定允许为空指针，&lt;strong&gt;同样要在JavaDoc中写好&lt;/strong&gt;，方便你的用户。&lt;/p&gt;

&lt;h4 id=&quot;私有方法中的参数&quot;&gt;私有方法中的参数&lt;/h4&gt;
&lt;p&gt;私有方法往往是为想隐藏公有方法中的实现细节而准备的。显然由私有方法中引入的null类型参数是在实现某个公有方法的封装中引入的；由于公有方法的参数中没有带入这类空指针（见上述讨论），那么出现的空指针参数必然是由实现逻辑的过程中传入的；这&lt;strong&gt;往往意味着实现中出现了不自然的设计&lt;/strong&gt;，这种情形和上述的共有方法传入空指针还不一样，因为私有方法的用户始终是这个类的某个公有方法（或者是其基类)，那么更没有理由不去重构了。&lt;/p&gt;

&lt;h5 id=&quot;一个具体的例子&quot;&gt;一个具体的例子&lt;/h5&gt;
&lt;p&gt;譬如某个类有如下的实现方法&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//....&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeThing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//do something but not check param!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someConditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//construct another param returns a new valid param&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;doSomeLowLevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constuctAnotherParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//....&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeLowlevelWOrk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anotherParm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//!oops, have to check param &amp;amp; anotherParam&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//dosomething &lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anotherParam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something special&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// do something as normal&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的公有方法没有检查其传入的参数就直接将其传入了一个更底层的实现，并且显示的传入了另外一个null指针作为某个特殊的条件逻辑;这里的空指针用于决定底层实现逻辑的分支选择其实引入了不必要的跨逻辑层次依赖，属于比较明显的代码坏味道，可以将其重写如下&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something special&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someConditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Now I'm sure no null passed in!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do some thing without another param&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anotherParam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constructAnotherParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something else with another param, no null objects!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;重构后的版本将外部传入参数的判断放在公有方法的顶层处理，来确保相对底层的私有实现中不引入额外的空指针，取而代之的是具体的业务逻辑条件判断；代码的可读性显然有了良性的变化。&lt;/p&gt;

&lt;h5 id=&quot;例外情况&quot;&gt;例外情况&lt;/h5&gt;

&lt;p&gt;凡事总有例外，这里毫无疑问也存在一种特殊的情况，即是在实现&lt;a href=&quot;https://sourcemaking.com/design_patterns/template_method&quot;&gt;模板方法模式&lt;/a&gt;的时候，在基类中将空参数给传递进来了；这种情况下&lt;strong&gt;如果不能修改基类的代码，那么依然不得不做处理&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;譬如在一个抽象类中定义了模板方法操作&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractBehavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;//both firstParam and secondParam can be null, but not checked in below public API&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//certain other handling&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在一个具体的实现类中，因为抽象类未做检查，子类实现必须检查父类传入的参数&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteBehavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//have to check if firstParam is null or not!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//have to check if secondParam is null or not!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;话说回来，继承一个无法修改代码的基类可能往往不是一个很好的注意，这种情况下，&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;使用组合而不是继承&lt;/a&gt;可能是一种更好的方法，如果可以的话；因为从代码的耦合上来说，&lt;strong&gt;继承关系是一种很强的耦合&lt;/strong&gt;以至于所有父类中的不良设计会被所有的子类所继承，形成无形的约束。这也许是我们需要始终对以高复用为目标的框架保持谨慎的原因。&lt;/p&gt;

&lt;h3 id=&quot;外部对象&quot;&gt;外部对象&lt;/h3&gt;

&lt;p&gt;所谓的外部对象是这些在某个方法实现中被引用到，却并没有被类如方法传入参数，也没有被放在成员对象列表中的对象。当然如果出现这种情况，往往是全局对象的引用（要么是静态全局对象，要么是单例对象）。然而不管哪种情况下，你的class已经悄无声息地引入了&lt;strong&gt;隐式依赖&lt;/strong&gt;，而隐式依赖在大部分情况下引入的问题比解决的问题要多。&lt;/p&gt;

&lt;p&gt;对于这类对象，如果用现代的依赖注入方案来解决，很自然它们就和普通的成员对象没什么区别了。关键的问题是需要考虑好，是否真的必须引入这类隐式依赖就可以了，绝大部分情况下，&lt;strong&gt;显示依赖比隐式依赖要好&lt;/strong&gt;。当然去掉了隐式依赖后，一个额外的好处是你的测试将变得更加容易了，因为不需要特殊的mock或是Stub来设置上下文了；只需要构造被测试对象的时候安插好构造参数即可。&lt;/p&gt;

&lt;h2 id=&quot;变通之道&quot;&gt;变通之道&lt;/h2&gt;
&lt;p&gt;啰嗦这么多，看起来很多地方可能还是不可避免需要去做空指针检查。是否有办法做个变通，既保证逻辑正确，也能确保代码维护性不被破坏？其实回头仔细想一下，之所以有空指针异常这回事儿，根本上还不是因为&lt;strong&gt;Java用异常机制来非正常情况的&lt;/strong&gt;处理吗，从这个角度出发，其实我们还有这些选择&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用返回值而不用异常 - 然而我们是在讨论Java，虽然依然可以用返回值对象，或者类似C或者golang的error code的方式，但是如果你以这种方式写代码，其实&lt;strong&gt;可维护性的负担反而加重&lt;/strong&gt;了,顶多是少了一些花括号而已&lt;/li&gt;
  &lt;li&gt;使用&lt;strong&gt;新的编程范式&lt;/strong&gt;，没错我们还有&lt;a href=&quot;/categories/fp/index.html&quot;&gt;函数式编程&lt;/a&gt;可以选择，因为Java8已经给我们送来了这个大礼 - Optional&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;optional&quot;&gt;Optional&lt;/h3&gt;
&lt;p&gt;Java8新引入的&lt;a href=&quot;https://www.mkyong.com/java8/java-8-optional-in-depth/&quot;&gt;Optional&lt;/a&gt;类型提供了不同于传统基于返回值或者基于异常的新的错误处理机制。一个Optional类型是一个包装类型，其封装了原有的对象类型，但是在对象的状态上，允许表达该对象&lt;strong&gt;要么是存在要么是不存在&lt;/strong&gt;的概念。表面上看起来和传统的null没有太明显的区别，然而两者之间有很大的不同&lt;/p&gt;

&lt;p&gt;譬如同样一个可能为空的对象上的一个多步骤操作，传统的方式可以写为&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ResultType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomethingWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//exceptional handling code, other return&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExceptionalHandling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果换用Optional封装则可以写为&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSomethingWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doExceptionalHandling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;传统的空指针或者返回值方式返回的对象是不同的类型，程序员必须&lt;strong&gt;对返回值做类型相关的处理&lt;/strong&gt;，从这种意义上说，返回值方式(包括空指针)提供的相对低层次的封装，毕竟对于C++/Java这类强类型语言而言，不同的变量类型相关处理意味着底层语言基础设施和应用业务逻辑这两个不同层次的抽象被混杂在同一个层级的代码范围内&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt;类型提供的是统一的对象类型封装，你可以对该类型做相对更高层次的封装，根据你具体的业务逻辑写出声明式的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;隐藏在optional中的模式&quot;&gt;隐藏在Optional中的模式&lt;/h3&gt;
&lt;p&gt;从上面的示例代码可以看出，Optional类其实提供了关于一些基本过程逻辑的封装，使得使用者可以&lt;strong&gt;站在更高的层次写代码&lt;/strong&gt;，关于一些基本的分支判断等过程逻辑控制，Optional提供了一些模式给程序员来调用，使得程序员可以更加关注在业务逻辑上，减少程序语言的底层实现细节的纠缠，同时又&lt;strong&gt;不丢失静态语言带来的编译器检查&lt;/strong&gt;的便利。&lt;/p&gt;

&lt;p&gt;当然Optional类型本身是一个封装类，作为函数式编程中的一个模式在Haskell中它是&lt;a href=&quot;/post/2012/04/15/haskell-functor-and-monad/&quot;&gt;一种具体的&lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt;抽象&lt;/a&gt;，其提供的方法提供了各种各样关于封装对象的高层操作，包括过滤器/映射/异常处理等，可以实现更复杂而高级的操作，这里不再赘述；细节可参考Optional的使用。&lt;/p&gt;

&lt;h3 id=&quot;java8的-type-annotation&quot;&gt;Java8的 Type Annotation&lt;/h3&gt;
&lt;p&gt;其实在Java8中，新引入的类型注解针对空指针问题提供了另外的处理方式，即通过指定&lt;code class=&quot;highlighter-rouge&quot;&gt;@Nonnull&lt;/code&gt;，编译器可以用于检测某个代码路径中有可能接受到空指针的情况，从而避免程序员处理空指针异常。IntelliJ IDEA提供了贴心的提示建议插入这个annotation从而帮助我们写出更整洁的代码。&lt;/p&gt;

&lt;h2 id=&quot;参考引用&quot;&gt;参考引用&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://enterprisecraftsmanship.com/2016/04/27/defensive-programming-the-good-the-bad-and-the-ugly/&quot;&gt;Defensive programming, the good, the bad, the ugly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6086334/is-it-good-practice-to-make-the-constructor-throw-an-exception&quot;&gt;Is it a good practice to make constructor throw exception&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composition over inheritance&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/java-platform-group/java-8s-new-type-annotations&quot;&gt;Java8 new type annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="java" /><category term="design" /><category term="patterns" /><category term="fp" /><category term="language" /><summary type="html">最近在参与某开发小组的团体代码审查会的时候，发现组内的一线开发工程师对于何时应该做空指针检查并没有很清晰的认识；然而这在Java社区里早已经是个老生常谈的争论 。</summary></entry><entry><title type="html">Migrate blog to Jekyll</title><link href="http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll/" rel="alternate" type="text/html" title="Migrate blog to Jekyll" /><published>2017-06-24T00:00:00+08:00</published><updated>2017-06-24T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll/">&lt;p&gt;之前本blog的内容是基于强大的&lt;a href=&quot;http://octopress.org/&quot;&gt;octopress&lt;/a&gt;生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的&lt;a href=&quot;http://octopress.org/2015/01/15/octopress-3.0-is-coming/&quot;&gt;新版本预告&lt;/a&gt;后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。&lt;/p&gt;

&lt;p&gt;很明显，&lt;strong&gt;octopress项目要死了&lt;/strong&gt;，这在开源软件社区是常有的事儿；但是活人不能被尿憋死，本来用octopress的目的也是因为 Jekyll 太抽象了想顺带找个近路学习学习前端知识；这些没有了借口，还是升吧。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;上新版本jekyll安装主题&quot;&gt;上新版本Jekyll，安装主题&lt;/h2&gt;

&lt;p&gt;最开始用octopress的时候，Jekyll还是 0.6 版本；这么多年过去，Github 团队官方已经发布了 3.0 版本了，功能支持的已经比较完善了。本身Jekyll是基于 gem 的，模块化做的非常好了，不像原来的 octorpess 直接fork一个代码就在里边改来改去，还要创建多个branch 防止无法升级的问题。按照 &lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;官方文档&lt;/a&gt; 的步骤按部就班即可。&lt;/p&gt;

&lt;p&gt;Jekyll支持&lt;strong&gt;丰富的插件&lt;/strong&gt;，生成好对应的site之后，修改配置文件就可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle update&lt;/code&gt; 来安装。但是默认的Jekyll主题太过于原始，所以找个适合自己口味的主题是首要的。因为本blog是托管在github上的，gith-hub pages &lt;a href=&quot;https://pages.github.com/themes/&quot;&gt;支持的主题&lt;/a&gt; 却&lt;strong&gt;比较有限&lt;/strong&gt;, 而且要没没有提供预览，要么提供的预览不适合个人口味。&lt;/p&gt;

&lt;p&gt;回头看Ocotpress发现其实现方式完全是自己生成页面的，不用Github自己的build系统；这里可以很容易的依法炮制，自己将所有的东西编译好，将生成的site内容给传上去即可。个人还是比较喜欢原来的 Octorpress提供的默认主题，简洁明快；所以最终选择的是 &lt;a href=&quot;https://mademistakes.com/work/minimal-mistakes-jekyll-theme/&quot;&gt;Minimal Mistakes&lt;/a&gt; ；浏览选择过程中，对 &lt;a href=&quot;http://phlow.github.io/feeling-responsive/&quot;&gt;Feeling Responsive&lt;/a&gt;主题也非常入眼，只是看起来文档比较复杂，可以留待以后尝试折腾下。&lt;/p&gt;

&lt;p&gt;Minimal Mistake主题支持比较多的设定，因为打算自己生成页面，所以采用类似fork的思路，安装&lt;strong&gt;自己想要的插件&lt;/strong&gt;（可以突破&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;Github-Pages的限制&lt;/a&gt;)，最后build成页面给push上去即可。&lt;/p&gt;

&lt;h2 id=&quot;自动同步&quot;&gt;自动同步&lt;/h2&gt;

&lt;p&gt;由于是自己手工编译生成静态内容，所以很希望有类似于Octopress的Rakefile，遗憾的是&lt;strong&gt;copy下来的Rakefile&lt;/strong&gt;不能正确执行。Google上search了一圈发现没有现成的方案，而且Github-pages的个人站点仅仅&lt;strong&gt;支持push到master分支&lt;/strong&gt;, 而&lt;del&gt;早期的时候是push到gh-pages&lt;/del&gt;分支的；这个细微的更新貌似很多google页面都没有提及；不过好在也不是很难发现，仅仅需要在自己site的设置页面查看build的分支就可以看到只能接受master分支了。&lt;/p&gt;

&lt;p&gt;自动化的工作最终写了个简单的shell脚本来完成, 基本的步骤是沿用 Octopress2 的步骤，设置2个入口&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一个用于初始化一个deploy目录，和github的站点内容保持同步，初始化git和remote等等。&lt;/li&gt;
  &lt;li&gt;另外一个用于每次更新内容，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 完成编译后，将生成的内容全部copy到deploy目录下，然后再同步到github的repository&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;deployDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_deploy
&lt;span class=&quot;nv&quot;&gt;siteDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_site
&lt;span class=&quot;nv&quot;&gt;siteUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://github.com/skyscribe/skyscribe.github.io.git

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;setup&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    rm &lt;span class=&quot;nt&quot;&gt;-fr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    mkdir &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git init
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dummy content&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; index.html
    git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
    git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dummy script init&quot;&lt;/span&gt;
    git branch &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; master
    git remote add origin &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteUrl&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Setup complete for &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;deploy&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll build
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    cp &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&quot;&lt;/span&gt;
    git pull origin master
    git add &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;date &lt;span class=&quot;s2&quot;&gt;&quot;+%Y-%m-%d_%H:%M:%S&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;site updated at &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$now&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git push origin master &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deploy completed&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in
  &lt;/span&gt;setup&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	    setup
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        deploy
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数据搬运&quot;&gt;数据搬运&lt;/h2&gt;

&lt;p&gt;相对来说数据搬运不是很困难就是比较繁琐，原来很多Octopress支持的插件，在这里都得自己检验是否不工作或者是否有合适的插件可以替代。期间的过程就是不断的&lt;strong&gt;测试驱动&lt;/strong&gt;搬运，发现编译出错后，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;--trace&lt;/code&gt;开关，看问题出在什么地方然后一一修改之。最麻烦的一个问题是 gist 插件貌似产生了不兼容，原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;include_file&lt;/code&gt; 插件也没法再用，只好将文件内容copy过来，用Liquid的 &lt;code class=&quot;highlighter-rouge&quot;&gt;highlight&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 标签，套用如下的模板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% highlight html %}
    {% include code/include.html %}
{% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;插件和定制&quot;&gt;插件和定制&lt;/h2&gt;

&lt;p&gt;没有了github的插件束缚，就可以装自己想要的插件了&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;jekyll-compose 可以用&lt;strong&gt;命令行来生成新的post&lt;/strong&gt;，类似于之前的octopress的命令行&lt;/li&gt;
  &lt;li&gt;jekyll-archives 可以用来生成归档页面，方便使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认的blog页面用的是post layout，但是默认没有定义，简单起见，自己在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt; 下边加一个就行，从默认的single.html拷贝过来修改一下即可。&lt;/p&gt;

&lt;h3 id=&quot;tag-cloud&quot;&gt;Tag cloud&lt;/h3&gt;
&lt;p&gt;Octopress的tagcloud插件，找了一圈也没找到好的，仿照别人家的，写了个简单的 tagcloud.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% assign all_tags = site.tags | size %}
&amp;lt;h3&amp;gt;
  &amp;lt;a href=&quot;{{absolute_url}}/categories/index.html&quot;&amp;gt;Categories&amp;lt;/a&amp;gt;
&amp;lt;/h3&amp;gt;
&amp;lt;div class=&quot;tagCloud&quot;&amp;gt;
  &amp;lt;ul&amp;gt;
  {%for tag in site.categories %}
  {% assign category_name = tag | first %}
  {% assign cat_count = tag | last | size %}
  {% assign cat_avg = cat_count | div: all_tags %}
  &amp;lt;li&amp;gt;
  &amp;lt;span class=&quot;tag&quot;&amp;gt;
      &amp;lt;a href=&quot;{{absolute_url}}/categories/{{ category_name | downcase}}/index.html&quot;&amp;gt;{{ category_name }}({{ cat_count }})&amp;lt;/a&amp;gt;
  &amp;lt;/span&amp;gt;
  &amp;lt;/li&amp;gt;
  {% endfor %}
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;稍微定制下需要显示的地方，将上述html给include进去即可。&lt;/p&gt;

&lt;h3 id=&quot;布局调整&quot;&gt;布局调整&lt;/h3&gt;
&lt;p&gt;页面在高分辨率的屏幕下感觉空白太多，进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;_sass/minimal-mistakes&lt;/code&gt; 修改即可，代码相对比较清楚&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_variables.scss&lt;/code&gt; 包含一些全局变量的定义，譬如字体大小，缩进，padding等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_sidebar.scss&lt;/code&gt; 包含对边栏的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_masthead.scss&lt;/code&gt; 指定主头部元素的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_page.scss&lt;/code&gt; 包含页面主要内容部分的样式定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概对着浏览器窗口调整即可，无需赘述。&lt;/p&gt;

&lt;h2 id=&quot;未尽事宜&quot;&gt;未尽事宜&lt;/h2&gt;
&lt;p&gt;还有一些其它的问题暂时没找到解决方案，暂时不折腾了，先列在这里。&lt;/p&gt;

&lt;h4 id=&quot;无法删除的老页面&quot;&gt;无法删除的老页面&lt;/h4&gt;
&lt;p&gt;之前的blog采用的是octopress的URL设置，当在新的主题里，将permalink依法炮制的时候，发现更新的页面没有被github正确重新加载，依然显示的是老的页面。无奈之下，只好修改一下permalink的前缀部分，强制生成不一样的页面。问题是老的页面依然可以访问。&lt;/p&gt;

&lt;h4 id=&quot;页面布局&quot;&gt;页面布局&lt;/h4&gt;
&lt;p&gt;默认的布局中有很多&lt;em&gt;额外的padding&lt;/em&gt;没法去掉，尤其是PC的分辨率比较高的时候，页面右侧的边框显得特别大；用Chrome的Inspect工具打开可以看到右侧的padding有16%之多，然而修改附带的css并不能生效。&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://rafabene.com/2015/10/11/how-migrated-blog-jekyll-github/&quot;&gt;How I migrated my blog to Jekyll/Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hblok.net/blog/posts/2016/10/23/jekyll-include-partial-snippets-of-code/&quot;&gt;Include partial snippets of code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/phaer/1020852&quot;&gt;Raw tag plugin to prevent liquid from parsing given text&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="blog" /><summary type="html">之前本blog的内容是基于强大的octopress生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的新版本预告后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。</summary></entry><entry><title type="html">Kotlin语言之变量约束设计</title><link href="http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants/" rel="alternate" type="text/html" title="Kotlin语言之变量约束设计" /><published>2017-06-05T23:12:00+08:00</published><updated>2017-06-05T23:12:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants/">&lt;p&gt;可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为&lt;strong&gt;继承/封装/多态等手法针对的都是程序组织上&lt;/strong&gt;的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖&lt;strong&gt;过程式实现跟操作系统打交道&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;函数式编程里的副作用&quot;&gt;函数式编程里的副作用&lt;/h2&gt;
&lt;p&gt;在函数式编程的世界里，事情会变得很传统的过程式处理不一样，因为这里非常讲究函数本身是否是&lt;strong&gt;有副作用&lt;/strong&gt;的，如果&lt;strong&gt;同样的输入不能保证相同的输出&lt;/strong&gt;，那么则是有副作用的。这里的输出不仅仅表示返回值，还隐含其它形形色色的对环境的影响，包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;申请但是没有释放的内存&lt;/li&gt;
  &lt;li&gt;向操作系统请求占用共享资源如网络套接字&lt;/li&gt;
  &lt;li&gt;屏幕输出，磁盘占用等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要区分副作用&quot;&gt;为什么要区分副作用&lt;/h2&gt;

&lt;p&gt;显然，副作用引入了&lt;strong&gt;额外需要程序员维护&lt;/strong&gt;的状态，而传统的线程库或基本的OS机制将其完全交给了程序员负责。从而导致在多线程编程环境下，复杂的问题随着状态的增加成&lt;strong&gt;指数上升&lt;/strong&gt;。状态意味着有共享资源需要维护，当有并发执行的进程或是线程的时候，为了保证正确的程序语意，则不得不引入锁(昂贵的操作)和竞争，从而制约性能。无锁算法通过CAS+重试机制，可以&lt;strong&gt;部分缓解锁的开销&lt;/strong&gt;，却不能从本质上解决问题。&lt;/p&gt;

&lt;p&gt;无副作用的函数则是天然适合并发的，因为没有共享自然可以并行不悖地执行，问题不是完美解决了吗？然而&lt;strong&gt;现实世界总是不允许绝对完美二字存在&lt;/strong&gt;的，纯粹无副作用的函数几乎一无是处，因为它本质上没什么用，什么也做不了。&lt;/p&gt;

&lt;p&gt;退而求其次的想法是，能否尽量隔离两者的实现，然后又可以优雅地将二者集成起来完成实际功能？&lt;strong&gt;HASKELL用其优雅的monad抽象&lt;/strong&gt;回答了这个问题。然而对于抽象思维能力不是那么强（或者没有那么好数学基础）的程序员而言，&lt;strong&gt;Monad实在是太阳春白雪&lt;/strong&gt;了而难以接近；想更加接地气一点的程序语言无一不选择和Monad保持距离，即使某些构造和设计的思想就来源于Monad, 譬如随处可见的Optional，基本的map/reduce链式操作等。&lt;/p&gt;

&lt;p&gt;对于这些没有显示引入monad的非纯函数式语言来说，严格的隔离就显得有些太激进了。取而代之的相对折中一点的&lt;strong&gt;平庸&lt;/strong&gt;策略是语言机制本身提供某些基础机制，剩下的怎么用这些基本机制，一切由程序员自己来定夺。&lt;/p&gt;

&lt;h2 id=&quot;kotlin的语言层面基本机制&quot;&gt;kotlin的语言层面基本机制&lt;/h2&gt;

&lt;p&gt;kotlin通过关键字 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 来声明&lt;strong&gt;只读&lt;/strong&gt;的变量，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 来声明可变量。任何函数只要引入对可变量的使用，则其本身就是有明显的副作用的。然而一个变量声明为只读，仅仅表示在其对应的作用域中，不允许修改此变量的值，并&lt;strong&gt;不意味着实际指向的数据对象本身是不可变&lt;/strong&gt;的， 因为在可能有其他的地方使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 的方式来操作此变量，或者有显示的方式将一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 的变量转换回可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;考虑下边的例子：&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// field1 是只读的，在本class中不允许修改它
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// can only modify field2, but not field1
&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//calling site
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;someTypeInst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someTypeInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// someTypeInst can still be changed by others! Not recommended!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;someTypeInst&lt;/code&gt;是以只读方式传入&lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的，然而并不能保证没有其它的线程并发地修改实际的对象，如果发生这种情况，&lt;strong&gt;程序员仍然需要保证数据的一致性和安全&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;只读变量的初始化&quot;&gt;只读变量的初始化&lt;/h3&gt;

&lt;p&gt;显然不可变变量则仅仅能够初始化一次，后续使用中不能再修改了。这样也带来一些限制，譬如在 &lt;code class=&quot;highlighter-rouge&quot;&gt;init block&lt;/code&gt; 里想一次性初始化某些资源然后将其设置为在class内部是只读，则无能为力。一种变通的方式是将其设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 类，然而这样做我们就损失了只读约束；另外一种做法则需要使用property构造来封装。&lt;/p&gt;

&lt;h2 id=&quot;核心集合类&quot;&gt;核心集合类&lt;/h2&gt;
&lt;p&gt;kotlin对来自JAVA的集合类库进行了二次封装，清晰地划分了只读集合类和可变集合。&lt;/p&gt;

&lt;h3 id=&quot;接口定义&quot;&gt;接口定义&lt;/h3&gt;
&lt;p&gt;常用的集合类接口在&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin,collections&lt;/code&gt; 包中被重新定义 ( 源码中位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.kt&lt;/code&gt; )&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//...
// by default not mutable
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//... }
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// mutable iterable supports removing elements during iterating
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Only read access to collection
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Supports read/write operations
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的集合类接口则选择从以上接口中&lt;strong&gt;选择对应的&lt;/strong&gt;来扩展实现，因而对同一个类型有两种实现，分别是只读的 (没有前缀) 的和可变类型 (&lt;strong&gt;用 Mutable 做前缀区分&lt;/strong&gt;) 。譬如 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; 类就定义为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Read only list interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
// Mutable list
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，实际的具体实现类是复用Java中的定义，可参考collection包中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeAliases.kt&lt;/code&gt; 文件&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;默认的集合操作以及Streams API返回的大部分是不可变接口对象。&lt;/p&gt;

&lt;h3 id=&quot;集合类扩展工具函数&quot;&gt;集合类扩展/工具函数&lt;/h3&gt;
&lt;p&gt;除了使用默认的JDK实现来生成具体集合类对象，Kotlin标准库中同时提供了大量的封装函数方便程序员使用，某些来源于对JDK的直接封装，有一些则是直接inline实现。&lt;/p&gt;

&lt;p&gt;譬如返回空list的包装和初始化形形色色的list&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new read-only list of given elements.  */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * Returns an immutable list containing only the specified object [element].
 * The returned list is serializable.
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@JvmVersion&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成可变List的函数封装大多也是清晰明了 , 并且有很多种类的封装，使得就地生成 List 的工作大大简化；大部分情况仅仅需要&lt;strong&gt;使用已有的函数&lt;/strong&gt;即可，不需要发明新的轮子&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [MutableList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [ArrayList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new [MutableList] with the given elements. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayAsCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isVarargs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其它集合类  (set/map等) 的实现原理&lt;strong&gt;大概类似&lt;/strong&gt;，可以通过查看对应源码。&lt;/p&gt;

&lt;h3 id=&quot;不可变集合转换为可变集合&quot;&gt;不可变集合转换为可变集合&lt;/h3&gt;
&lt;p&gt;很多场景下，API返回的都是不可变集合，将其变成一个可变对象再行编辑修改是常见不过的变成任务；kotlin 通过其&lt;strong&gt;自身的扩展机制&lt;/strong&gt;将这些工具函数自动添加到了对应的集合类上&lt;/p&gt;

&lt;p&gt;如果想要将一个只读的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt; 对象变为一个可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableList&lt;/code&gt;，那么其实现是通过重新初始化一个新对象实现的：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Below code is copied from generated standlib as _Arrays.kt
//  see https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于具体的Array类，有不同的实现，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;ByteArray&lt;/code&gt; 的初始化方法则有所不同，直接调用其构造函数，然后注意添加现有的各个元素&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ByteArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;之所以如此，是因为具体这些子类是被映射到具体的 JVM 对象上的。如ByteArray的文档如是说&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;public final class ByteArray defined in kotlin
An array of bytes. 
When targeting the JVM, instances of this class are represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;byte[]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而对于CharArray，则其映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;char []&lt;/code&gt;类型上去。&lt;/p&gt;

&lt;h2 id=&quot;idea支持&quot;&gt;IDEA支持&lt;/h2&gt;
&lt;p&gt;作为官方的IDE环境，IDEA对可变量的引用做了显示的&lt;strong&gt;下划线&lt;/strong&gt;提醒，程序员可以一目了然地看到代码中对可变量的使用。&lt;/p&gt;

&lt;p&gt;然而想要更深入的查看整个实现调用链中，哪些引入副作用哪些没有，工具的支持就比较有限了。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="language" /><category term="fp" /><summary type="html">可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为继承/封装/多态等手法针对的都是程序组织上的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖过程式实现跟操作系统打交道。</summary></entry><entry><title type="html">Kotlin语言之函数式编程</title><link href="http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming/" rel="alternate" type="text/html" title="Kotlin语言之函数式编程" /><published>2017-06-04T22:32:00+08:00</published><updated>2017-06-04T22:32:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming/">&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin语言&lt;/a&gt;是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其&lt;a href=&quot;https://techcrunch.com/2017/05/17/google-makes-kotlin-a-first-class-language-for-writing-android-apps/&quot;&gt;2017年的I/O大会上将其列为Android平台官方支持的语言&lt;/a&gt;而窜上了热点。&lt;/p&gt;

&lt;p&gt;本文尝试从函数式编程的角度管窥Kotlin的特性。&lt;/p&gt;

&lt;h2 id=&quot;jvm上的函数式语言生态&quot;&gt;JVM上的函数式语言生态&lt;/h2&gt;
&lt;p&gt;作为一门比较年轻的编程语言，要想在既有的数百种语言中脱颖而出，成功吸引开发者的心，对新的&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;函数式编程范式&lt;/a&gt;的支持是必然不可少的 - 这一点基本成为语言出品商心照不宣的潜规则了，当然在21实际，不支持面向对象的范式也是说不过去的。&lt;/p&gt;

&lt;p&gt;作为基于JVM平台的语言，和Java的互操作性肯定是一个重要的优势，当然这方面已经有成熟的函数式语言&lt;a href=&quot;https://www.scala-lang.org/&quot;&gt;scala&lt;/a&gt;和更早一点的&lt;a href=&quot;https://clojure.org/about/rationale&quot;&gt;clojure&lt;/a&gt;在前。可能比较遗憾的是，正统的函数式编程风格太难被传统的OO程序员所接受，因此基于传统Lisp的clojure一直曲高和寡，scala在近年来有变得更加流行的趋势，只是目前看来&lt;a href=&quot;https://dzone.com/articles/the-rise-and-fall-of-scala&quot;&gt;仍然没有跨越期望的引爆点&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;有丰富的特性还希望有速度&quot;&gt;有丰富的特性还希望有速度&lt;/h3&gt;
&lt;p&gt;传统印象中的静态函数式语言的编译速度往往会比较慢，这一点在工程实践上是个很重要的因素。&lt;/p&gt;

&lt;p&gt;Kotlin作为后来者，其开发者认为静态语言的编译速度是个至关重要的，然后Scala的编译速度远不能令人满意。对大型的项目而言，笨拙的编译速度浪费的可是大量的时间和金钱；毕竟天下武功唯快不破，更快的编译时间意味着更快的反馈周期，更多次的迭代开发。Kotlin的目标之一是期望编译速度可以像Java一样快，&lt;a href=&quot;https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d&quot;&gt;benchmark分析&lt;/a&gt;也表明了二者的速度是差别不大的。&lt;/p&gt;

&lt;h2 id=&quot;基本特性&quot;&gt;基本特性&lt;/h2&gt;
&lt;p&gt;函数式语言的基本元素就是function，这一点kotlin倒是没有玩太多花头。用&lt;code class=&quot;highlighter-rouge&quot;&gt;fun&lt;/code&gt;关键字来声明函数，函数是第一等公民，可以支持函数作为参数，返回函数等基本特性。&lt;/p&gt;

&lt;h3 id=&quot;不可变类型支持&quot;&gt;不可变类型支持&lt;/h3&gt;
&lt;p&gt;Kotlin强制要求程序员声明某个特定的变量是否是可变类型。&lt;/p&gt;

&lt;p&gt;如果是可变类型，则需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;var &lt;/code&gt;来声明；那么后续程序中任何地方访问变量都会被IDE给highlight出来，提醒可能的副作用。因为可变类型意味着内部存储着状态，从函数式编程的角度来看，状态会&lt;strong&gt;影响函数的纯度&lt;/strong&gt;，带来副作用和复杂性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5275528-e33afde1447172d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;immutable_hints.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;函数声明&quot;&gt;函数声明&lt;/h3&gt;
&lt;p&gt;基本的函数声明是这样的&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsAFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当然这里的类型后置语法和传统的C家族语言有些不同，但是适应起来倒也不是难事儿。&lt;/p&gt;

&lt;h3 id=&quot;类型推导&quot;&gt;类型推导&lt;/h3&gt;
&lt;p&gt;Kotlin也支持强大的类型推导，从而在很多情况下，可以省略不必言的类型指定，简化代码；譬如函数的返回类型可以被自动推断的时候，其类型声明可以被省略。&lt;/p&gt;

&lt;h3 id=&quot;特殊的返回类型-unit&quot;&gt;特殊的返回类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;是一个特殊的类型，用于指定某个函数返回的值可以被省略，类似于Java8的&lt;code class=&quot;highlighter-rouge&quot;&gt;Void&lt;/code&gt;类型。如果一个函数没有返回值，那么可以指定其返回&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;或者直接省略其返回&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something with arg
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// no return needed
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// same as above
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;中缀表达式&quot;&gt;中缀表达式&lt;/h3&gt;
&lt;p&gt;中缀表达式写法更替进人的思维习惯，在定义某些操作符的时候是非常有用的。此用法往往用于扩展已有类型的操作，定义的时候需要满足以下条件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;属于某个类的成员函数，或者是定义某个类的扩展函数(后边再回头来看)，因为这里我们&lt;strong&gt;必须知道左侧的操作对象&lt;/strong&gt;是谁&lt;/li&gt;
  &lt;li&gt;必须只有一个函数参数（操作符后边的对象）&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;infix&lt;/code&gt;关键字来标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;譬如&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;infix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;/// implementation of shl operation
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// call site
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;命名参数和默认值&quot;&gt;命名参数和默认值&lt;/h3&gt;
&lt;p&gt;这点和Python很像在多个参数的复杂函数的使用上有很大帮助，能极大提高可读性减少维护成本。调用方可以在调用点指定需要传入的参数的名字；也可以省略掉不需要指定的参数。&lt;/p&gt;

&lt;p&gt;譬如有如下的&lt;code class=&quot;highlighter-rouge&quot;&gt;reformat&lt;/code&gt;函数用于格式化&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;normalizeCase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;upperCaseFirstLetter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;divideByCamelHumps&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用点可以简单写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// equals to
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个功能在传统的C++/Java里边没有提供，但是IDEA提供了只能提示可以弥补Java的不足；而Kotlin则将其内置在语言中了；本身没多少复杂性在里边。&lt;/p&gt;

&lt;h2 id=&quot;高阶函数和语法糖&quot;&gt;高阶函数和语法糖&lt;/h2&gt;

&lt;h3 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h3&gt;
&lt;p&gt;函数的参数可以是一个函数，这个在Kotlin的库里已经有大量的例子，譬如基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt;的filter函数携带一个谓词函数，其针对给定的参数返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt; Boolean&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FilteringSequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;单参数函数的表达式形式&quot;&gt;单参数函数的表达式形式&lt;/h3&gt;
&lt;p&gt;当函数只有一行实现的时候，可以省略其函数体，直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;来书写，就像复制给一个变量一样&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add2Numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lambda和匿名函数&quot;&gt;Lambda和匿名函数&lt;/h3&gt;
&lt;p&gt;匿名函数用大括号括起来，上面的例子也可以写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;add2Numbers2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;函数调用的形式省略&quot;&gt;函数调用的形式省略&lt;/h3&gt;
&lt;p&gt;当函数仅仅有一个参数的时候，其参数名字默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;保留关键字可以不用显示指定。&lt;/p&gt;

&lt;p&gt;当函数的最后一个参数是一个函数的时候，其函数体可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;块的方式来书写，获得更好的可读性。&lt;/p&gt;

&lt;p&gt;譬如如下的例子用于打印指定数目个偶数&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;printEvens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;一个具体一点的例子&quot;&gt;一个具体一点的例子&lt;/h3&gt;

&lt;p&gt;假设要实现如下功能的函数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;遍历某个目录树&lt;/li&gt;
  &lt;li&gt;找出所有符合条件的文件夹&lt;/li&gt;
  &lt;li&gt;取其文件绝对路径&lt;/li&gt;
  &lt;li&gt;归并为一个字符串列表返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以通过如下几个函数完成&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里每个函数的含义都是比较清楚易懂的。如果利用上述的省略规则，那么可以更简略的写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型扩展函数&quot;&gt;类型扩展函数&lt;/h2&gt;
&lt;p&gt;Kotlin 支持对已有的类型添加扩展，值需要在任何想要的地方添加想要的功能，则原有的类型即可像被增强了一样具有新的功能，该机制提供了OO之外新的灵活的扩展方式。&lt;/p&gt;

&lt;p&gt;譬如默认的Kotlin的&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;类没有提供并发的&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;操作，可以通过扩展机制很容易的写出来一个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;来并发循环的版本&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parallel for each, see also https://stackoverflow.com/questions/34697828/parallel-operations-on-kotlin-collections
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRuntime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableProcessors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// default size is just an inlined version of kotlin.collections.collectionSizeOrDefault
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;destination&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DAYS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里在函数体中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;自动会绑定于被扩展的对象。&lt;/p&gt;

&lt;p&gt;如果我们想实现一个自动将一大堆plantuml文件转换为png格式并copy到指定目录，因为默认的plantuml的API是单线程的，我们可以基于上述的parallelForEach实现来并发调度UML的生成过程，对应的代码可以写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;markDownFileLists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SourceFileReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generatedImages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstOrNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copyFileToDirWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pngFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCopyTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${System.currentTimeMillis()} - Created png for $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="language" /><category term="fp" /><summary type="html">Kotlin语言是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其2017年的I/O大会上将其列为Android平台官方支持的语言而窜上了热点。</summary></entry><entry><title type="html">Software Design in Agile Development Context</title><link href="http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context/" rel="alternate" type="text/html" title="Software Design in Agile Development Context" /><published>2016-12-24T19:32:00+08:00</published><updated>2016-12-24T19:32:00+08:00</updated><id>http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context</id><content type="html" xml:base="http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context/">&lt;p&gt;在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;软件设计的刚需被敏捷了吗&quot;&gt;软件设计的刚需被敏捷了吗？&lt;/h2&gt;

&lt;p&gt;工作流程的变更以及开发节奏的加快并不能绕开一个很核心的问题：&lt;strong&gt;写出容易维护方便扩展的代码的复杂程度本质上没有改变&lt;/strong&gt;；软件的维护周期越长，迭代的版本越多，这个基本问题就越突出。要想顺利解决这一问题，只能&lt;strong&gt;依赖于系统具有相对良好的设计&lt;/strong&gt;，使得添加新的功能不会轻易破坏原有的结构，出现问题的时候，不需要大范围地对系统做出变更。&lt;/p&gt;

&lt;p&gt;传统的瀑布式方法希望通过借鉴成熟的建筑行业的做法，采用预先大规模的架构设计，对系统做好明确的分割；继而进行不同层次的设计，直到所有可以预见到的需求都得以满足，然后才开始进行的代码的编写和构建。这种方法生产出来的软件交付工期很长，适应性很差，除了少数特殊行业之外基本已经被市场所淘汰。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://agilemanifesto.org/&quot;&gt;敏捷宣言&lt;/a&gt; 提出了一些基本的原则来指导我们怎样用相对更”&lt;strong&gt;敏捷&lt;/strong&gt;“的方式开发和交付我们的软件；通过多个不同的迭代，增量式的构建和持续交付系统来降低风险。然而软件本身的复杂性导致我们不能将客户的需求一对一的翻译成代码，像搭积木一样构建出来一个可以轻易维护的系统。因为新加入的需求很可能导致原有的代码结构无法适应新的需求；某些为了尽快完成需求而做出的&lt;strong&gt;关键的假设可能必须被打破&lt;/strong&gt;导致添加新的需求会破环大量已有的功能。如何做出恰如其分的软件设计，既能满足现有的短期需求，又能平衡潜在的变更。&lt;/p&gt;

&lt;p&gt;各种不同的敏捷实践方法论对如何管理用户的需求，如何增强不同角色的沟通，如何实施日常的开发和测试活动，如何验证需求保证已经交付的承诺不被变更所破坏，如何规划和平衡资源和进度等复杂问题都给出了丰富的可选实践供项目管理人员裁剪；对于如何做软件设计以及做多少软件设计并没有很详尽的描述。就连基本的是否需要软件设计，以及需要多少软件设计，怎样算作过度设计都语焉不详。&lt;/p&gt;

&lt;h2 id=&quot;真的需要软件设计吗&quot;&gt;真的需要软件设计吗？&lt;/h2&gt;

&lt;p&gt;大部分情况下，对于这个基本的问题我想答案应该是肯定的，除非你是在做一个很小的个人项目。如果需要牵扯到多个人一块合作并且最终的产品需要维护比较长时间，那么起码&lt;strong&gt;某种程度的软件设计&lt;/strong&gt;应该是不可或缺的。毕竟&lt;strong&gt;软件开发活动本身也是围绕着人展开&lt;/strong&gt;的，既然需要多个不同知识背景，不同技能，不同角色的人一起来协作交付功能复杂多变的软件，那么必然需要一些设计保证&lt;strong&gt;参与其中的人有一致的理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;敏捷运动的早期一个常见的误解就是，敏捷软件开发不需要软件设计，不需要软件架构，只需要采用极限编程，将人们聚集一个公共空间里，直接动手写代码就行了；复杂的设计文档都是浪费，都是可以避免掉的，代码就是最好的设计文档。这样的过程可能适合于几个能力超强的程序员聚在一起做的临时小项目，放到更广泛的商业环境则难以持续下去。人员的流动，特殊需求的变更，性能问题的修补会使一个一开始看起来极其简单的几个源代码文件组成的小项目演进成&lt;strong&gt;难以维护的“庞然大物”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果系统没有明确的分工和边界，没有相对清晰的职责分工和交互限制，软件的结构很容易陷入“大泥球”结构而不可维护，试想如果代码里的每一个包或者类都有可能和另外其它的任意一个类有交互关系，即使是一个绝对代码行数很小的项目也会变得无法继续添加新的功能。&lt;/p&gt;

&lt;h2 id=&quot;哪些东西应该包含在软件设计中&quot;&gt;哪些东西应该包含在软件设计中？&lt;/h2&gt;

&lt;p&gt;所谓的设计其实可以理解为关于如何组织软件各个部分（特性和行为分割）的一些决策，以及做出相应决策的一些原因。&lt;/p&gt;

&lt;p&gt;敏捷场景下，重构的重要性以及早已经深入人心，因而容易经&lt;strong&gt;由重构来去掉“坏味”的部分就不宜放在设计&lt;/strong&gt;中。因为一般为了重用的目的都会将设计决策写下来供后续使用；如此一来必然产生一些维护成本；而维护设计文档的开销一般比代码要大很多。因此容易通过重构而优化的部分，放在专门的软件设计中显得有些得不偿失了。毕竟敏捷软件开发的基本思路就是&lt;strong&gt;消除浪费&lt;/strong&gt;，使得&lt;strong&gt;投入产出比最大&lt;/strong&gt;化。&lt;/p&gt;

&lt;p&gt;某些跟具体实现技术相关而和核心业务需求关系比较远的决策，大部分也&lt;strong&gt;不适宜包含在软件设计&lt;/strong&gt;中。譬如期望某部分关键数据需要做持久化以保证系统异常重启的时候依然可以恢复。对于业务需求而言，这块数据需要持久化是重要的，但是如何做持久化，又可能是易变的，譬如今天是考虑用文件来做持久化就可以了，将来可能发现不够必须用关系数据库，或者甚至关系数据库可能也不是一个合适的选择，得要用键值对数据库。&lt;strong&gt;识别到可能变化的部分，并将不变的部分抽象出来，放入设计中&lt;/strong&gt;可能就足够了。这样技能照顾到当前的需求，又能满足将来扩展的需要。至于具体是怎样实现的，看代码就足够了。&lt;/p&gt;

&lt;p&gt;需求的&lt;strong&gt;概念抽象化，和软件的静态模型可以作为设计的中心&lt;/strong&gt;之一，必须详细考虑并归档维护。之所以要对需求进行抽象化处理，是因为用户的期望可能是模糊不清的，甚至是“朝令夕改”的。敏捷方法强调持续交付就是为了使用户早期得到反馈，&lt;strong&gt;及时修正他们的需求&lt;/strong&gt;，更好的管理客户的期望，避免开发出不符合客户真正预期的产品，浪费开发资源不说也浪费了客户的投资。软件的静态模型是关于大的软件职责的拆分和交互边界，这一部分不仅是当前进一步开发的基本依据，日后万一需要重构也是很重要的参考，值得花力气仔细讨论达成一致，减少日后维护成本。&lt;/p&gt;

&lt;p&gt;软件的部署和核心模块的交互在有这方面的变更的时候（新加入模块或者服务等）也需要仔细考虑并作为软件设计的关键活动。模块的边界是粗粒度的系统耦合的地方，一些关键的交互流程也适宜详细讨论并放在软件设计文档中。&lt;/p&gt;

&lt;p&gt;系统核心的模块/类以及之间的交互，如果有发生变更，也需要第一时间考虑清楚并放置在设计过程中产生合适的产出，便于沟通和交流。如果模块的粒度足够大（譬如估计有很多的代码），那么哪些部分是对外交互的接口也应该提早考虑清楚，并提取出来以便后续写代码以及代码评审的时候对照，确保设计被正确遵守。&lt;/p&gt;

&lt;h2 id=&quot;什么时候应该停止继续设计&quot;&gt;什么时候应该停止继续设计？&lt;/h2&gt;

&lt;p&gt;敏捷语义下，任何的浪费都是可耻的，代价巨大的设计工作自然也不例外。知道何时还需要仔细讨论搞清楚，何时应该停止变得尤其困难，甚至需要一些接近于艺术化的方法，&lt;strong&gt;需要经过大量的实践经验累积和反思&lt;/strong&gt;才能做到不偏不倚。&lt;/p&gt;

&lt;p&gt;如果发现所讨论的问题可能代码实现很容易就能完成，如果考虑不完备，那么修改代码的代价非常小，那么就可以立即停止了；因为设计的目的是为了更好的写代码，更好的维护既有的代码。因此只有重构代码的代价远远大于预先仔细设计付出的代价是，才应该花费力气去做这些烧脑的工作。发现代码实现已经很容易没什么问题的时候，就放手去写代码或者重构代码吧。这种情况往往发生在我们想去“设计”一些内部实现细节，而这些细节对模块的边界以及待修改模块和核心部分耦合很小的情况。&lt;/p&gt;

&lt;p&gt;如果是在构建一个新的模块，而这个模块和已有的系统有形形色色的复杂联系（耦合），那么如果这个模块和已有的系统的各个部分的交互已经比较清楚，而且其内部实现估计工作量也很小的时候，那么就可以放心将剩下的工作交给聪明的程序员去继续了。将一些&lt;strong&gt;细微的工作也放入设计中，只会使设计文档变得庞大而又难以维护&lt;/strong&gt;。毕竟可工作的代码比完美的文档更重要，虽然后者也很有价值。&lt;/p&gt;

&lt;p&gt;如果对于是否应该继续设计有分歧，可以和其它准备实现的程序员坐在一起讨论（其实任何时候都应该如此，如果团队规模比较小而且时间允许），看将要写代码的程序员是否觉得足够清楚，返工的风险是否足够得小。如果对于一些核心的模块或者类的职责还有不同的认识，或者程序员不知道某些改动是应该新创建一个子包，还是应该在已有的摸个包中修改来实现，那么&lt;strong&gt;很可能有些关键的部分没有设计&lt;/strong&gt;清楚。&lt;/p&gt;

&lt;p&gt;决定何时应该适可而止也和你的程序员团队的&lt;strong&gt;实际水平和能力&lt;/strong&gt;密切相关。一群天才程序员可能需要极少的设计来达成基本的共识就可以产出高质量易维护的代码，而水平平庸的程序员团队则需要更多设计上的预先讨论沟通以达成基本共识，减少返工。&lt;/p&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;p&gt;软件工程的一个关键要素就是工具。软件设计自然也离不开合适的工具，尤其是软件设计又是对需求进行抽象的结晶；选择合适的工具可以增进协作和沟通，使得设计输出是有实际指导作用的而不仅仅是纯粹的文档工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;轻量级的文档工具&lt;/strong&gt;往往使维护和修改变得更加容易，因为设计输出本身也是一个迭代的过程；便于多人评审和协作显得尤其重要。目前主流的方式基本都是基于Markdown和Plantuml的；前者可以用来存放文本，后者则可以用文本的格式来描述UML图。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="agile" /><category term="methodologies" /><summary type="html">在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。</summary></entry></feed>