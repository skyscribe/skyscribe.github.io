<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://skyscribe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://skyscribe.github.io/" rel="alternate" type="text/html" /><updated>2019-10-03T11:14:36+08:00</updated><id>https://skyscribe.github.io/feed.xml</id><title type="html">驭风万里无垠</title><subtitle>汇小流以成江海，积跬步以至千里</subtitle><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><entry><title type="html">微服务开发：C++语言是否真的不适用？</title><link href="https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp/" rel="alternate" type="text/html" title="微服务开发：C++语言是否真的不适用？" /><published>2019-10-01T00:00:00+08:00</published><updated>2019-10-01T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp/">&lt;p&gt;微服务架构模式是当今炙手可热的企业软件架构范式，经过最近几年的广泛的讨论和优缺点争辩之后已经随着
&lt;a href=&quot;/ /post/2018/04/26/cloud-native/&quot;&gt;云原生架构&lt;/a&gt;　的逐渐火热而日益呈现星火燎原之势。
抛开这些争论不谈，假设我们需要实现一个微服务架构的服务，是否&lt;strong&gt;该用&lt;/strong&gt;C++语言或者&lt;strong&gt;是否能用&lt;/strong&gt;C++语言呢？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;乍一看似乎这个问题没有什么深入探讨的必要，因为&lt;strong&gt;微服务开发本身是编程语言中立&lt;/strong&gt;的，它本身倡导的思想就是用尽量和具体语言无关的技术来解耦业务复杂性，通过智能的API来串联各个可以分布式开发的服务单元。
然而一个不容忽视的现实是，很多谈论微服务开发的书籍或者博客文章&lt;strong&gt;要么不谈落地仅仅谈理论&lt;/strong&gt;（也许这样的贩卖理论的书籍大多多乏味至极没有多少营养）；
要么谈到的时候也是无外乎用流行的几个大的技术栈&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Java 生态圈的基于JVM的技术，使用Spring Boot/Spring Cloud等一些&lt;strong&gt;现成的服务&lt;/strong&gt;，或者稍微时髦一些的会用到Scala或者Kotlin来实现新潮的&lt;strong&gt;函数式编程乃至流计算技巧&lt;/strong&gt;或者&lt;strong&gt;事件驱动&lt;/strong&gt;机制&lt;/li&gt;
  &lt;li&gt;新生代的Golang技术，这个在&lt;strong&gt;特别强调Cloud的部署环境中&lt;/strong&gt;讨论的格外多一些，因为Golang语言在很多云计算的基础设施项目中有极大的应用&lt;/li&gt;
  &lt;li&gt;还有一些则用流行的NodeJs技术栈来举例，这方面多多少少&lt;strong&gt;得益于NPM这一强大的第三方包管理工具&lt;/strong&gt;所支持起来的庞大的开源软件分发管理系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看起来并没有多少人谈论用C++语言来实现微服务；然后是否是因为C++就不适合来实施微服务？
回答这个问题其实并不难，只要从简单的微服务架构的实现要求来看一下就清楚明了了。&lt;/p&gt;

&lt;h2 id=&quot;微服务实现的技术要求&quot;&gt;微服务实现的技术要求&lt;/h2&gt;

&lt;p&gt;微服务架构的软件系统的最基本思想其实就是&lt;strong&gt;分治和解耦&lt;/strong&gt;；其它的技术需求都可以认为是因此而衍生出来用于解决它所带来的具体问题的。&lt;/p&gt;

&lt;p&gt;因为系统被拆分为多个松耦合的粒度较小的服务，并且服务之间需要能够松耦合，因此每个拆分的服务需要提供和其它服务的通信来协作完成端到端的业务场景。
这样的业务交互是通过某些广泛可用的上层&lt;strong&gt;应用程序编程接口&lt;/strong&gt;来完成的；目前来说这样的接口定义有两种&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;基于HTTP协议的REST风格API，本身是基于存在了二十年以上的HTTP协议来实现的&lt;/li&gt;
  &lt;li&gt;基于Google Protobuf编码的GRPC远程过程调用协议,该协议相对较新，由Google提出&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rest-api&quot;&gt;REST API&lt;/h3&gt;
&lt;p&gt;基于REST风格的API其实要求服务提供方需要按照资源化的风格封装它对外曝露的接口，每一个接口都需要作用域某个资源之上，并且针对该资源提供创建、读取、修改、删除等操作。
这些操作方法通过&lt;strong&gt;遵循既有的HTTP协议的方法动词&lt;/strong&gt;来表达，而实际资源的&lt;strong&gt;内容则通过HTTP消息体&lt;/strong&gt;来传递和交换。&lt;/p&gt;

&lt;p&gt;实际的资源内容的定义和校验则&lt;strong&gt;依托现有的JSON或者XML容器来封装&lt;/strong&gt;；API的请求和相应中可以依据需要来提供或者返回具体资源负载；这些资源的定义本身用OpenAPI来定义，客户端和服务端都可以根据这一独立于代码实现的API定义规范来解析和处理。&lt;/p&gt;

&lt;p&gt;当然在比较高级的基于HATEOS的用法中，实际消息中封装的资源可能会按照媒体内容互相关联的方式来组织，
使得客户端可以无需在代码中写死资源的URI，而是通过一次请求关联资源并根据返回的链接来动态发现的方式来降低服务之间的耦合。&lt;/p&gt;

&lt;p&gt;HTTP协议的实现自然是和语言无关的技术，而JSON的封装对具有几十年历史积淀的C++语言来说也完全不是问题。
至于OpenAPI规范的定义更加是和语言无关的技术。&lt;/p&gt;

&lt;h3 id=&quot;grpc&quot;&gt;GRPC&lt;/h3&gt;
&lt;p&gt;GRPC是相对比较新一点的服务之间的API调用接口实现方式；详细的探讨可以参考&lt;a href=&quot;/ /post/2018/04/26/cloud-native/&quot;&gt;这篇文字&lt;/a&gt;。
从上层架构上来看，GRPC的设计思路可能更加&lt;strong&gt;契合传统的程序员的思路&lt;/strong&gt;，它的直接思路其实就是要求各个服务之间通过远程过程调用的方式来实现相互交互。&lt;/p&gt;

&lt;p&gt;GRPC和传统的基于方法调用的RCP所不同的地方在于它&lt;strong&gt;在传统的请求／响应模型之上还提供了客户端和服务端之间的全双工的数据流推送&lt;/strong&gt;，因而它需要和HTTP/2在一起才能配合完好。
在这种接口范式下，服务提供者需要按照Proto Buffer的语法规范定义自己的服务声明定义文件，然后该文件会被protoc编译器检查解析并生成样板代码。&lt;/p&gt;

&lt;p&gt;基于GRPC技术实现的服务&lt;strong&gt;需要根据上述的服务样板代码来二次开发，扩展实现自己的业务逻辑&lt;/strong&gt;；客户端则可以响应的使用生成的客户端样板代码来发起远程调用请求。&lt;/p&gt;

&lt;h3 id=&quot;这些技术本身有强烈的语言偏爱吗&quot;&gt;这些技术本身有强烈的语言偏爱吗？&lt;/h3&gt;

&lt;p&gt;基于这些讨论，单纯看微服务落地实现的技术栈要求，它并&lt;strong&gt;没有特意对编程语言提出很硬的约束&lt;/strong&gt;，即理论上任何能够完成中等复杂度任务的编程语言都可以来实现微服务。
无论是REST/JSON还是GRPC/ProtoBuffer，它们本身都具有多语言支持的能力，尤其是GRPC自带的代码生成工具有个很微妙的限制就是&lt;strong&gt;不同的编程语言的支持能力是不同的，但是C++语言是功能最完善的&lt;/strong&gt;之一。&lt;/p&gt;

&lt;p&gt;显然我们可以在需要的情况下，豪不犹豫地选用C++语言来实现微服务，只要我们弄清楚了我们确实需要使用C++语言来实现微服务。&lt;/p&gt;

&lt;h2 id=&quot;什么时候需要使用c来实现&quot;&gt;什么时候需要使用C++来实现&lt;/h2&gt;
&lt;p&gt;回答这样的问题并没有一个放之四海而皆准的经验，因为微服务架构的其中一个关键要素就是需要考虑到具体的开发团队的因素，以及业务领域问题的具体需求。
很多时候这样的决策和选择需要不少深思熟虑和权衡才能找到最适合自己情况的那个选项。&lt;/p&gt;

&lt;h3 id=&quot;业务场景需求&quot;&gt;业务场景需求&lt;/h3&gt;
&lt;p&gt;从业务场景需求的角度来说，可能&lt;strong&gt;性能需求以及扩展性需求&lt;/strong&gt;是需要被着重考虑的。对于CPU密集型的微服务来说，选用一个以性能见长的编程语言可能是一个明智的选择，
这方面正是C++语言比较擅长的地方，也许只有Rust语言可以与之比肩，但是C++长期的历史积淀和成熟稳定的特性短期之内Rust还无法匹及。&lt;/p&gt;

&lt;h3 id=&quot;开发团队技能&quot;&gt;开发团队技能&lt;/h3&gt;
&lt;p&gt;从开发团队的方面来考虑，则必须要认识到&lt;strong&gt;C++语言对成员的编程水平总体上还是要求比较高&lt;/strong&gt;，尽管现代的C++语言标准一直在努力尝试往简化语言门槛的方向迈进。
如果既有的团队有很好的C/C++语言背景和丰富的系统编程知识，使用C++语言来做微服务是很自然的选择。
反之期望一个没有什么C/C++背景的团队来临时抱佛脚开发C++为主要语言的微服务很容易给项目的按序推进带来巨大的挑战。&lt;/p&gt;

&lt;h2 id=&quot;技术和工具&quot;&gt;技术和工具&lt;/h2&gt;

&lt;p&gt;假设这些因素我们都以及考虑周详，具体到实现上，是否就万事大吉可以马上撸起袖子开工写代码了呢？
&lt;strong&gt;不幸的是事情并没有那么简单&lt;/strong&gt;，稍微详细看一下这些技术栈就清楚了。
下面假设我们决定采用随处可见的流行的REST API + JSON的方式来实现微服务。&lt;/p&gt;

&lt;h3 id=&quot;rest框架&quot;&gt;REST框架&lt;/h3&gt;
&lt;p&gt;如前所述，REST技术栈本质上是基于HTTP协议之上的一些二次发挥；而选择C++实现的时候第一个现实的因素是&lt;strong&gt;C++标准库里面并没有提供HTTP协议的实现&lt;/strong&gt;，
这也是C++生态系统目前比较大的一个问题：标准库里面的东西实在是太少了，这里面一个很大的原因应该是能放到标准库里面的东西必须要经过委员会的仔细审查，加上过去近四十年的各种技术积累和包袱，加入新的库总要面临重口难调的窘境。
甚至于在Reddit上还有这么帖子就是在探讨&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/7ghn75/defactoindustry_standard_restful_serverlibraryapi/&quot;&gt;是否有一个事实标准的REST框架实现&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h4&gt;
&lt;p&gt;如果是将标准稍微放开一些，或者可以访问比较新的boost库，那么&lt;a href=&quot;https://www.boost.org/doc/libs/1_71_0/libs/beast/doc/html/index.html&quot;&gt;Beast&lt;/a&gt; 可以算一个比较冒险的选择，因为它也是在1.66版本才被加入进去。
要是你所在的公司或者组织由其它方面的考虑停留在了一个比较老的版本的Boost上，那么引入这么一个库就显得比较麻烦。&lt;/p&gt;

&lt;p&gt;Beast的主要特点如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;保持了header only的方式，最小化编译和链接依赖；副作用就是冗长模板元编译开销&lt;/li&gt;
  &lt;li&gt;采用Boost.asio的&lt;strong&gt;异步网络编程&lt;/strong&gt;模型和协程来实现高性能和高并发，熟悉这些库的话上手会比较容易&lt;/li&gt;
  &lt;li&gt;库本身提供的&lt;strong&gt;抽象层次比较高&lt;/strong&gt;，实际上手可能需要写比较多的代码，或者需要二次封装&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文档并不是很完备&lt;/strong&gt;，也许需要一些时间才能更加成熟&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rest-sdk&quot;&gt;REST SDK&lt;/h4&gt;
&lt;p&gt;微软平台上的C++程序员可能会更偏爱微软出品的&lt;a href=&quot;https://github.com/microsoft/cpprestsdk&quot;&gt;开源在GitHub上的REST SDK&lt;/a&gt;，同样的它也采用了异步编程模型。&lt;/p&gt;

&lt;p&gt;虽然是一个微软官方提供的开源库，它本身还是可以在多个平台上运行的，并且提供了流行Linux环境的二级制发布包，如果没有交叉编译的需求，可以直接下载安装。&lt;/p&gt;

&lt;h4 id=&quot;pistache-framework&quot;&gt;Pistache Framework&lt;/h4&gt;
&lt;p&gt;这是一个功能相当完善并且性能也很出色的REST框架，它本身的特色是&lt;strong&gt;能够和swagger的代码生成工具无缝结合&lt;/strong&gt;，可以用open API的声明来生成模型代码，极大简化了用户的编码负担。&lt;/p&gt;

&lt;p&gt;Pistache使用epoll机制来完成高性能的传输层，并提供了&lt;strong&gt;流式的API给用户使用&lt;/strong&gt;，用户可以在REST方法回调中使用异步API将内容写入流，就像操作一个标准输入输出流那样方便。&lt;/p&gt;

&lt;p&gt;但是由于这个&lt;strong&gt;epoll机制和核心的部分耦合比较紧密&lt;/strong&gt;，并且没有很好的办法来用epoll来模拟IOCP机制，因此如果需要在Windows上（甚至符合POSIX的Cygwin环境也是一样）使用该库则会碰上&lt;strong&gt;跨平台可移植性的难题&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;性能评估&quot;&gt;性能评估&lt;/h4&gt;
&lt;p&gt;C++程序的一个很大的关注点就是性能，
&lt;a href=&quot;https://blog.binaryspaceship.com/2017/cpp-rest-api-frameworks-benchmark/&quot;&gt;这篇博文&lt;/a&gt;
提供了一个性能评估数据，总体而言&lt;strong&gt;Pistache的性能明显占据上风&lt;/strong&gt;。
可惜这个对比的报告时间有些老，好在代码是开源的，拉取三个仓库自己的最新版本在本地虚拟机上跑一下，可以得到如下的结果：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;框架&lt;/th&gt;
      &lt;th&gt;98%请求完成的时间(ms)&lt;/th&gt;
      &lt;th&gt;每秒处理的请求数&lt;/th&gt;
      &lt;th&gt;示例代码的行数&lt;/th&gt;
      &lt;th&gt;Github星标&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cpprestsdk/default&lt;/td&gt;
      &lt;td&gt;107&lt;/td&gt;
      &lt;td&gt;12.23&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;4478&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cpprestsdk/RapidJSON&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;14.28&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;4478&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;restbed&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;32.54&lt;/td&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;1078&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pistache&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;182.85&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;1683&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;此外，因为最新的库代码以及发生了变更，因此原来repo中的&lt;strong&gt;示例代码或者CMakeLists.txt文件需要做些微调&lt;/strong&gt;，基本上按照对应项目的最新文档适度改动即可。我自己的虚拟机只分了２个CPU核，所以绝对数据比原作者的要低。&lt;/p&gt;

&lt;p&gt;稍微有点奇怪的是，从项目的流行度上来看，来自微软的开源项目cpprestsdk表现的更加热门一些，无论是星标数还是fork数字都非常亮眼；
但是这里的性能比较却是三者之中最差的一个，是否和微软的自带明星光环有关有待进一步详查。&lt;/p&gt;

&lt;h3 id=&quot;json解析和处理&quot;&gt;JSON解析和处理&lt;/h3&gt;

&lt;p&gt;传统的REST微服务实现用JSON来编码消息中的资源内容，因而&lt;strong&gt;JSON解析能力&lt;/strong&gt;是实现REST服务的一个重要的考量因素。
从使用的角度来看，JSON表述的文档结构常常可以简单地看作是一颗树结构，里面的具体节点元素只要符合
&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc8259/&quot;&gt;RFC8259规范要求&lt;/a&gt;(更老一点的版本是&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc4627/&quot;&gt;RFC4627&lt;/a&gt;)
就可以了。&lt;/p&gt;

&lt;p&gt;本质上来说，JSON的解析就是文本文件的解析，其语法规则比较简单直接，自己手工实现一个满足自己使用场景的也并非难事。
只是考虑到性能、跨平台、编码、代码大小等各种各样的要素带来的复杂性，直接&lt;strong&gt;复用已有的库&lt;/strong&gt;是更为明智的做法。&lt;/p&gt;

&lt;h3 id=&quot;开源实现比较&quot;&gt;开源实现比较&lt;/h3&gt;

&lt;p&gt;JSON处理的开源库非常多，目前就职于腾讯的&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc4627/&quot;&gt;MiloYip&lt;/a&gt;做了一个很好的比较总结，开源在&lt;a href=&quot;https://github.com/miloyip/nativejson-benchmark&quot;&gt;GitHub&lt;/a&gt;这里，
我们直接拿来参考就是了。&lt;/p&gt;

&lt;h4 id=&quot;比较对象&quot;&gt;比较对象&lt;/h4&gt;
&lt;p&gt;作者从如下几个方面考察了常见的数十个JSON库&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能兼容性&lt;/strong&gt;，包括校验，双精度数字的解析处理，字符串解析和压缩JSON文档的序列化反序列化；这在&lt;strong&gt;跨语言的微服务场景下尤为重要&lt;/strong&gt;，因为客户端可能是用另外一种完全不同的编程语言开发的&lt;/li&gt;
  &lt;li&gt;各种操作下的性能表现，包含
    &lt;ul&gt;
      &lt;li&gt;运行时间（越短越好）&lt;/li&gt;
      &lt;li&gt;处理过程中的内存占用&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;最大内存&lt;/strong&gt;占用情况（越少越好）&lt;/li&gt;
      &lt;li&gt;内存分配器调用次数多少，经验表明很多时候CPU的耗费时间有很大一部分花费在不必要的内存分配和释放操作上。&lt;strong&gt;更少的内存分配操作往往意味着更好的性能&lt;/strong&gt;，即便这个结论并不是绝对准确，否则也不会有各种各样优化小对象分配的内存分配器出现了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可执行文件的大小 - 在微服务的容器化场景下，这也是一个很重要的要素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;比较结果&quot;&gt;比较结果&lt;/h4&gt;
&lt;p&gt;各项的比较结果如下 - 因为&lt;strong&gt;JSONCPP是一个很早就出现并且得到广泛使用的JSON解析库&lt;/strong&gt;，这里将其单独放在一列做比较。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较项目&lt;/th&gt;
      &lt;th&gt;最高得分项目&lt;/th&gt;
      &lt;th&gt;第二名得分项目&lt;/th&gt;
      &lt;th&gt;第三名得分项目&lt;/th&gt;
      &lt;th&gt;jsoncpp&lt;/th&gt;
      &lt;th&gt;说明　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;功能兼容性　　&lt;/td&gt;
      &lt;td&gt;taocpp/json(100%)&lt;/td&gt;
      &lt;td&gt;RapidJSON_pre(100%)&lt;/td&gt;
      &lt;td&gt;configuru(99%)&lt;/td&gt;
      &lt;td&gt;85%&lt;/td&gt;
      &lt;td&gt;前三基本达到&lt;strong&gt;100%&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解析时间&lt;/td&gt;
      &lt;td&gt;RapidJSON(8ms)&lt;/td&gt;
      &lt;td&gt;gason(8ms)&lt;/td&gt;
      &lt;td&gt;json4c(9ms)&lt;/td&gt;
      &lt;td&gt;166ms&lt;/td&gt;
      &lt;td&gt;前三和后面的相差巨大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存占用　　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(4.8MB)&lt;/td&gt;
      &lt;td&gt;strdup(6.6MB)&lt;/td&gt;
      &lt;td&gt;Jvar(7.56MB)&lt;/td&gt;
      &lt;td&gt;24.56MB&lt;/td&gt;
      &lt;td&gt;Qt的数据不准确&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;序列化时间　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(11ms)&lt;/td&gt;
      &lt;td&gt;ujson(25ms)&lt;/td&gt;
      &lt;td&gt;jzon(28ms)&lt;/td&gt;
      &lt;td&gt;94ms&lt;/td&gt;
      &lt;td&gt;部分纯C实现表现较好&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;美化输出　　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(17ms)&lt;/td&gt;
      &lt;td&gt;ujson(29ms)&lt;/td&gt;
      &lt;td&gt;SchederdomJson(29ms)&lt;/td&gt;
      &lt;td&gt;NA&lt;/td&gt;
      &lt;td&gt;jsoncpp未提供　　　　&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可执行文件大小&lt;/td&gt;
      &lt;td&gt;pjson(15KB)&lt;/td&gt;
      &lt;td&gt;Qt(18KB)&lt;/td&gt;
      &lt;td&gt;RESTSDK(18.3KB)&lt;/td&gt;
      &lt;td&gt;243KB&lt;/td&gt;
      &lt;td&gt;C实现毫无疑问靠前，RapidJSON31KB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从结果来看，RapidJSON在多项比较重都名列前茅，称之为&lt;strong&gt;性能最好功能最全的JSON库&lt;/strong&gt;也毫不为过。&lt;/p&gt;

&lt;p&gt;需要额外指出的是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;RapidJSON提供了几个版本变种，默认情况下的版本提供了93%的标准兼容性，却能够在其它性能比拼中拔得头筹。
提供完全兼容的版本&lt;strong&gt;性能稍差一些或者毫无损失但在各项比较中依然排在前列&lt;/strong&gt;，这里没有列出它的其它变种的排名情况而是将它们合并在一起展示。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C版本的实现并没有特别明显的优势&lt;/strong&gt;，除了最后一向需要考虑可执行文件大小的场合，而C++的实现并没有落后太多。
这一项里RapidJSON的得分在C++里面居于第六，绝对大小依然远好于jsoncpp&lt;/li&gt;
  &lt;li&gt;某些REST库自身也提供了自己的JSON实现，比如来自&lt;strong&gt;微软的REST SDK，只是本身并不特别出彩&lt;/strong&gt;，在上述的REST比较重以及可以看到一些端倪，这里不赘述&lt;/li&gt;
  &lt;li&gt;RapidJSON的最初实现也来自于这个benchmark的作者，只是两三年前以及被重命名&lt;strong&gt;成为腾讯开源库的一部分&lt;/strong&gt;；目前在GitHub上有超过8000个👍&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于微服务的架构设计正在席卷几乎所有的软件开发组织，形形色色的开源的REST和JSON框架使得能否用C++来开发微服务这一简单问题的&lt;strong&gt;答案不言自明&lt;/strong&gt;。
在业务场景需要、团队技术能力匹配的情况下，使用上述的这些工具和框架库实现高性能的微服务不应该有任何障碍。
腾讯开源的FastJSON给了我们不少的惊喜，这也许是国内的大技术公司给开源社区的巨大贡献。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="cpp" /><category term="design" /><category term="tools" /><summary type="html">微服务架构模式是当今炙手可热的企业软件架构范式，经过最近几年的广泛的讨论和优缺点争辩之后已经随着 云原生架构　的逐渐火热而日益呈现星火燎原之势。 抛开这些争论不谈，假设我们需要实现一个微服务架构的服务，是否该用C++语言或者是否能用C++语言呢？</summary></entry><entry><title type="html">C++20 - 下一个大版本功能确定</title><link href="https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine/" rel="alternate" type="text/html" title="C++20 - 下一个大版本功能确定" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine/">&lt;p&gt;C++20的功能特性已经于3月份冻结，显然&lt;strong&gt;这次终于来了一波大的改进&lt;/strong&gt;，而不再是像之前C++14/C++17那般小打小闹的做小步快跑，尤其是三个讨论很久的大feature终于被合入主干；并且这些feature终将会极大地影响后续C++代码的书写方式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;核心语言特性终于有了大变化&quot;&gt;核心语言特性终于有了大变化&lt;/h2&gt;
&lt;p&gt;新的版本之所以被认为是下一个大的版本，主要原因还是来自于核心语言特性的扩充和简化。看起来好像两个目标有些互相矛盾，但是内在的逻辑其实还是统一的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;扩充新的特性可以弥补之前一些遗留已久的功能限制，&lt;strong&gt;方便提高程序员的生产力&lt;/strong&gt;，减少社区中长期存在的奇技淫巧侵蚀程序员宝贵的心智空间；&lt;/li&gt;
  &lt;li&gt;简化的方向主要是出于“照顾”新手程序员，帮助他们&lt;strong&gt;更快地上手产生生产力&lt;/strong&gt;而不是匍匐在陡峭的学习曲线上靠长期的实践积累来摸索，从而培养下一代的新鲜血液，否则语言就会因为失去活力而慢慢消亡；这显然不是标准委员会愿意看到的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从这两个角度看，也许片面地评价标准委员会的资深专家们为“学院派”或者“老学究”，总归是有些不合适的；因为C++一开始在90年代上半段的风靡完全是因为它是一门实用的程序语言。
只是随着时间的推进，很多&lt;strong&gt;早期做出的设计决策多多少少被整个产业界的各色各样的业务需求催生的奇技淫巧所侵蚀&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;尤其是&lt;strong&gt;模板元编程的流行和语言特性本身的滞后&lt;/strong&gt;带来的矛盾一直没有得到合适的处理，背后的原因正是标准委员会需要照顾已有的软件代码的兼容性（当然背后也有很多大公司的利益考量），妥协再妥协；最终演变成不得不变的地步。&lt;/p&gt;

&lt;h2 id=&quot;concepts&quot;&gt;Concepts&lt;/h2&gt;
&lt;p&gt;像concept这样可以&lt;strong&gt;明显提升程序员生活质量&lt;/strong&gt;的特性(想象一下用错了一个容器的成员函数之后GCC打印出来的”成吨”的编译错误，很多程序员形容是恨不得捏着鼻子绕着走)，愣是从C++03定稿之后就被提出出来，却活生生被推迟了一次又一次，甚至GCC的版本库上的concepts分支都经历了加上来又移除掉的曲折过程 - &lt;strong&gt;速度和质量&lt;/strong&gt;始终是一对很难权衡的矛盾。&lt;/p&gt;

&lt;p&gt;幸好，经历了&lt;strong&gt;十几年的再三讨论&lt;/strong&gt;，concept这一模板元大杀器终于被投票送进了C++20标准的正式列表里。&lt;/p&gt;

&lt;p&gt;关于Concepts最好的介绍当然是Bjarne自己的这篇&lt;a href=&quot;http://www.stroustrup.com/good_concepts.pdf&quot;&gt;Concepts: The Future of Generic Programming&lt;/a&gt;的文章，
另外一个比较好的描述来自于&lt;a href=&quot;https://en.cppreference.com/w/cpp/concepts&quot;&gt;cppreference&lt;/a&gt;；简单来说，它完成的事情就是用来描述泛型定义中，关于&lt;strong&gt;类型参数的约束和校验&lt;/strong&gt;；
出于零成本的考虑，我们需要做到这个校验可以&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在&lt;strong&gt;编译期间完成&lt;/strong&gt;检查，对生成的实际代码没有影响（就像手写的代码一样）&lt;/li&gt;
  &lt;li&gt;具备&lt;strong&gt;定义良好的接口&lt;/strong&gt;形式，可以方便地进行组合&lt;/li&gt;
  &lt;li&gt;尽量地保持通用性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用concepts&quot;&gt;使用Concepts&lt;/h3&gt;

&lt;p&gt;通过使用concepts，传统的模板元编程方面关于编译错误的痛点可以得到极大改善，编译器可以给出更加符合人类直觉的错误提示。
比如标准库中的&lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;std::find&lt;/a&gt;算法的声明如下：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InputIt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;strong&gt;两个模板参数其实有更多额外的要求&lt;/strong&gt;用传统的语法是没法表达的，第一个类型参数&lt;code class=&quot;highlighter-rouge&quot;&gt;Input&lt;/code&gt;我们期望它是一个可遍历的迭代器类型，并且其中的元素类型需要和&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;类型匹配，并且该类型能够用来做相等比较。
这些&lt;strong&gt;约束条件在现有的语言标准中都是隐性&lt;/strong&gt;的，一旦用错，编译器就会拿海量的错误信息来招呼你，因为编译器背后会使用SFINAE这样的语言特性来比较各种重载并给出一个常常的candidate列表，然后告诉你任何一个尝试都没有成功，所以失败了。&lt;/p&gt;

&lt;p&gt;Concepts相当于将这些要求用一种显而易见的方式给出来，比如我们想表述一个在序列容器上查找的类似算法，可以用concepts来描述为&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//using alias
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候如果使用不满足条件的输入参数，编译器会直观地告诉我们错误的具体原因&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;waldo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//okay
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//error! - can't compare string and double
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//okay
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;waldo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//error! - can't compare double and string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然这里的例子有点啰嗦，出于&lt;strong&gt;节约键盘敲击次数&lt;/strong&gt;的考虑（Java太啰嗦了？原来的模板元函数的写法也已经够啰嗦的了！），可以进一步简化这个写法，将简单的concepts约束直接嵌入到声明的地方：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义concepts&quot;&gt;自定义concepts&lt;/h3&gt;
&lt;p&gt;对于上面的简单的concepts，标准库已经提供了一个开箱可用的封装，不过&lt;strong&gt;出于学习目的自己动手做一个轮子&lt;/strong&gt;也很简单。比如用上面的比较为例，可以写作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;concept&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//compar with ==, and should return a bool
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//compare with !=, and should return a bool
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;语法上和定义一个模板元函数很想象，所不同的地方是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这里我们定义的对象是一个关于类型的检查约束&lt;/li&gt;
  &lt;li&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;requires&lt;/code&gt;部分引申出具体的检查约束，必须同时实现操作符相等和不相等，两个操作符都需要返回bool类型&lt;/li&gt;
  &lt;li&gt;整个concept本身可以用在逻辑表达式中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;简化concept的格式负担&quot;&gt;简化concept的格式负担&lt;/h3&gt;
&lt;p&gt;如果能将简单的事情变得更简单，为什么不更进一步呢？这个设计哲学是C++的核心设计思想之一（参见Bjarne的D&amp;amp;E CPP），考虑下面的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;Sortable&lt;/code&gt;表示某个可以被排序的容器类型；因为concept也是用于限制类型，而函数的参数也是用来限定类型，一个自然的想法就是逐步简化它&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//应用上述的简化方式，concept描述放在模板参数声明中
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;进一步地，去掉&lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt;部分的声明会更加简单，&lt;strong&gt;就像是一个普通的函数声明&lt;/strong&gt;，只不过参数类型是一个编译器可以检查的泛型类型&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样一来，就和其它语言中的接口很类似了，没错就和Java的JDK中的泛型接口很相似了；只是底层的实现技术是完全不一样的，Java由于根深蒂固的OO设计而不得不借助于类型擦除术；当然这个扯的稍微远了一点。&lt;/p&gt;

&lt;h3 id=&quot;auto类型的参数&quot;&gt;auto类型的参数&lt;/h3&gt;
&lt;p&gt;其实C++14里面已经允许了&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;作为函数参数的类型这一用法，显然它和&lt;code class=&quot;highlighter-rouge&quot;&gt;concept&lt;/code&gt;的简化写法完全不矛盾。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x实际上可以是任意类型!
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//x和y可以是任意的类型，可以不相同
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在多个参数的情况下， 如果我们想限定两个参数的类型必须总是一样，有一种很简单的机巧做到&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concept&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//任何类型都是Any
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//x和y的类型必须相同，尽管他们可以是任意类型
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;标准库中的预定义concepts&quot;&gt;标准库中的预定义concepts&lt;/h3&gt;
&lt;p&gt;C++20的标准库中预备了很多开箱即用的concepts，通过库的方式提供，用户只需要包含&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;concepts&amp;gt;&lt;/code&gt;库即可。
详细的列表可以参考&lt;a href=&quot;https://en.cppreference.com/w/cpp/header/concepts&quot;&gt;concepts header&lt;/a&gt;;从大的分来来看，包括&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;核心语言相关的concepts，比如判断类型是否相同，是否是由继承关系，是否可以赋值/拷贝/构造/析构/转换等。&lt;/li&gt;
  &lt;li&gt;比较相关的concepts，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;用来判断是否可以用在逻辑判断上下文中，&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparable&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparableWith&lt;/code&gt;声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;运算符是否表述等价关系；&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictTotallyOrdered&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictTotallyOrderedWith&lt;/code&gt;声明了比较运算符是否产生一个完全有序的结果&lt;/li&gt;
  &lt;li&gt;关于对象的concepts，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Movable&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Copyable&lt;/code&gt;，分别声明可移动和可拷贝（包含了可以swap），而&lt;code class=&quot;highlighter-rouge&quot;&gt;Semiregular&lt;/code&gt;声明对象是否可以被移动/拷贝/交换/默认构造；&lt;code class=&quot;highlighter-rouge&quot;&gt;Regular&lt;/code&gt;则等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;Semiregular&lt;/code&gt;加上&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;关于函数调用的concepts，包含&lt;code class=&quot;highlighter-rouge&quot;&gt;Invocable&lt;/code&gt;(声明对应的类型可以想函数一样调用并用给定的一系列参数来作为输入参数)，&lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&lt;/code&gt;指定可调用的对象符合断言约束并返回bool，&lt;code class=&quot;highlighter-rouge&quot;&gt;Relation&lt;/code&gt;指定对应的可调用函数是一个二元函数；&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictWeakOrdering&lt;/code&gt;则表明对应的函数满足&lt;a href=&quot;https://en.cppreference.com/w/cpp/concepts/StrictWeakOrder&quot;&gt;弱排序&lt;/a&gt;(具体细节需要一些逻辑数学知识)&lt;/li&gt;
  &lt;li&gt;用于range库的对象交换要求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应该可以预期后续的版本将会加入更多的支持。&lt;/p&gt;

&lt;h3 id=&quot;编译器的支持情况&quot;&gt;编译器的支持情况&lt;/h3&gt;
&lt;p&gt;GCC目前仍然是通过TS的方式来支持，编译时候需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;-fconcepts&lt;/code&gt;开关；
Clang的全功能支持已经在将近一年前&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/958sj9/clang_concepts_is_now_featurecomplete/&quot;&gt;在redit上宣布完工&lt;/a&gt;，只是其&lt;a href=&quot;https://clang.llvm.org/cxx_status.html&quot;&gt;官方的列表&lt;/a&gt;上依然没有更新。
MSVC则于更早一点宣布了完整的concept支持，只是我们需要Visual Studio 2017 15.7版本。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The MSVC compiler toolset in Visual Studio version 15.7 conforms with the C++ Standard!
&lt;br /&gt; https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总体上看来，GCC的开发进度有些迟缓，clange的也不算很透明，只有MSVC比较领先。&lt;/p&gt;

&lt;h2 id=&quot;模块化支持&quot;&gt;模块化支持&lt;/h2&gt;
&lt;p&gt;模块支持被写入新的语言核心，这一新的封装方式甚至可以认为是&lt;strong&gt;C++诞生35年以来最大&lt;/strong&gt;的一个新功能；
也是语言标准化以来，第一次通过修改核心语法允许程序员用一种&lt;strong&gt;全新的方式来描述带命名的信息封装边界&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;信息封装手法的更新&quot;&gt;信息封装手法的更新&lt;/h3&gt;
&lt;p&gt;传统的封装手段基本上都是采用如下的方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将用户自定义的结构或者类取一个名字&lt;/li&gt;
  &lt;li&gt;将相关联的细节都隐藏在这个名字的后面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不管是变量声明，函数定义，自定义的类，结构体，无一例外都满足这个模式。即使是模板元编程方法，其实也是通过类型绑定的方法间接地使用上述的封装手段。&lt;/p&gt;

&lt;h3 id=&quot;头文件的不完美封装&quot;&gt;头文件的不完美封装&lt;/h3&gt;
&lt;p&gt;除了上述的基本信息封装单元，C++中屈指可数的封装办法&lt;strong&gt;就剩下了从古老的C语言继承下来的头文件包含&lt;/strong&gt;的方式了。
在软件规模还局限在数万行代码一下的时代，使用头文件的方式一股脑将需要的东西都大包大揽在一个编译单元中，然后使用诸如唯一定义规则的方法让链接器在生成最终可执行代码或者库的时候做冲突检测是一个&lt;strong&gt;简单而优雅&lt;/strong&gt;的方案。
因为对于它想解决的问题规模来说，这样的解决方案就足够了。&lt;/p&gt;

&lt;p&gt;然而随着行业中软件项目的复杂性与日俱增，越来越多的商业项目&lt;strong&gt;需要数百甚至上千的头文件&lt;/strong&gt;被包含在一个编译单元中，这个时候既有的方式就越来越捉襟见肘&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;编译时间长&lt;/strong&gt;成为了一个突出的痛点，以至于实际项目中出于减少编译时间的考虑，聪明的工程师发明了如IWYU的&lt;strong&gt;头文件检测工具来缓解&lt;/strong&gt;这一问题&lt;/li&gt;
  &lt;li&gt;像pimp惯用法这样的技术手段可以减少放在头文件中的依赖，但是程序员却不得不&lt;strong&gt;承担额外内存申请&lt;/strong&gt;的开销（可能没有这么个指针很多对象本身就可以在栈上完成快速构造和析构），即使有了&lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt;来环境内存泄露的隐忧&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板方式提供的抽象代码无法声明，必须放置在头文件中内联实现&lt;/strong&gt;，否则对应的cpp文件在编译单元进行代码生成的时候会因为找不到定义而无法通过编译；之前提出的一些export声明也因为种种缺陷和编译器支持不力而被废弃&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单来看，&lt;strong&gt;现代的编程语言都或多或少带有模块化系统&lt;/strong&gt;；缺乏现代的模块化支持成为了C++语言的一种硬伤，严重制约了C++开发大项目的能力。&lt;/p&gt;

&lt;h3 id=&quot;模块化系统需要的核心功能&quot;&gt;模块化系统需要的核心功能&lt;/h3&gt;

&lt;p&gt;模块化是一个很自然的逻辑信息隐藏手段，一个良好的模块化系统应该允许&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;良好的信息隔离&lt;/strong&gt;，可以方便的指定哪些可以被外部访问，哪些应该不允许被外部访问&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;嵌套的隔离机制&lt;/strong&gt;，即可以在模块中嵌套子模块&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;细粒度的访问权限&lt;/strong&gt;控制，尤其是能提供模块内部/模块外部/子模块不同的访问权限则更好&lt;/li&gt;
  &lt;li&gt;和&lt;strong&gt;操作系统的文件访问系统保持一致的视图&lt;/strong&gt;，比如期望子文件夹可以对应子模块是一个非常符合直觉的方法&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;类似命名空间的隔离和访问&lt;/strong&gt;，比如支持重新导出一些模块中公开的可访问部分到另外一个空间中或者嵌套的命名、重命名模块等&lt;/li&gt;
  &lt;li&gt;和&lt;strong&gt;构建系统、打包系统&lt;/strong&gt;具有清晰易懂的交互接口；支持语言本身和IDE、语法检查等生态系统工具设施的无缝融合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要同时实现这些目标，并没有想象中的容易；其它一些流行的编程语言其实都小心仔细地对这些可能“讨好”程序员的目标做取舍，并在定义中详细地描述好限制。
比如Java一开始用Jar打包的方式来模拟模块，但是却由于不支持嵌套子模块中复杂的访问控制而遭到很多用户的不满；而Go语言中的模块和文件系统中文件名的纠葛同样也是Go语言中一个晦涩的知识点。
NodeJS通过NPM机制来提供模块化支持，然而其嵌套的打包方式和让人窒息的依赖树结构导致打包的时候需要依赖其它的第三方工具才能避免中招。&lt;/p&gt;

&lt;h3 id=&quot;后向兼容的艰难挑战&quot;&gt;后向兼容的艰难挑战&lt;/h3&gt;
&lt;p&gt;C++的模块机制是奔着替换旧有的头文件包含机制的目标来的，同时又因为需要照顾庞大的既有代码库不被破坏而&lt;strong&gt;不得不同时兼容头文件包含机制&lt;/strong&gt;。
和已有的其它语言特性一样，这种向后兼容带来的额外复杂性是否是必要的还又不小不同的声音，不过主流的声音还是决定走兼容的道路。&lt;/p&gt;

&lt;h3 id=&quot;基本语法&quot;&gt;基本语法&lt;/h3&gt;
&lt;p&gt;如果我们希望声明一个模块，可以用如下的语法&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//声明一个模块名字为example
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可以导出的函数
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为我们丢弃了头文件的方法，可以将该模块定义保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;example.cppm&lt;/code&gt;的文件中。这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;cppm&lt;/code&gt;后缀用于告诉编译器这是一个模块定义文件。&lt;/p&gt;

&lt;p&gt;假设我们希望使用该模块，则用如下的代码&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//导入上述定义的模块
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//调用example模块中的函数
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分离模块接口和实现&quot;&gt;分离模块接口和实现&lt;/h4&gt;
&lt;p&gt;如果我们想&lt;strong&gt;分离模块的声明和实现，将他们放在不同的文件&lt;/strong&gt;中，这样更符合传统的接口定义和实现分离的编写代码方法（其实可以看作是C++比Java更干净的一个地方），我们可以对上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;example.cppm&lt;/code&gt;做如下的修改&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后创建一个源代码文件，放置模块函数的实现&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//当前模块是example
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出于灵活起见，C++20支持将一个模块中声明的&lt;strong&gt;函数放在多个模块实现单元中分别实现&lt;/strong&gt;，这样更容易实现干净的代码，并提高编译速度。&lt;/p&gt;

&lt;h4 id=&quot;隔离权限指定&quot;&gt;隔离权限指定&lt;/h4&gt;
&lt;p&gt;模块访问权是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt;声明来指定的，&lt;strong&gt;没有声明的类或者函数等默认是不能被外部代码访问&lt;/strong&gt;的；基于声明的语法也决定了如果分离声明和实现，可见性在实现单元中其实是忽略的。&lt;/p&gt;

&lt;p&gt;为了避免代码变得过于啰嗦，语法层面上也支持通过括号作用于一次性声明多个导出函数或者类，比如&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doAnother&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internalImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//外部不可访问
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;模块和namespace是正交的语言设施&quot;&gt;模块和namespace是正交的语言设施&lt;/h4&gt;

&lt;p&gt;旧的C++标准早就支持通过namespace来实现信息封装和隔离，而新的module机制可以和namespace结合使用，提供清晰的隔离结构，比如&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doAnother&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;语言机制上提供了灵活的手段，但是程序员却要自己&lt;strong&gt;做好权衡，保持模块的粒度适中&lt;/strong&gt;，匹配实际的应用场景。&lt;/p&gt;

&lt;h4 id=&quot;模块重新导出&quot;&gt;模块重新导出&lt;/h4&gt;
&lt;p&gt;实际应用中，复杂的软件项目可能有很多形形色色的模块，它们可能处于不同的抽象单元；和应用代码比较近的上层模块可能&lt;strong&gt;需要将某些它自己可见的模块开放给上层代码直接使用&lt;/strong&gt;，提供重新导出的功能可以极大地提高信息封装的能力，提高模块的内聚度减少不必要的耦合。&lt;/p&gt;

&lt;p&gt;一个简单的方法就是将import的部分重新放在export块中，即下面的代码例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low_module1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low_module2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;标准库中的模块&quot;&gt;标准库中的模块&lt;/h3&gt;
&lt;p&gt;标准库中提供的工具函数和类显然应该被模块化，只需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;import std.xxx&lt;/code&gt;即可导入。
现代的WG21委员会的工作方式是有很多并行开发但是还没有进入主干库的”准标准库”，编译器可以选择实现，等到对应的规范成熟的时候，它们才会被正式地移入标准库中。&lt;/p&gt;

&lt;p&gt;Visual C++的封装方式如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.filesystem&lt;/code&gt;提供文件系统的库，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;experimental/filesystem&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.memory&lt;/code&gt; 提供智能指针的库，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;memory&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.regex&lt;/code&gt;提供对正则表达式库的封装，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.threading&lt;/code&gt;提供对线程库的支持（已经于C++11中正式支持），相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;atomic&amp;gt;/&amp;lt;future&amp;gt;/&amp;lt;mutex&amp;gt;/&amp;lt;thread&amp;gt;/&amp;lt;shared_mutex&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.core&lt;/code&gt;包含了其它所有的标准库设施&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;潜在的争议&quot;&gt;潜在的争议？&lt;/h3&gt;

&lt;p&gt;作为一门有着30多年历史的语言，模块化机制的一个设计难点就是&lt;strong&gt;保持和古老的include机制（本质上是代码的复制）兼容该如何实现&lt;/strong&gt;。
好在WG21经过漫长的讨论终于实现了起码在理论上完美的兼容 - 用户可以自由混用两者，只要不产生重复和链接问题即可。
Redit的cpp频道里面有人发起了一个&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/agcw7d/c_modules_a_chance_to_clean_up_the_language/&quot;&gt;是否提供一种机制让用户强制在某一个模块中清理旧有的include模式的讨论&lt;/a&gt;，采用的思路正式类似Rust语言的版本指定的思路。&lt;/p&gt;

&lt;p&gt;这个想法其实有很重要的现实意义，因此有很多自身CPP用户发表了自己的看法，大概标准定义成现在这个样子应该主要是两个方面的原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;委员会中的代表有很多来自于大公司，这些公司有海量的遗留代码；因此出于&lt;strong&gt;自身利益的考虑&lt;/strong&gt;他们不会选择一种不兼容的方案和自己过不去。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;社区分裂的风险&lt;/strong&gt;，这个其实从C++03诞生依赖就有人开始质疑，乃至于早期的D语言就是冲着这一点不满才决定选择单干，可惜有评论认为现在的D语言的分裂情况和C++比较起来完全是不遑多让的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;这些问题其实都是很现实的问题&lt;/strong&gt;，个人觉得WG21选择向后兼容的思路并没有什么问题，因为从新发明轮子的时候都是简单的，真正&lt;strong&gt;复杂的是如何长期稳定地维护和更新&lt;/strong&gt;。
C++的使用领域一直在缩小（或者有人说它是退回到了适合的领域）是个不争的事实，然而在适合的领域，它的优势不光在于语言本身还依赖于这些遗留系统的支撑。&lt;/p&gt;

&lt;h2 id=&quot;协程支持&quot;&gt;协程支持&lt;/h2&gt;
&lt;p&gt;协程并不是一个新鲜的概念，甚至在现代编程语言出现之前很久就被提出出来，并在其它一些编程语言中被实现了很长时间了；它的基本思想是要求一个函数或者过程可以在执行过程中被操作系统或者调度器临时中止，然后在适合的时机（获取CPU计算资源等）再被恢复执行。详细的描述可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;为什么需要协程&quot;&gt;为什么需要协程&lt;/h3&gt;
&lt;p&gt;协程最明显的一个好处是允许我们书写&lt;strong&gt;看起来顺序执行但是其实背后却异步执行的代码&lt;/strong&gt;，这样技能协调人大脑擅长顺序逻辑和计算机处理擅长异步执行的矛盾，兼顾效率和心智负担。
同时协程还可以支持惰性赋值和初始化的逻辑，进一步提高程序的运行效率（仅仅在需要的时候做运算）但是又不对程序员的大脑产生太多的额外负担。&lt;/p&gt;

&lt;p&gt;协程是一个比进程和线程更轻量级一点的概念，具体实现上来说可以分为有栈协程和无栈协程；技术上来说前者可以通过第三方库实现就可以，但是性能开销比较大也容易出问题；而&lt;strong&gt;无栈协程更加轻量级但是需要语言特性上做出改动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;C++20引入的协程属于无栈协程。&lt;/p&gt;

&lt;h3 id=&quot;基本语法定义&quot;&gt;基本语法定义&lt;/h3&gt;
&lt;p&gt;C++中的协程首先要是一个函数，它满足如下特性&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;可以被中止，保存状态然后在合适的时机恢复执行 - 这也是协程的基本要求&lt;/li&gt;
  &lt;li&gt;本身是不需要额外的栈的，即stackless&lt;/li&gt;
  &lt;li&gt;当被暂时中止的时候，执行权被交回了调用者&lt;/li&gt;
  &lt;li&gt;它的定义语法满足下述的特征&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;协程函数语法和关键字&quot;&gt;协程函数语法和关键字&lt;/h4&gt;
&lt;p&gt;协程函数定义可以又如下一些特征：&lt;/p&gt;

&lt;h5 id=&quot;co_await操作符等待另外一个协程的完成&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt;操作符等待另外一个协程的完成&lt;/h5&gt;
&lt;p&gt;比如如下的从网络读取数据并写回对方的echo代码，从逻辑上看循环内部的两行代码是顺序执行的，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;关键字却标明了逻辑上它是&lt;strong&gt;通过”等待“另外一个协程完成&lt;/strong&gt;才继续往下执行的。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_echo_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_read_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;co_yield-可以直接挂起当前的协程执行并返回一个值&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_yield&lt;/code&gt; 可以直接挂起当前的协程执行并返回一个值&lt;/h5&gt;
&lt;p&gt;比如下面的循环中，每次到&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;操作的时候，当前的协程便被暂时中止执行并返回一个整数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;generator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;co_yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种用法在其它语言中也叫generator函数或者生成器。&lt;/p&gt;

&lt;h5 id=&quot;co_return用于直接返回&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;用于直接返回&lt;/h5&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lazy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;返回类型要求&quot;&gt;返回类型要求&lt;/h5&gt;
&lt;p&gt;因为协程的返回值并不是普通的值而是一个可以和另外一个协程相互协作的对象，因此C++标准对协程的返回值有如下要求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能使用可变参数&lt;/li&gt;
  &lt;li&gt;不能使用普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句&lt;/li&gt;
  &lt;li&gt;不能返回自动推导的类型，如&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;concept&lt;/code&gt;类型等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时如下的函数也不能是协程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt;函数因为需要在编译器运算，不能是协程&lt;/li&gt;
  &lt;li&gt;构造函数和析构函数用于普通对象的构造，也不能被延迟执行进而不能是协程&lt;/li&gt;
  &lt;li&gt;主函数不能是协程，否则操作系统无从启动程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;协程的执行&quot;&gt;协程的执行&lt;/h3&gt;

&lt;p&gt;任何一个协程其实由如下这些要素构成&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;promise&lt;/code&gt;对象需要充当一个桥梁&lt;/strong&gt;，由协程内部改变其状态，将值提交给另外一方等待该promise的协程&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;外部协程操控另外一个协作协程的句柄&lt;/strong&gt;，外部协程需要借助该句柄来决定是否挂起对方的协程或者将其协程帧销毁&lt;/li&gt;
  &lt;li&gt;隐式的&lt;strong&gt;协程状态对象&lt;/strong&gt;，该对象需要能够
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;保存内嵌的promise对象&lt;/li&gt;
        &lt;li&gt;用值拷贝方法传递的参数值对象 - 显然出于内存安全的考虑不能由引用或者指针&lt;/li&gt;
        &lt;li&gt;当前执行到哪个阶段的状态标识，从而外部协程知道下一步是否应该迁移状态还是需要销毁帧数据&lt;/li&gt;
        &lt;li&gt;其它一些生存期超越当前挂起点的局部变量&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;协程执行的流程&quot;&gt;协程执行的流程&lt;/h4&gt;
&lt;p&gt;当一个协程执行的时候，它的实际运行顺序如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来分配上述的状态对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拷贝所有的函数参数&lt;/strong&gt;到这个对象中（因为协程本身也是个函数），值类型直接拷贝，如果由&lt;strong&gt;引用或者指针类型，其安全性需要程序员自己保证有效性&lt;/strong&gt;，因为在协程中他们同样使引用和指针&lt;/li&gt;
  &lt;li&gt;构造promise对象，这里先查找它&lt;strong&gt;是否支持对应协程所有传入参数为参数签名的构造函数&lt;/strong&gt;并调用，如果没有则调用默认构造函数来构造&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.get_return_object&lt;/code&gt;函数，将结果放在一个局部变量中；这样&lt;strong&gt;第一次协程被挂起的时候，该局部变量就可以被返回给调用者&lt;/strong&gt;。如果在第一次执行到挂起之前发生了异常，对应的结果都不会放置在promise中，而是通过该局部变量返回&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.initial_suspsed&lt;/code&gt;函数，并使用&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt;等待它的结果。通常情况下，promise类型要么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_always&lt;/code&gt;,要么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_never&lt;/code&gt;;前者对应的使延迟启动的协程，后者则对应提前启动的协程&lt;/li&gt;
  &lt;li&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await promise.initial_suspend&lt;/code&gt;恢复的时候，协程的函数体才开始别执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当该协程函数执行到一个挂起点，返回对象将会通过必要的类型转换返回给外部协程的等待方。&lt;/p&gt;

&lt;h5 id=&quot;返回&quot;&gt;返回&lt;/h5&gt;
&lt;p&gt;如果协程函数执行到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;语句，则执行如下的操作&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果返回类型是如下的几种，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.return_void&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return expr;&lt;/code&gt; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;的类型其实是void&lt;/li&gt;
        &lt;li&gt;直接跳过了可能的&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;语句而执行到了函数的结果；如果promise对象恰好定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise::return_void()&lt;/code&gt;函数，那么&lt;strong&gt;行为就是未定义&lt;/strong&gt;的，需要格外留意！&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;否则将调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.return_value(expr)&lt;/code&gt;返回需要的类型&lt;/li&gt;
  &lt;li&gt;销毁协程开始阶段创建的所有的局部自由变量，销毁的顺序和构造顺序相反&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.final_suspend&lt;/code&gt;函数，并等待其&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;结果&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;协程异常处理&quot;&gt;协程异常处理&lt;/h5&gt;
&lt;p&gt;如果协程中抛出了&lt;strong&gt;未捕获异常&lt;/strong&gt;，它的行为如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;捕获异常，并调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.unhandled_exception&lt;/code&gt;函数&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.final_suspend&lt;/code&gt;函数，并等待其&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;结果&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;状态对象的销毁&quot;&gt;状态对象的销毁&lt;/h5&gt;
&lt;p&gt;当协程状态对象因为&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;或者异常情况需要销毁的时候，其执行过程如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用promise对象本身的析构函数&lt;/li&gt;
  &lt;li&gt;调用协程参数对象的析构函数&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator delete&lt;/code&gt;来完成对状态对象本身的销毁&lt;/li&gt;
  &lt;li&gt;将执行权交回外部调用者&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;堆内存分配&quot;&gt;堆内存分配&lt;/h3&gt;
&lt;p&gt;协程的状态&lt;strong&gt;必须要通过&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来分配，因为标准要求这里必须是无栈协程。分配过程遵循如下两条规则&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型定义了一个类级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;，则&lt;strong&gt;优先选择此分配方法&lt;/strong&gt;，否则会调用全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来完成内存分配&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型定义了自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;，并且&lt;strong&gt;其函数签名和协程的函数参数签名一致，这些参数将会被一并传递&lt;/strong&gt;给该函数，这样的目的是为了和leading allocator convention的行为保持一致，即签名一致的分配器有优先权&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;可能的分配优化&quot;&gt;可能的分配优化&lt;/h4&gt;
&lt;p&gt;如果有办法事先确认协程状态对象的生存周期一定比调用方的生存周期短，并且该协程的帧大小在调用的时候可以明确得到。
该优化即使对用户自定义的内存分配器也可以使用。
这种情况下，&lt;strong&gt;被调用的协程的栈帧其实是内嵌在了调用方的函数栈帧&lt;/strong&gt;中，就像一个迷你的内联函数调用一样。&lt;/p&gt;

&lt;h3 id=&quot;promise类型&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型&lt;/h3&gt;
&lt;p&gt;实际的promise类型则由&lt;strong&gt;编译器根据实际协程声明中的签名类型&lt;/strong&gt;结合&lt;code class=&quot;highlighter-rouge&quot;&gt;std::corountine_traits&lt;/code&gt;模板推到得出。&lt;/p&gt;

&lt;p&gt;比如当一个协程的类型被定义为 &lt;code class=&quot;highlighter-rouge&quot;&gt;task&amp;lt;float&amp;gt; foo(std::string x, bool flag)&lt;/code&gt;，那么编译器推导出来的类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果协程被定义为非static的成员函数，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const&lt;/code&gt;,对应的推导出来的Promise类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;,同时对象类型会被放置在第一个参数模板了行中。&lt;/p&gt;

&lt;h3 id=&quot;编译器支持情况&quot;&gt;编译器支持情况&lt;/h3&gt;

&lt;p&gt;Visual Studio是这个提案的主推者之一，所以早在2013年MSVC就提供了自己的协程实现；并且在&lt;a href=&quot;https://devblogs.microsoft.com/cppblog/yield-keyword-to-become-co_yield-in-vs-2017/&quot;&gt;VS2017中正式将关键字向标准提案靠拢&lt;/a&gt;。
Clang也提供了支持，尽管&lt;a href=&quot;https://clang.llvm.org/cxx_status.html&quot;&gt;其C++ Status页面&lt;/a&gt;显示的还是partial支持。
遗憾的是GCC的corountine支持还处于比较早期的阶段，目前仍然在一个&lt;a href=&quot;https://gcc.gnu.org/wiki/cxx-coroutines&quot;&gt;分支上开发&lt;/a&gt;。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="engineering" /><category term="language" /><category term="cpp" /><summary type="html">C++20的功能特性已经于3月份冻结，显然这次终于来了一波大的改进，而不再是像之前C++14/C++17那般小打小闹的做小步快跑，尤其是三个讨论很久的大feature终于被合入主干；并且这些feature终将会极大地影响后续C++代码的书写方式。</summary></entry><entry><title type="html">C++正则表达式比Python慢？</title><link href="https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize/" rel="alternate" type="text/html" title="C++正则表达式比Python慢？" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize/">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B17&quot;&gt;C++17&lt;/a&gt; 推出已经有将近3年的时间，速度快一些的公司才慢慢采纳了6年前的C++14进入正式的生产环境。
程序员们的一个大福利就是终于不用外挂第三方库（无论是准标准的boost还是其它形形色色的其它第三方库）就可以直接方便地使用标准库自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;来写代码；
这显然比直接使用原始而笨拙的&lt;code class=&quot;highlighter-rouge&quot;&gt;string::find_first_of&lt;/code&gt;外加一堆边界检查和判断&lt;strong&gt;要轻松和干净&lt;/strong&gt;很多。&lt;/p&gt;

&lt;p&gt;然而&lt;a href=&quot;https://stackoverflow.com/questions/14205096/c11-regex-slower-than-python&quot;&gt;stackoverflow上&lt;/a&gt;的一位&lt;strong&gt;注重性能&lt;/strong&gt;的&lt;a href=&quot;https://stackoverflow.com/users/239007/locojay&quot;&gt;程序员&lt;/a&gt;**很快就发现有些地方不对：好像这个新的regex标准库API是长的漂亮了不少，但是性能似乎和C++的“零成本的抽象”格格不入？&lt;/p&gt;

&lt;h2 id=&quot;python版本比c快很多&quot;&gt;Python版本比C++快很多？&lt;/h2&gt;

&lt;p&gt;locojay给出来一个非常简单的使用正则表达式来分隔字符串的代码，并且比较了C++版本和Python版本的运行时间（自然Python语言在C++社区特别受欢迎不是空穴来风），发现C++版本慢的不可理喻。&lt;/p&gt;

&lt;p&gt;C++代码比较简单：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;刨去&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数种的调用，实现的代码是典型的使用迭代器来生成新的split子迭代器，并构造为&lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;返回。&lt;/p&gt;

&lt;p&gt;对应的python版本如下&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' +'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'a b c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行的结果却让人大跌眼镜，即使在使用了最大可能的优化选项-O3（C/C++&lt;strong&gt;性能很好的重要来源之一就是几十年间积累的形形色色的编译器后端优化能力&lt;/strong&gt;）之后，两者居然&lt;strong&gt;相差了50%之多并且是C++版本慢&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;注：下面的结果是我自己虚拟机里面跑出来的结果，&lt;strong&gt;原问题回答者的结果似乎还要慢了不少几乎是Python版本的运行时间的两倍&lt;/strong&gt;，也许是因为我的机器里面的GCC版本已经比较新了的原因。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;python3 test.py  
real	0m2.194s
user	0m2.117s
sys	    0m0.004s

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./test
real	0m3.179s
user	0m3.152s
sys	    0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一反应当然会质疑这个结果，但是计算机又不会撒谎，所以一定是代码实现的问题，要么是标准库的regex实现有问题，要么是代码写的有问题？&lt;/p&gt;

&lt;h2 id=&quot;优化掉无意义的临时对象构造和析构&quot;&gt;优化掉无意义的临时对象构造和析构&lt;/h2&gt;
&lt;p&gt;显然这里有一个&lt;strong&gt;无意义的临时string/vector对象的构造和析构&lt;/strong&gt;，这些过程都会伴随着内存的分配和释放，而Python版本由于其内在的string优化压根就没有这些开销。&lt;/p&gt;

&lt;p&gt;去掉这个构造并尽力复用对象而不改变程序的语义后，代码会成为这样&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过将需要使用的字符串和vector挪到循环的外部，运行之后，性能提高了一倍多！稍微麻烦一点的时候，内部的代码因为需要清理容器的内容而变得不太干净了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;real    0m1.254s
user    0m1.238s
sys     0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原答题者的版本里，他的结果还是比Python版本要慢，而我本地机器的运行结果已经超出了python版本不少了！一个自然而然的想法是我们释放可以做的更好？&lt;/p&gt;

&lt;h2 id=&quot;彻底去掉源字符串的内存分配和释放&quot;&gt;彻底去掉源字符串的内存分配和释放&lt;/h2&gt;

&lt;p&gt;注意到这里的第一个参数每次都是同一个，我们根本就不需要将一个&lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt;在传递参数的时候构造出来一个新的string对象，直接传递这个指针就可以，代码几乎不需要改动&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不幸的是这样做的结果并不比前一个版本的更快，显然这里的无效字符串已经被编译器给优化掉了。&lt;/p&gt;

&lt;h2 id=&quot;使用string_view&quot;&gt;使用string_view&lt;/h2&gt;
&lt;p&gt;由于注意到这里的结果里面并不需要分配新的字符串，如果我们可以使用C++17,标准库里面已经有一个新的速度更快的&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;类，不会引起任何的内存分配和释放。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;版本的代码如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;string_view&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可惜这个版本的性能和&lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt;的前面版本并没有太大的差异。显然性能问题从来就没有想当然而然的部分，必须依照测试情况是实验结果来分析。
另外一个显然的教训是，&lt;strong&gt;内存分配的代价在很多时候比想象的要大很多&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;当然这是一个过分简化了的例子，实际的代码往往比这个要复杂很多，这里的性能结果和结论往往不能适用实际的复杂场景，因为每一个程序的运行环境和执行情况可能都是独一无二的，必须一句实际情况来分析。&lt;/p&gt;

&lt;p&gt;更复杂的情况，这里的计算时间的方法显然也太过原始了；可以借助强大的profile工具，生成perf可以解析的数据，从而进一步生成&lt;a href=&quot;https://github.com/brendangregg/FlameGraphhttps://github.com/brendangregg/FlameGraph&quot;&gt;火焰图&lt;/a&gt;或者直接查看&lt;code class=&quot;highlighter-rouge&quot;&gt;perf report&lt;/code&gt;的命令行界面来分析性能的热点在哪里。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="engineering" /><category term="performance" /><category term="cpp" /><category term="python" /><category term="regex" /><summary type="html">C++17 推出已经有将近3年的时间，速度快一些的公司才慢慢采纳了6年前的C++14进入正式的生产环境。 程序员们的一个大福利就是终于不用外挂第三方库（无论是准标准的boost还是其它形形色色的其它第三方库）就可以直接方便地使用标准库自带的&amp;lt;regex&amp;gt;来写代码； 这显然比直接使用原始而笨拙的string::find_first_of外加一堆边界检查和判断要轻松和干净很多。</summary></entry><entry><title type="html">实现领域驱动设计</title><link href="https://skyscribe.github.io/post/2019/02/23/domain-driven-development-impl/" rel="alternate" type="text/html" title="实现领域驱动设计" /><published>2019-02-23T00:00:00+08:00</published><updated>2019-02-23T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/02/23/domain-driven-development-impl</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/02/23/domain-driven-development-impl/">&lt;p&gt;领域驱动设计在最近几年里越来越多地走进了主流架构设计的中心舞台上来了，这一切其实似乎是在业界精神领袖Martin Folwer在
他的《企业软件架构模式》一书和各种各样的讨论中的推荐之下之后忽然就火了起来。
甚至有一种说法是：&lt;strong&gt;如果学完了设计模式之后感觉没有什么用武之地，那么你需要去好好看一下Eric Evans写的《领域驱动设计》一书&lt;/strong&gt;以吸收新的灵感，
然后才能知道你工作中的面性对象设计用错在了什么地方。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;和领域驱动设计的接触史&quot;&gt;和领域驱动设计的接触史&lt;/h2&gt;
&lt;p&gt;领域驱动设计对我而言并不是一个很新鲜的名词，因为在我看来&lt;strong&gt;它讨论的还是面向对象的设计思想和基本的设计模式应用&lt;/strong&gt;；
只不过是它将这些思想直接地应用到了软件所要解决的问题域中去了而已。
只是我对它的理解还是经历了一个很长的曲折过程。直接用中文的“领域驱动设计”一词来描述无疑会使行文变得累赘不少，后面就暂且不时偷懒地用DDD来指代它。&lt;/p&gt;

&lt;h3 id=&quot;职业生涯最早期的擦肩而过&quot;&gt;职业生涯最早期的擦肩而过&lt;/h3&gt;
&lt;p&gt;我第一次和领域驱动设计的思想擦肩而过的日子应该是在十多年前，那时候我还是一个刚刚离开校门不就的青涩的初级程序员；
自恃学了一些面向对象的设计方法，然后在TopLanguage社区上读到了一些大神推荐Martin Fowler的网站的文章。因为恰好在外企里面工作，英语还算可以，
就仔细读了Martin博客上的几篇文章，恰好看到了关于领域驱动设计的讨论。&lt;/p&gt;

&lt;p&gt;由于自己的工作经验实在是浅薄的可怜，眼界是是出奇的狭窄，&lt;strong&gt;可惜自己还不自知，对于软件工程中的领域知识复杂性实在了解的有限&lt;/strong&gt;。
这个时候有公司高级设计师在刚刚火起来的微博上讨论领域驱动设计和领域特定语言，我看到这样新鲜的名词居然没有听说过，马上找来了Martin的书读了一遍。
可惜实在是所知有限，并没有很深入的理解进去；得到的只是一些非常皮毛的概念。&lt;/p&gt;

&lt;h3 id=&quot;二次接触&quot;&gt;二次接触&lt;/h3&gt;

&lt;p&gt;大概三四年前，在做了长时间的软件工程师、高级工程师并尝试了其它团队Leader和项目管理的角色之后，我做出了深入技术领域的决定，成为了一名初级的软件架构师。
出于自己爱读书的习惯，我又重新翻起了那本被认为是划时代设计思想巨著的《领域驱动设计》一书。这一次因为有了之前的工作经验，
作者所谈的一些技术痛点读起来就变得显而易见，虽然Eric Evans所经历的行业我没有直接的感受，其中所谈的困境和作者想解决的问题却深深地引起了我的共鸣。&lt;/p&gt;

&lt;p&gt;这个时候我心里最深切的想法是：再来深入体会和理解领域驱动设计其实应该是水到渠成的事情。
可惜这一次我又错了，尽管我专门集中了最好的碎片时间尽量大块儿地阅读这本巨著；&lt;strong&gt;最终因为自己操作的机会毕竟有限&lt;/strong&gt;，
很多方面的认识还是知其然而不知其所以然。&lt;/p&gt;

&lt;p&gt;作者提到的关于Unbiqutous Language的概念和其它形形色色的概念，其实还是不免流于理论形式；虽然对从数学专业毕业的我而言，理解起这些理论来并不觉得吃力。
这个时候我正在做架构师的工作，平时也亲自主持设计一些关键系统模块的高层设计和抽象思考，并有大量的时间去评审别的高级工程师设计出来的模型。&lt;/p&gt;

&lt;p&gt;有意无意地我会讲Eric里面讲述的思想引入到我们日常的工作中，并努力身先示范并尽力去影响大家来推进这些思想的引用。
这个时候的项目用的Java环境，而Spring本身到这个时候已经支持了不少DDD自身的一些逻辑注解；里面的文档都会给你一句简单的介绍说这个Service的概念来自于Eric Evans等。&lt;/p&gt;

&lt;p&gt;很多时候我觉得自己明明很认真地告诉大家使用这些想法会得到怎样的好处，其它的同事也会对这些想法表示赞同，然而&lt;strong&gt;真正具体实施的时候，
别人还是会觉得这些做法很费劲儿&lt;/strong&gt;，真正做出来的软件还是不自然地陷入到了“大泥球”之中，其实这些努力并不能算得上是成功。
具体的原因当时的自己其实并没有理解的很深刻。&lt;/p&gt;

&lt;h3 id=&quot;第三次亲密接触&quot;&gt;第三次亲密接触&lt;/h3&gt;

&lt;p&gt;时光飞速地从身边流过，四年过去我已经从当初迷茫而不自知的初级架构师成长成为了一个积累了更多的经验又更加惶恐地认识到自己不足的一个中高级架构师。
当时的迷茫和手足无措其实很大部分来自于自己知识积累上的不足和实际工作经历的欠缺；毕竟当时转过来重新深入钻研技术有一些其它方面的原因，并不是完全的水到渠成。&lt;/p&gt;

&lt;p&gt;还好我尚能做到知不足而奋进；几年的时间我尽量用自己身边可用的渠道弥补自己之前相关知识上的欠缺。这些弥补的方式主要还是读书和思考，
某种程度上来说，读书可以算作是我个人的比较优势，我的动手能力也还算可以，但是比较起来我还是更擅长于读书。&lt;/p&gt;

&lt;p&gt;优秀的描述架构和设计的图书其实并没有许多；因为关于软件设计和架构的方法学和思想也就那么一些花样；其它一些具体的技术和框架是不断有花样出来，
底层的这些本质的东西并没有发生太大的变化。商业软件的复杂性很多时候并不在于这些具体的软件基础技术；当然脱离这些基础技术的话，很多时候并不可能做出有使用价值的软件来。&lt;/p&gt;

&lt;p&gt;基于这些其它方面技术的积累，我又一次对领域驱动设计发生了兴趣，于是就顺手来啃一下另外一本这个领域赫赫有名的《实现领域驱动设计》。
简单翻了一下目录就不禁感叹：这不就是为现在我的知识和认知水平储备的吗？有广度又有深度，没有过多地重复一些其它的理论只是，
却又不简单地堆砌代码；连书中的文字和插画风格也和Bob大叔的很相像，每一个部分都有一个关于牛仔的漫画和对白，可惜我对美国的牛仔文化并不是很熟悉。&lt;/p&gt;

&lt;h2 id=&quot;简单的为什么和怎么做&quot;&gt;简单的为什么和怎么做&lt;/h2&gt;

&lt;p&gt;对于任何一个稍微复杂一点的实体来说，想清楚这两个问题都会有不小的挑战。是否采用DDD方法，为什么要采用DDD以及怎样很好地时间DDD也是这样的复杂问题。&lt;/p&gt;

&lt;h3 id=&quot;为什么需要ddd&quot;&gt;为什么需要DDD&lt;/h3&gt;
&lt;p&gt;为什么的问题其实取决于我们需要解决的问题域的复杂性，如果是非常简单的系统，用数十行的脚本或者SQL查询语言就可以完成的事情，断然是用不到DDD这么高级的抽象系统的，
因为那样做不产生太多实际的价值，可能还会折进去不少的精力损耗而得不偿失。&lt;/p&gt;

&lt;p&gt;DDD本身希望解决的是复杂的业务领域，这些业务领域在需要用软件来表述和实现的时候，需要多个团队成员的协作来完成需求讨论、设计、开发、测试已经维护才能实现商业目标。
这种情况下，使用DDD可以极大地简化业务领域的复杂性；用更小的成本实现更大的商业价值。&lt;/p&gt;

&lt;h3 id=&quot;最简单的怎么做&quot;&gt;最简单的怎么做&lt;/h3&gt;

&lt;p&gt;DDD的核心思想可以认为是两个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无处不在的领域业务语言即Ubiquitous Language，这是DDD最为强大的一个工具之一&lt;/li&gt;
  &lt;li&gt;绑定的领域上下文即Bounded Context&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两者的关系是互相依存的，&lt;strong&gt;没有清晰的领域业务语言，就没有办法识别清楚&lt;/strong&gt;特定的绑定上下文；
同样没有清晰的领域上下文，那么领域业务语言就会变得模糊不清出而失去威力。&lt;/p&gt;

&lt;h3 id=&quot;ubiquitous-language&quot;&gt;Ubiquitous Language&lt;/h3&gt;
&lt;p&gt;这是一门特殊的团队使用的通用开发语言，需要由&lt;strong&gt;领域知识专家（系统分析和需求知识专家）和开发技术专家（程序员）共同来开发和维系&lt;/strong&gt;。
只有如此，两者才能共享相同的知识；通常情况下，该语言可能由领域专家先根据领域知识和需求来创建，然后该语言需要保持演进，以便领域知识专家和开发技术专家互相学习，
共同产生目标软件模块甚至系统。&lt;/p&gt;

&lt;p&gt;它是一种团队内部用来捕捉核心业务逻辑概念和内部领域软件模型的工具。它的作用范围需要限制在一个绑定的上下文中，
从而有可能出现同一个实体在不同的绑定上下文中会有不同的语言名称，这个并没有什么问题。
一个特定的Ubiquitous Language总是为特定的绑定上下文所服务的。&lt;/p&gt;

&lt;p&gt;这种语言是领域专家和程序员之间的桥梁：通过共享相同的领域语言，知识专家和程序员共同写作，完成最终的软件产品；
这种知识和技能上的互补是DDD方法的一个内生的优势。
当然如果组织的沟通和行政结构不匹配的话，这也可能成为实现DDD的一个阻碍因素。&lt;/p&gt;

&lt;h4 id=&quot;挑战和陷阱&quot;&gt;挑战和陷阱&lt;/h4&gt;

&lt;p&gt;这里有一个巨大的挑战在：&lt;strong&gt;开发组织是否有足够的时间和投入来保证领域知识专家能够坐下来和开发人员一起讨论和发现&lt;/strong&gt;这些无处不在的通用领域语言，
识别其中的抽象模型和核心业务价值的关系，不断地提炼领域通用语言。
同样的开发人员或者程序员也要被不断地鼓励用该通用的语言和领域专家进行沟通，确保相互的理解和语言的演进，而不是一头扎进代码的细节中实现偏离了该共同语言的最终产品。&lt;/p&gt;

&lt;p&gt;很多年以来，软件开发行业都有些过于追逐炫目的底层技术细节了（当然不是说这些不重要），而DDD的思想需要我们适当地变得少一点技术化，多讨论一些业务语言。
因为领域问题的复杂性才是大部分商业软件复杂性的主要来源；新的技术和工具可以解决一些痛点，但是很多时候它们不应该是软件的核心价值所在。&lt;/p&gt;

&lt;h3 id=&quot;领域粒度切分和绑定上下文&quot;&gt;领域粒度切分和绑定上下文&lt;/h3&gt;

&lt;p&gt;很多时候我们面对的领域问题非常复杂，然而开发人员往往禁不起诱惑而希望将所有的问题都放在一个领域中来解决，
这样的副作用就是理解和沟通起来相当困难，出现问题也非常难以排查，从而使得系统维护和演进的成本变得日渐高昂甚至最终会被废弃而完全失去价值。&lt;/p&gt;

&lt;p&gt;解决这一问题的办法是需要将问题领域切分为多个子领域，并确切地区分子领域和核心领域。
&lt;strong&gt;核心领域关系到业务成功因此需要配备最好的领域知识专家和最好的开发人员&lt;/strong&gt;，从而使他们形成适合于他们的统一语言，保证即使其它领域不成功，核心的商业价值也可以得以保全。
而非核心领域则是一些支持性的领域，这些领域中有些可能可以被多个其它领域所使用，这样的领域就是一些通用的子领域。&lt;/p&gt;

&lt;p&gt;通过讲问题领域分割为多个子领域，复杂的问题得以简化；通过聚焦于核心领域，核心的商业价值得以最大化。
每一个子领域和围绕它形成的领域专家和技术专家共同产生和维护的统一语言构成了特定的绑定上下文。&lt;/p&gt;

&lt;h4 id=&quot;领域边界&quot;&gt;领域边界&lt;/h4&gt;

&lt;p&gt;划分好的子领域形成了自然的领域边界；因此&lt;strong&gt;绑定上下其实是用领域统一语言的边界来分隔&lt;/strong&gt;的。
不同的绑定上下文自然就不能共享统一的业务语言了，因为这个&lt;strong&gt;边界其实是个语言边界&lt;/strong&gt;；这也是前边一直强调的通用领域语言的重要性所在了。
这也意味着&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;没有必要也&lt;strong&gt;没有可能在不同的子领域之间统一术语和上下文&lt;/strong&gt;，这个是由绑定上下文的本质决定的；不同的领域自然有不同的绑定上下文和自己的领域术语&lt;/li&gt;
  &lt;li&gt;开发人员和领域专家需要认识到并且拥抱不同子领域的模型和概念不需要一致的现实&lt;/li&gt;
  &lt;li&gt;跨越领域来分享概念和名词容易带来混淆和混乱，尽力不这么做&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;领域不是组件模块等纯软件概念&quot;&gt;领域不是组件、模块等纯软件概念&lt;/h4&gt;

&lt;p&gt;领域模型是基于领域专家和技术专家的共同语言而存在和得以维系的；因此我们不能草率地将传统的纯软件架构技术和领域概念混为一谈。
一个子领域并不是一个组件，或者一个模块，或者应用服务实例等纯软件组织概念。
领域驱动设计要求我们总是在大脑里记清楚两者不是一回事儿；我们的&lt;strong&gt;模型总是柔和了业务领域知识和软件抽象技术的一个综合体&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;绑定上下文的粒度和大小&quot;&gt;绑定上下文的粒度和大小&lt;/h3&gt;

&lt;p&gt;绑定上下文的&lt;strong&gt;粒度取决于所采用的领域统一语言所表述的概念边界&lt;/strong&gt;；最理想的情况是两者刚好能够完全匹配；但是没有匹配的话，还可以不断的修正它，
这也正是敏捷软件开发思想的应用，不是什么太大的问题。&lt;/p&gt;

&lt;p&gt;一个绑定上下文中所使用的其它的DDD设施，包括Entity，Aggregates，Events，Service等，
应该是恰到好处地匹配DDD的需要，是“增之一分则太肥，减之一分则太瘦”的恰到好处。尤其是核心领域对应的绑定上下文，
更要努力做到如此；自然这需要上面所说的最好的资源支持才可以做的到。&lt;/p&gt;

&lt;p&gt;DDD的思想还要求我们界定绑定上下文的边界的时候，&lt;strong&gt;必须避免软件架构技术产生决定性的影响&lt;/strong&gt;；
因为这一方法的指导性原则是，需要倾听和修正领域模型和语言边界，而不是软件架构实现技术的边界。
有时候可以用具体承载领域的软件架构技术来指代领域，只要领域边界的界定不是根据这些架构技术得来的就行。&lt;/p&gt;

&lt;h2 id=&quot;上下文映射&quot;&gt;上下文映射&lt;/h2&gt;

&lt;p&gt;处于上述绑定上下文粒度和领域通用语言的考虑，复杂一点的领域设计系统中总会有多个不同的子领域；描述问题的解决方案的时候，我们需要考虑不同子领域之间的映射关系；
而这正式上下文映射所要解决的问题。如果将多个绑定上下文描述在一张图中，他们之间的相互关系就是上下文映射。&lt;/p&gt;

&lt;p&gt;上下文映射不光给我们提供了一个关于整个系统的高层视图，还架起了一座帮助我们在多个绑定上下文（子领域）之间沟通的桥梁。
这一点之所以重要，是因为&lt;strong&gt;不同的子领域可能使用完全不同的”通用领域语言”&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;如何描述上下文映射&quot;&gt;如何描述上下文映射&lt;/h3&gt;

&lt;p&gt;一般情况下，上下文映射描述的是现在所理解的领域边界和这些相关子领域的相互关系；实际操作的时候我们需要保持敏捷而不是考虑过多想象的未来图景。
大部分情况下，基本的领域框架和寥寥数笔领域关系就足够使用；如果需要描绘更多的细节信息，
可以采用DDD中的其它诸如Aggregates、modules方法来细化这些关系；
只是大部分情况下这样做并无必要。&lt;/p&gt;

&lt;p&gt;需要留意的是&lt;strong&gt;上下文映射并不是企业软件架构或者系统拓扑结构&lt;/strong&gt;；它不是特别为这方面的意图所准备的。
它的主要作用是帮助各个领域团队开发的时候作为沟通和交流的参照；在有必要的时候，它依然可以部分地用在这些场景，凸显系统集成的瓶颈所在；只是不要本末倒置就可以。&lt;/p&gt;

&lt;p&gt;大部分情况下，上下文映射可以用白板的形式放置在领域开发团队的办公区域，使得参与其中的开发和业务人员随时可以看到它们。
其它的方式可以根据实际团队的沟通习惯来实施，比如放在大家经常访问的Wiki中；不过如果这个Wiki长久没有人访问，还是不要浪费力气的好。&lt;/p&gt;

&lt;h3 id=&quot;上下文映射关系&quot;&gt;上下文映射关系&lt;/h3&gt;
&lt;p&gt;实际描述多个绑定上下文之间的相互关系的时候，可以采用如下几种Evans所定义的集成模式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;伙伴式关系：两个领域之间是通过紧密写作来完成各自的领域职责；一荣俱荣一损俱损的关系，两者之间有直接而深入的耦合关系。相互关联的功能必须要通过两个团队之间的紧密合作才可能开发和集成成功。&lt;/li&gt;
  &lt;li&gt;共享内核：两个领域之间共享一些基本的公用模型或者核心设施、代码等；从而两个领域的设计可以得到极大的简化；如果存在共享内核，需要尽力使得共享内核足够的小和简单。&lt;/li&gt;
  &lt;li&gt;上下游关系：上游领域的改动无需通知下游，而下游的成功非常依赖于上游提供的服务。&lt;/li&gt;
  &lt;li&gt;反破坏层：当上游领域和下游领域团队之间的&lt;strong&gt;沟通异常困难，或者下游非常难以协调上游的资源支持&lt;/strong&gt;的时候，下游领域团队往往会需要选择构建一个针对上游领域的反破坏层；这在大公司里面非常常见。&lt;/li&gt;
  &lt;li&gt;开放宿主服务：一个领域通过想其它领域提供&lt;strong&gt;一个开放协议的方式&lt;/strong&gt;提供支持；新的领域如果需要和它继承，需要根据已有的协议添加适配即可。很多时候，下游的领域会将这个开发协议的提供方看做是一个难以可靠协调的上游，
并且构建反破坏层来维护自身的稳定性。&lt;/li&gt;
  &lt;li&gt;已发布的公用语言：两个领域之间可以通过共享一部分领域通用语言的方式来沟通和交互。&lt;/li&gt;
  &lt;li&gt;大泥球：大泥球现象在一些上了历史的老项目中非常场景，当需要和这些遗留领域打交道的时候，我们&lt;strong&gt;需要格外小心构建隔离边界，防止大泥球问题的蔓延&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;软件架构&quot;&gt;软件架构&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DDD方法强调它并不需要和某一种架构风格相互绑定&lt;/strong&gt;，也不依赖于某些特定的软件架构方法，甚至于可以和风险驱动的软件架构方法相处融洽。
不同的软件架构技术和方法有不同的适用场景，而&lt;strong&gt;DDD方法则力图和这些架构方法和谐共存&lt;/strong&gt;，不管是经典的封层架构，
还是稍微现代一点的形形色色的架构风格和方法，DDD都可以根据需要来适用他们解决领域内的问题。&lt;/p&gt;

&lt;h3 id=&quot;分层架构和依赖导致原则&quot;&gt;分层架构和依赖导致原则&lt;/h3&gt;

&lt;p&gt;传统的封层架构按照层次组织软件系统，严格的分层架构仅仅允许高层的组件依赖于低层的组件，并且不允许跨越层次调用依赖；而松散一点的分层架构则允许跨越一些中间层次来调用底层的组件；
当然两者都允许底层的组件调用高层；并且需要确保分层架构中没有环产生，以免有难缠的系统依赖问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;依赖倒置原则其实从某种程度上来看打破了传统的分层架构的严谨性&lt;/strong&gt;，但是同时又允许更大的灵活性，因为组织依赖上都要求大家尽量依赖于抽象而不是依赖于具体的实现；
甚至可以认为层次的概念呗弱化的同时，软件的灵活性还得到了保证。&lt;/p&gt;

&lt;h3 id=&quot;端口和适配器架构&quot;&gt;端口和适配器架构&lt;/h3&gt;

&lt;p&gt;这一架构风格原来也被称为是六边形架构；或者另外一个所谓的洋葱架构指向的也是这种风格。任何时候一个组件想要和另外一个组件交互的时候，只需要做这两件事情&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;拿到对方的端口&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;准备一个新的适配器组件，将自己的内部逻辑翻译为对外部端口的调用&lt;/strong&gt;即可&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今天的很多封层架构其实都是端口和适配器架构，尤其是很多基于依赖注入设施的项目更是如此；即使是他们称呼自己为分层架构。
这一架构的巨大好处是，即使外部模块或者组件没有就绪，我们也可以根据端口和适配器很方便地构建测试用例来验证用户场景。&lt;/p&gt;

&lt;h3 id=&quot;基于服务的架构&quot;&gt;基于服务的架构&lt;/h3&gt;

&lt;p&gt;基于服务的架构包括传统的SOA架构和新兴的微服务架构，他们的侧重点和针对服务切分的颗粒度乃至服务治理方式有形形色色的差异，好在从DDD方法认为这种架构风格并没有破坏领域的完整性。
相反我们可以根据DDD的方法让一个服务描述一个对应的绑定上下文，在这个服务内部，所有的代码共享同一个通用的领域语言。&lt;/p&gt;

&lt;h3 id=&quot;rest和ddd&quot;&gt;REST和DDD&lt;/h3&gt;
&lt;p&gt;当今微服务大热的背景下，REST多多少少已经被很多场景滥用了，甚至可以说&lt;strong&gt;不该用而滥用的场景比应该使用而没有使用的情况要多&lt;/strong&gt;。
作为服务的提供方来说，REST端口提供的是&lt;strong&gt;对于资源的抽象和操纵接口&lt;/strong&gt;，它是随着HTTP协议的兴起而变得无处不在的，其核心仍然是围绕着关于服务器资源的访问展开的；只不过这些资源的抽象本身一直在不断地扩大。
对使用REST的客户端而言，它提供的是关于资源访问的URI和一系列资源操作的方法。&lt;/p&gt;

&lt;p&gt;理想情况下，REST服务提供方需要&lt;strong&gt;按照超媒体的组织方式提供基于HATEOS风格的可发现式的API&lt;/strong&gt;，将客户端的访问从具体而又死板的URI信息中解耦；
而客户端可以从一个简单的URI开始，根据实际的资源访问情况，步步深入访问其它需要的资源完成业务场景。&lt;/p&gt;

&lt;p&gt;从DDD的角度考虑，一般不建议采用直接用REST API来暴露领域模型的做法，而是&lt;strong&gt;要尽量采用适度的隔离措施&lt;/strong&gt;，使得核心的领域模型不至于变得过度脆弱。有两种办法可以达到该目的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一种是专门创建一个用于提供REST表示接口的子领域，让该子领域访问核心的领域。&lt;/li&gt;
  &lt;li&gt;另外一种做法是将注意力放置在媒体类型上，用一类媒体类型表述一系列的领域交互模型资源；这种做法其实是上述的共享内核或者已发布公共语言的继承方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cqrs&quot;&gt;CQRS&lt;/h3&gt;
&lt;p&gt;CQRS即命令和查询职责分离的简称；这一做法要求我们任何一个方法要么负责查询，要么负责执行命令修改状态；但是永远不要将两者混合在一起。
依据这种做法，&lt;strong&gt;传统的领域模型就不得不分为两个部分：一个子模型负责查询，另外一个则负责执行命令&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这样的做法虽然会带来意外耦合的问题，却有一些额外的好处，尤其是系统需要有不同的扩展性要求和查询、修改性能指标；将两者分离的做法很容易轻松地应对这些传统方法难以处理的难题。
往往采用CQRS技术的系统需要&lt;strong&gt;仔细考虑和应对最终一致性&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;h3 id=&quot;事件驱动架构&quot;&gt;事件驱动架构&lt;/h3&gt;
&lt;p&gt;事件驱动的架构方法鼓励使用各种事件产生、发送、检测、消费以及对时间做出反应来组织软件系统。DDD系统内部可能有来自内部、外部的多种不同的事件；我们&lt;strong&gt;用领域事件的做法来融合DDD和事件驱动&lt;/strong&gt;架构。
通过使用领域事件来传递领域模型需要关注的关键信息，各个领域模型可以采用事件驱动架构的各种方法来监控、检测、过滤、合并领域时间，或者对领域事件做出反应，完成复杂的用户场景。&lt;/p&gt;

&lt;h4 id=&quot;event-sagas&quot;&gt;Event Sagas&lt;/h4&gt;
&lt;p&gt;Event Sagas用于描述&lt;strong&gt;长期运行、持续不断的事件处理过程&lt;/strong&gt;；有如下三种常见的办法来描述长期运行的长时间处理过程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将处理过程作为一个组合任务过程，用一个可以持久化的对象来记录任务执行时间、完成度信息&lt;/li&gt;
  &lt;li&gt;将处理过程表述为收集各种活动交互的聚合的集合；其中一个或者多个维护整体的执行和状态信息&lt;/li&gt;
  &lt;li&gt;处理过程本身设计为无状态的，但是每个处理时间的任务在处理完毕之后都增加更多信息到输出事件上，从而把进度、完成情况等信息递增地包含在事件中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Event Sagas的方式要求我们&lt;strong&gt;必须拥抱最终一致性模型，并且妥善处理好超时和重试处理&lt;/strong&gt;，尽量补偿可能出现的异常情况，甚至在情况复杂的时候尽量引入工作流来降低领域问题的复杂性。&lt;/p&gt;

&lt;h4 id=&quot;event-sourcing&quot;&gt;Event Sourcing&lt;/h4&gt;
&lt;p&gt;一般情况下使用Event Sagas就可以追踪和记录系统中发生的事件，只是在某些业务场景下我们想更进一步地追踪每一个时刻系统发生的所有事件，而不仅仅是某个实体最后一次被修改后的状态和时间戳。
Event Sourcing技术通过&lt;strong&gt;记录实体上所发生的所有事件信息，并将其放置在单独的存储实体上&lt;/strong&gt;来满足这一需求，
用户甚至可以通过简单的提供实体的唯一标识来查询和定位具体的事件，甚至还原某一个时刻领域实体的状态。&lt;/p&gt;

&lt;p&gt;这样的做法在很多时候可以&lt;strong&gt;提供足够灵活性的同时，满足极大的性能和扩展性需求&lt;/strong&gt;。这一方法能工作的前提是依赖于上述提过的最终一致性行为。
同时使用Event Sourcing技术构建的系统往往是满足CQRS的要求或者可以认为是在CQRS基础上的进一步定制。&lt;/p&gt;

&lt;h2 id=&quot;领域实体&quot;&gt;领域实体&lt;/h2&gt;

&lt;p&gt;开发人员一种常见的错误倾向就是过分地关注主题的数据模型，这也许于我们过多地关注于数据库技术有关。
然而&lt;strong&gt;领域驱动开发的核心是关于领域的行为和特征，而不是数据的获取和读取&lt;/strong&gt;。
之所以要用领域实体的概念来封装业务特征，而不是直接在数据集的基础上采用CRUD来直接实现业务规则，主要是因为系统的业务复杂度不断提高的时候，直接CRUD的方式带来了软件复杂度的急剧上升。&lt;/p&gt;

&lt;p&gt;领域实体和另外一个DDD术语Value Object有很多方面比较接近；两者的一个最显著的区别是：
领域实体具有一个唯一的标识符，它可以区分不同的领域实体，而值对象可以直接复制并且复制的对象和原来的对象完全表述同样的领域抽象信息。&lt;/p&gt;

&lt;h3 id=&quot;领域实体标识符&quot;&gt;领域实体标识符&lt;/h3&gt;

&lt;p&gt;领域实体标识符的一个最重要的要求就是&lt;strong&gt;需要保证在具体的领域内是唯一的，并且这个唯一性不受时间的改变而改变&lt;/strong&gt; - 即使程序退出重启了，如果这些信息被持久化保存，重新加载的时候这个唯一性仍然需要保留；
否则就会带来很严重的不一致问题。&lt;/p&gt;

&lt;p&gt;有很多技术手段来产生唯一的领域实体标识符，这些方法实现有简有繁，并且每一种都有它们自己的优点和不足。&lt;/p&gt;

&lt;h4 id=&quot;用户保证的唯一性&quot;&gt;用户保证的唯一性&lt;/h4&gt;
&lt;p&gt;一种最简单的思路是，让用户提供输入来保证领域实体的唯一性；这种方法简单直接并且在很多场景下是一种不错的解决方案。
这样的做法有一个显而易见的不足就是扩展性和性能可能不高；甚至需要考虑好用户可能输入非法的标识符的情况，
如果这是可能发生的，设计一个&lt;strong&gt;健壮的校验系统或者工作流验证系统&lt;/strong&gt;也是有意义的。&lt;/p&gt;

&lt;h4 id=&quot;应用程序自动产生&quot;&gt;应用程序自动产生&lt;/h4&gt;

&lt;p&gt;有很多技术手段可以让应用程序在需要的时候自动产生一个唯一的实体标识符，比如常见的UUID、GUID技术可以保证产生一个在绝大多数情况下都不会重复的唯一标识符。
&lt;strong&gt;这些技术方法也有一些明显的陷阱&lt;/strong&gt;需要我们选择的时候留意&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;分布式节点的ID产生可能需要防止意外的ID碰撞，这个和选择使用的算法参数密切相关。&lt;/li&gt;
  &lt;li&gt;直接用String对象来表述这些ID可能不是一个好主意，最好是用一个值对象来表示它，尤其是这样的ID里面包含了其它比如机器地址等信息的时候。&lt;/li&gt;
  &lt;li&gt;如果有些领域对象需要知道这些基于随机数算法产生的标识符，会有额外的挑战需要我们应对。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用数据库系统产生的标识符&quot;&gt;使用数据库系统产生的标识符&lt;/h4&gt;

&lt;p&gt;直接使用数据库系统来产生标识符有一个额外的好处是我们不需要考虑它的唯一性，&lt;strong&gt;存储系统自己封装了如何保证唯一性的重要细节&lt;/strong&gt;我们直接拿来使用就好了。
常见的关系数据库系统比如Oracle、MySQL都提供了这样的设施；其不足之处是性能可能不能我们的需要；这一点尤其在大型分布式系统中格外明显。&lt;/p&gt;

&lt;h4 id=&quot;请求另外一个绑定上下文来提供标识符&quot;&gt;请求另外一个绑定上下文来提供标识符&lt;/h4&gt;

&lt;p&gt;这种方式的思想也很直接，需要唯一标识符的时候，请求上游的绑定上下文（领域）要求对方分配一个标识符。
这样做的一个天然的问题是，如果上游的绑定上下文发生了变化该如何处理？我们可以使用事件驱动架构的办法，监控上游领域的领域事件，然后根据变化做出响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这也是一种最复杂的策略，因为领域内的实体不仅仅依赖于领域边界上的适配器翻译，还依赖于外部绑定上下文的领域事件更新&lt;/strong&gt;。
因而在大部分情况下，我们必须谨慎选择采用该策略来决定领域实体的标识符。&lt;/p&gt;

&lt;h4 id=&quot;何时产生实体标识符&quot;&gt;何时产生实体标识符&lt;/h4&gt;

&lt;p&gt;一般来说我们有两种时机来决定领域实体的唯一标识符：一种是在领域实体对象被创建的时候，自动分配一个标识符；另外一种策略则是只有当实际需要讲实体放置在一个Repsoitory中的时候，才实际分配标识符。&lt;/p&gt;

&lt;p&gt;第二种方法有一个显然的好处是，在&lt;strong&gt;实际放入Repostory之前我们依然可以像操作值对象一样操作这个领域实体&lt;/strong&gt;。
潜在的问题是，如果系统架构风格是事件驱动的，那么实体对象被创建的时候，所发布的领域事件的实体标识符就无法拿到了。
要处理这个问题，我们要么只能回到第一种方式做预先分配，要么我们在比较对象的时候，采用基于属性比较的方式而不是比较领域实体标识符。&lt;/p&gt;

&lt;p&gt;当然第一种方式的情况下，我们实现对象的比较或者取hash的时候，可以直接用领域实体而无须关心其它的内部属性值。&lt;/p&gt;

&lt;h4 id=&quot;多套标识符的协调和映射&quot;&gt;多套标识符的协调和映射&lt;/h4&gt;

&lt;p&gt;如果我们采用存储系统提供的标识符，这些标识符可能和我们自己设计的领域实体的标识符中间产生不协调；比如ORM系统产生的标识符是一个数字串而领域模型需要提供另外一种表示方法。
这种情况下，一般的做法是&lt;strong&gt;隐藏这些实际来自于其它地方的标识符，而仅仅对外暴露领域模型抽象出来的实体&lt;/strong&gt;标识符。
这种情况下，如果需要讲标识符当做数据的键来使用，那么也不需要使用领域模型抽象的实体标识符。&lt;/p&gt;

&lt;h4 id=&quot;实体标识符的稳定性&quot;&gt;实体标识符的稳定性&lt;/h4&gt;

&lt;p&gt;大部分情况下出于标识符稳定性的要求，我们选择&lt;strong&gt;将标识符设计为不可变的，即在创建或者分配的时候可以设置一次，
而一旦创建就不允许修改&lt;/strong&gt;了。这种设计策略和标识符合适创建没有直接关系。
如果领域内部需要做标识符的修改，需要务必小心做好封装和信息隐藏，隔离对其它绑定上下文的影响。&lt;/p&gt;

&lt;h3 id=&quot;挖掘实体的角色和职责&quot;&gt;挖掘实体的角色和职责&lt;/h3&gt;

&lt;p&gt;角色和职责的挖掘是传统的面性对象设计方法中最困难的部分，也是最有价值的部分。
我们需要使用的底层技术还是一样的，用接口来抽象实体所需要扮演的角色，然后用类来建模实际的领域实体。
不论怎样选择这里的角色抽象，需要始终牢记的是&lt;strong&gt;跨职能团队根据领域业务逻辑而统一的领域语言才是决定这些角色和实体类的职责的最重要的因素&lt;/strong&gt;，
而实际实现这些抽象的面性对象技术应该作为具体实现的支撑细节。&lt;/p&gt;

&lt;h3 id=&quot;领域实体的创建校验&quot;&gt;领域实体的创建、校验&lt;/h3&gt;

&lt;p&gt;从面向对象编程的角度来看，领域实体本身是一个对象，因此需要调用对应的类的构造方法来生成实体对象。
该实体类内部封装的属性之间可能存在一些&lt;strong&gt;非空值之外的一些相互约束关系，这些约束关系称之为Invariant&lt;/strong&gt;，它对应的参数需要在外部构造的时候，把对应的参数传入，并且在类的内部实现上加以隐藏。
负责更新这些单个属性参数的内部操作方法不应该暴露给外部。&lt;/p&gt;

&lt;p&gt;如果构造的过程比较复杂，可以用基于工厂模式的设计方法将实体对象的构造过程封装起来，方便外部用户更简单地生成实体对象；
这一方法本身是设计模式的直接应用，实现起来并不麻烦。&lt;/p&gt;

&lt;p&gt;另一个相关的常见的实体处理约束是关于实体对象的校验 - 其背景是我们往往需要处理多个对象的组合的情况；此时&lt;strong&gt;每一个子对象是合法的并不意味着这些对象的组合也依然是合乎领域实体模型约束&lt;/strong&gt;，因此需要合理的校验和判断。
我们需要的是基于整个对象的校验；需要实现整对象校验的前提是，&lt;strong&gt;每一个子对象（可能是一个实体或者值对象）自身需要满足自身的校验约束&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一种常见的处理方法是使用自封装，即在实体类内部提供多个Accessor方法，并且要求实体类内部的访问也需要使用这些自封装方法。
这种处理方法也是“防御式编程”所推荐的处理方法。与此相反的一种反模式是，期望于用存储系统提供的校验工具来实现实体对象校验，这在某些情况下可能有一些比较大的缺陷；
典型地如在MySQL数据库中，单个行记录最多只能包含65535个字符，如果超出此限制，数据库的校验则无法处理了。
因而重要的是应该更好地关注与关注点分离，这也是计算机科学的基本处理思路。&lt;/p&gt;

&lt;h3 id=&quot;领域实体变更跟踪&quot;&gt;领域实体变更跟踪&lt;/h3&gt;
&lt;p&gt;大部分情况下，领域实体对象的状态变化不需要被特别关注；而当这一&lt;strong&gt;需要的确被领域专家所确认&lt;/strong&gt;的时候，我们可以&lt;strong&gt;用领域事件这一方法来满足，或者使用事件存储&lt;/strong&gt;机制来达成目的。
有时候我们纯粹是出于一些技术上的原因而不是领域专家的意见需要关注领域实体的每一个变更，这种情况下解决之道是使用Event Sourcing方法。&lt;/p&gt;

&lt;h2 id=&quot;值对象&quot;&gt;值对象&lt;/h2&gt;

&lt;p&gt;值对象在很多方面和领域实体对象非常想象，然而两者有一些至关重要的不同。所谓的值对象它所表述的是一些&lt;strong&gt;没有唯一标识的类似纯粹数值&lt;/strong&gt;的概念。
值对象本身在DDD方法中占据重要的位置；我们可能感到惊讶的是，在DDD方法中我们总是应该&lt;strong&gt;力求多使用值对象而不是领域实体对象&lt;/strong&gt;；并且即使我们决定了使用领域实体来描述一些聚合概念，
那么该实体内部如果可以用值对象的集合来表示，就尽量少用子领域实体的集合来表示。&lt;/p&gt;

&lt;h3 id=&quot;值对象的特征&quot;&gt;值对象的特征&lt;/h3&gt;
&lt;p&gt;值对象一般需要满足下面一些特征&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;描述领域中的一种数值，度量或者其它类似的概念&lt;/li&gt;
  &lt;li&gt;可以用不可变对象来表示&lt;/li&gt;
  &lt;li&gt;可以用&lt;strong&gt;等价关系来比较&lt;/strong&gt;另外一个完全不同的对象&lt;/li&gt;
  &lt;li&gt;可以被另外一个对象替换而不影响语义和行为&lt;/li&gt;
  &lt;li&gt;当被其它的协作对象使用的时候，能满足无副作用的行为约束&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不可变性&quot;&gt;不可变性&lt;/h3&gt;
&lt;p&gt;值对象可以表述为一个不可变对象的想法具有重要的简化意义；满足不可变对象意味着，一旦值对象被构造完成之后，
其自身的方法调用并不会改变内部封装的属相值。这种情况下，&lt;strong&gt;如果需要变更，最好的办法是替换产生一个新的对象&lt;/strong&gt;。这样的处理方式和值对象本身的领域语义直接对应，该值对象才能和其它DDD概念更好地协作。
当我们需要对构造好的值对象变更某些属性的时候，需要思考能否用替换的方法来达到同样的效果。&lt;/p&gt;

&lt;h3 id=&quot;整对象概念&quot;&gt;整对象概念&lt;/h3&gt;

&lt;p&gt;值对象需要能表述为一个完整对象的概念，而不是一堆属性之间的无意义拼凑；这些&lt;strong&gt;属性之间应该满足相互之间的高内聚&lt;/strong&gt;；有可能的话则讲没有内聚的属性移除到其它地方。
同时时刻谨记值对象需要和绑定上下文中的领域概念相匹配，值对象本身所表述的概念整体上要能和领域通用语言协调一致；因此用一个基本的原始字符串类型来描述值对象远远不如用一个自定义的类类型来描述对应的领域概念要来的自然。&lt;/p&gt;

&lt;h3 id=&quot;可替换性和等价判断&quot;&gt;可替换性和等价判断&lt;/h3&gt;

&lt;p&gt;我们期望它能够满足不可变性的同时就意味着可替换性是显而易见的；因为当我们需要变更一个值对象的时候，
只需要构造一个新的值对象并返回出去即可。同时可替换性也要求我们能够基于值的语义来判别两个值对象是否相当。
这里的相等依赖于它所封装的内部属性是否都相等，其处理方式和领域实体有着明显的不同&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;领域实体对象的相等比较往往基于其唯一标识即可&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;值对象的想等下判断需要基于各个属性的等价性&lt;/strong&gt;来判别&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;无副作用&quot;&gt;无副作用&lt;/h3&gt;

&lt;p&gt;无副作用本身要求对象的方法调用中不能修改对象自身的内部状态；值对象的无副作用其实是在满足了上面的不可变性和可替换性之后的自然可得的特征，因为除了构造方法除外，任何其它方法都不能违反不可变属性。
如果发现某个值对象的方法必须要修改内部的状态，我们需要停下来挑战一下自己：能否用替换的方法而不是变更内部属性的方法达到同样的目的。&lt;/p&gt;

&lt;h3 id=&quot;实现最小化集成&quot;&gt;实现最小化集成&lt;/h3&gt;

&lt;p&gt;稍微复杂一点的DDD系统中都会有很多个需要被集成在一起的多个绑定上下文；此时使用值对象来完成他们之间的相互集成往往是最简单的：
在下游的绑定上下文中，只需要&lt;strong&gt;用一个值对象来集成上游绑定上下文中传入的对象&lt;/strong&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;将领域标准类型表述为值对象&quot;&gt;将领域标准类型表述为值对象&lt;/h3&gt;

&lt;p&gt;在很多系统中，我们需要处理关于某些信息的有限种的分类信息，比如货币种类、HTTP协议的MIME类型等；这些用于表示事物的类型的信息如果用值对象来描述看起来简单易于理解。
只是在实际实现上，可能用枚举类型来表示会是一个更自然的选择，尤其是如&lt;strong&gt;Java的枚举值类型允许实现抽象和多态行为&lt;/strong&gt;，即允许在枚举类本身中定义抽象行为，
然后在具体的一个一个的值中提供具体实现；这种方法其实是状态模式的一个语言层面的简化实现。&lt;/p&gt;

&lt;p&gt;这些标准类型的值对象定义最好是拿出来放在一个共享的绑定上下文中被多个其它的领域上下文所使用；同时需要计划好对这些标准类型值对象的更新和维护，因为实际上会有多个下游的共享上下文受此影响。
如果系统中的此类定义很多，可以考虑使用代码生成的方法来减小人工维护的负担。&lt;/p&gt;

&lt;h3 id=&quot;持久化值对象&quot;&gt;持久化值对象&lt;/h3&gt;

&lt;p&gt;值对象的持久化有很多种不同的做法，我们可以使用&lt;strong&gt;Repository概念来完成具体的持久化&lt;/strong&gt;。基于值对象的上述特征，
现在&lt;strong&gt;更流行的方法是使用NoSQL数据存储&lt;/strong&gt;来持久化值对象，但是更传统的基于ORM的持久化方法依然是有广泛的使用。&lt;/p&gt;

&lt;p&gt;在基于ORM的方法中，如果值对象的属性中包含有聚合属性，当我们考虑将多个值序列化到一个列中的时候，就必须考虑存储系统的本身的限制。
比如上述的&lt;strong&gt;MySQL最大行宽的限制&lt;/strong&gt;不仅会影响到单个属性列还对整个行记录的可用空间产生直接的约束。
另外一个值得主意的情况是当&lt;strong&gt;将多个对象写入一个数据库列&lt;/strong&gt;的时候，就不能指望使用SQL查询的方法来实现高效检索。&lt;/p&gt;

&lt;h2 id=&quot;服务&quot;&gt;服务&lt;/h2&gt;
&lt;p&gt;DDD中的服务用来描述实现领域特定的任务的&lt;strong&gt;无状态的操作&lt;/strong&gt;的概念，
它和和一般的软件架构理论（比如SOA或者微服务）中所谓的服务或者组件这些粗粒度的软件隔离实体的含义截然不相同，
不能简单地将后者的概念拿来对比，否则会产生更多的混淆和误解。&lt;/p&gt;

&lt;p&gt;DDD服务本身描述的还是一个&lt;strong&gt;和领域相关的概念&lt;/strong&gt;而不是一个抽象的通用的概念。
当我们需要将一大块和实体或者值对象有些关系而又没有状态的职责剥离出来的时候，服务就派上用场了。通常来说我们出于这些目的来决定引入服务&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;业务逻辑操作比较复杂&lt;/li&gt;
  &lt;li&gt;需要将某种领域逻辑的组合从一种形式转换为另外一种&lt;/li&gt;
  &lt;li&gt;需要从多个领域对象的输入中通过某种运算产生出新的值对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;确保仅在必要的时候创建服务&quot;&gt;确保仅在必要的时候创建服务&lt;/h3&gt;

&lt;p&gt;一种常见的使用服务的误区是&lt;strong&gt;滥用了服务的概念导致本该由领域对象或者值对象表达的概念都泄露&lt;/strong&gt;到了服务对象中。
这也是上面提到的&lt;strong&gt;服务需要保证是无状态&lt;/strong&gt;的原因；如果需要保留状态，那么显然使用服务是一种误用。
同时需要谨记的是服务仍然是一种领域知识相关的设施，如果想表述和领域通用语言不相关的概念，那么可能需要用到应用服务。&lt;/p&gt;

&lt;h3 id=&quot;是否需要用分离的接口来描述服务&quot;&gt;是否需要用分离的接口来描述服务&lt;/h3&gt;

&lt;p&gt;是否应该采用一个隔离的接口来描述服务并没有一个清晰的界定，因为它的好处和不足同样明显。
采用分离的接口可以提高软件系统的可测试性，但是只有唯一实现的服务类再加上一个接口定义会显得比较怪异和画蛇添足。&lt;/p&gt;

&lt;h2 id=&quot;领域事件&quot;&gt;领域事件&lt;/h2&gt;

&lt;p&gt;Evans将领域事件描述为领域内发生的一部分完整的事实，它可以用来描述某个时间&lt;strong&gt;绑定上下文中发生的某些事情的表述&lt;/strong&gt;。
如何决定什么是领域事件而什么不是？最好的策略是&lt;strong&gt;倾听领域专家的声音&lt;/strong&gt;，并从中发现这些事件的蛛丝马迹，比如领域专家的口中说出”当xxx发生的时候“或者”如果YYY发生“，这里的XXX和YYY就是清晰的领域事件。
这些时间的出现往往意味着由某些地方需要关注这些事件出现的后果并做出反应。&lt;/p&gt;

&lt;p&gt;使用领域事件的概念往往&lt;strong&gt;默认我们需要采用最终一致性模型&lt;/strong&gt;，这一隐含的假设我们应该始终铭记于心。
使用领域事件的方法可以达到很高的并发处理性能和较低的系统耦合；当然不利之处是我们需要考虑它带来的&lt;strong&gt;系统行为的额外复杂性&lt;/strong&gt;，因为依赖从显示的调用变成了异步的发布/通知模型。&lt;/p&gt;

&lt;h3 id=&quot;领域事件的建模&quot;&gt;领域事件的建模&lt;/h3&gt;

&lt;p&gt;我们总是用某个发生的事件来表述领域事件，比如somethingHappened，这个概念描述的是一件事实已经发生过；
有时候我们还需要描述事件发生的上下文信息，比如发生的时间，出现次数等。
不论如何建模，我们还需要保证&lt;strong&gt;领域事件总是不可变的&lt;/strong&gt;，就如已经发生的事情不可更改一样；
同时参照前面所述的值对象的语义，保证领域事件没有副作用也是一项隐含的要求。&lt;/p&gt;

&lt;h3 id=&quot;领域事件标识符&quot;&gt;领域事件标识符&lt;/h3&gt;
&lt;p&gt;大部分情况下，当领域事件仅仅被一个绑定上下文消化、处理的时候，没有必要给领域事件指定一个唯一的标识符；
然而当&lt;strong&gt;领域事件可能被从一个绑定上下文中通过底层的事件转发基础设施被发送到另外一个领域中&lt;/strong&gt;去的时候，
我们就不得不为领域事件准备一个唯一的标识符，使得不同的事件可以在其被处理的范围内可以被唯一识别。
同样的当一个领域事件需要被持久化存储或者从存储介质中恢复到内存的时候，事件标识符也必不可少。&lt;/p&gt;

&lt;h3 id=&quot;从领域模型中发布事件&quot;&gt;从领域模型中发布事件&lt;/h3&gt;
&lt;p&gt;当事件需要发送到某个远程的领域中去的时候，我们需要尽量把领域事件的细节与底层的事件分发中间件或者框架相解耦，&lt;strong&gt;避免将领域事件的细节泄露给基础设施中间件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;发布事件的时候，最终一致性模型带来的副作用和&lt;strong&gt;它本身的一致性保证机制&lt;/strong&gt;值得详细考虑。
当通过一个中间件或者事件转发设施来分发事件的时候，&lt;strong&gt;领域逻辑对事件延迟的容忍性&lt;/strong&gt;也需要根据领域业务要求进详细分析。
有时候我们甚至需要对历史发生的事件做一些后续处理和分析，这种情况下，我们可以采用事件存储的方式，设置一个完成事件序列化保存的特殊的事件监听者。&lt;/p&gt;

&lt;h2 id=&quot;模块&quot;&gt;模块&lt;/h2&gt;
&lt;p&gt;一些现代的变成语言或者框架都自带了模块机制，因而模块的概念和这些语言框架中的模块的用法并没有特别本质的区别。
唯一需要留意的是DDD中的模块的命名和使用是&lt;strong&gt;以领域模型的内聚为依据&lt;/strong&gt;的，它并不一定和代码的具体部署和运行方式强绑定。&lt;/p&gt;

&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;
&lt;p&gt;聚合是一种用于&lt;strong&gt;将实体或者值对象仔细汇聚在一起并形成清晰的边界&lt;/strong&gt;的领域设计概念。从描述来看聚合好像很简单直接，然而它也许是DDD中最没有被准确理解和实施的概念。&lt;/p&gt;

&lt;p&gt;聚合的设计实现上很容易落入（需要尽力避免）如下的两个极端&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为了组合的方便而将聚合的引用关系设计的非常复杂和庞大&lt;/li&gt;
  &lt;li&gt;或者将聚合的关系拆分地太独立以至于没有办法真正地维护领域逻辑中的不变式&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在一致性边界内的不变式上建模聚合&quot;&gt;在一致性边界内的不变式上建模聚合&lt;/h3&gt;

&lt;p&gt;为了发现领域模型中的聚合，我们需要仔细&lt;strong&gt;甄别领域边界内的业务规则的内在不变式&lt;/strong&gt;。
这些不变式属于一些业务规则，并且这些业务规则必须总是一致的。这样的一致性由很多种形式，
一种是传统的原子性的一致性，他们是即使生效的，并且是原子不可变更的；这种也往往被成为事务一致性；还有一种新的一致性模型是最终一致性。
&lt;strong&gt;聚合不变式种考虑的是传统的事务一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;设计良好的聚合可以保证每次修改的时候其内在的领域逻辑的一致性总是在修改后被保留，也就是说它的&lt;strong&gt;不变式在修改前后总是可以被满足&lt;/strong&gt;。
这也意味着，从用户界面来的修改每次仅仅能够在一个聚合上被执行，否则事务一致性就很难满足。&lt;/p&gt;

&lt;h3 id=&quot;保持聚合设计尽量的小&quot;&gt;保持聚合设计尽量的小&lt;/h3&gt;
&lt;p&gt;因为我们需要保证聚合的事务一致性语义，考虑到&lt;strong&gt;性能和可扩展性&lt;/strong&gt;，自然而然地我们想要将聚合的设计保持足够的小，因为庞大的事务处理会带来明显的性能瓶颈。
想象具有复杂的关联关系的聚合，当我们需要更新一个很小的属性的时候，为了维护一致性，
我们可能不得不将所有有关联的记录都从其它的地方加载的内存中完成处理。&lt;/p&gt;

&lt;p&gt;小规模的聚合带来的一个额外的好处是&lt;strong&gt;产生冲突的概率大大地降低&lt;/strong&gt;了，从而使得系统的可用性自然得以提高；因而不论任何情况，都要想办法降低聚合的体量保持它足够可能的小。&lt;/p&gt;

&lt;h3 id=&quot;组合聚合对象的时候用标识符来引用之&quot;&gt;组合聚合对象的时候用标识符来引用之&lt;/h3&gt;
&lt;p&gt;一个很常见的想法是可以组合多个聚合，在这种场景下，我们需要&lt;strong&gt;抵制住如下的诱惑：将引用的聚合想象为是在同一个一致性保证的边界&lt;/strong&gt;内。
其实这样的做法会得不偿失，因为如果那么做了，聚合的规模就不可能保持的很小，性能惩罚就会悄悄地潜入进来，危及系统扩展性和可用性。&lt;/p&gt;

&lt;p&gt;更好的处理方法是不在引用外部聚合对象（指针或者引用），而是在使用的地方&lt;strong&gt;用对方的全局唯一标识符来替代&lt;/strong&gt;。
显然地得益于&lt;strong&gt;对象标识符本身保证了对象自己并不会被自动加载入内存&lt;/strong&gt;中；不管是静态的内存分配还是垃圾收集器的负担都得以大大减小。&lt;/p&gt;

&lt;h3 id=&quot;在聚合边界之外采纳最终一致性模型&quot;&gt;在聚合边界之外采纳最终一致性模型&lt;/h3&gt;
&lt;p&gt;对于跨越多个聚合的业务运算，业务处理用例其实&lt;strong&gt;跨越了多个领域上下文，这种情况下我们需要考虑最终一致性&lt;/strong&gt;模型保证而不是聚合本身默认的事务一致性模型。
在大部分业务场景下，领域专家对最终一致性模型的容忍程度往往要高于开发人员的想象。&lt;/p&gt;

&lt;p&gt;某些领域场景可能有一些额外的挑战，因为是&lt;strong&gt;采用最终一致性模型还是采用事务一致性模型并不容易得到一个清晰的答案&lt;/strong&gt;。
熟悉传统的事务模型的DDD实践者可能更倾向于采用强一致性的事务保证，而喜欢CQRS模型的开发者则更喜欢最终一致性模型。
问题的&lt;strong&gt;核心在于深入理解领域模型的不变式要求&lt;/strong&gt;，因为DDD开发的首要思想就是始终考虑领域的实际需求而不是具体的软件实现技术设施。&lt;/p&gt;

&lt;h3 id=&quot;例外规则&quot;&gt;例外规则&lt;/h3&gt;
&lt;p&gt;凡事都难免有例外，某些情况下我们处于特殊的需要会主动选择打破上述这些聚合规则，譬如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户接口操作的遍历，比如在批量创建一系列聚合对象操作和创建一个聚合对象来操作所有处理没有很大区别的时候，我们可以选择打破上述的规则&lt;/li&gt;
  &lt;li&gt;缺乏&lt;strong&gt;最终一致性要求的基础设施&lt;/strong&gt;，比如计时器、后台线程调度、消息传递设施；此时强行采用最终一致性会有额外的挑战，我们不得不妥协&lt;/li&gt;
  &lt;li&gt;全局事务或者一些&lt;strong&gt;遗留技术的影响&lt;/strong&gt;，譬如我们不得不于其它依赖于两阶段提交的分布式事务系统打交道的时候，最终一致性处理的引入可能得不偿失&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;查询性能需要优化&lt;/strong&gt;的时候，我们不得不缓存外部聚合对象的指针而不是每次在需要的时候加载进内存做查询，当然性能的影响需要仔细掂量权衡&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;避免使用依赖注入&quot;&gt;避免使用依赖注入&lt;/h3&gt;

&lt;p&gt;使用依赖注入技术来自动传入一个聚合类所依赖的服务或者仓库对象应该被认为是一个糟糕的想法，
原因很简单：&lt;strong&gt;我们期望用对象标识符的方法来引用其它的聚合对象而不是用对象引用自身&lt;/strong&gt;而依赖注入技术会自动将对象的引用传递进来。&lt;/p&gt;

&lt;h2 id=&quot;其它一些ddd方法和术语&quot;&gt;其它一些DDD方法和术语&lt;/h2&gt;
&lt;p&gt;除了上面探讨的DDD方法和术语，还有如下一些比较容易理解的设施&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;工厂类，工厂方法、抽象工厂等，这些概念在传统的设计模式中已经得到了广泛的研究，DDD只是拿来使用。&lt;/li&gt;
  &lt;li&gt;仓库概念和传统的数据库中的DAO或者对象集合的技术很接近，可以用传统的Hibernate技术也可以用NoSQL的方法来实现仓库，Spring等开源库已经提供了很好的封装手段。&lt;/li&gt;
  &lt;li&gt;集成领域上下文的技术，可以是用基于传统的RPC的方式，也可以采用基于REST API的方法来完成，相关的软件架构技术已经探讨的比较充分了。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="　architecture" /><category term="pattern" /><category term="engineering" /><summary type="html">领域驱动设计在最近几年里越来越多地走进了主流架构设计的中心舞台上来了，这一切其实似乎是在业界精神领袖Martin Folwer在 他的《企业软件架构模式》一书和各种各样的讨论中的推荐之下之后忽然就火了起来。 甚至有一种说法是：如果学完了设计模式之后感觉没有什么用武之地，那么你需要去好好看一下Eric Evans写的《领域驱动设计》一书以吸收新的灵感， 然后才能知道你工作中的面性对象设计用错在了什么地方。</summary></entry><entry><title type="html">读Uncle Bob新书-Clean Archtiecture</title><link href="https://skyscribe.github.io/post/2019/01/26/clean-architecture-notes/" rel="alternate" type="text/html" title="读Uncle Bob新书-Clean Archtiecture" /><published>2019-01-26T00:00:00+08:00</published><updated>2019-01-26T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/01/26/clean-architecture-notes</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/01/26/clean-architecture-notes/">&lt;p&gt;不经意发现Bob大叔出版了新书，延续之前的命名风格定名为《Clean Architecture》，英文版已经于2017年底正式上市；
刚好公司的账户可以访问Orielly公司的在线书城，于是就断断续续地读了起来。
Bob大叔讲故事的能力即使在久负盛名的技术作家圈里面也是闪耀出众的，可以算作是高手中的高手，行文由浅入深层层递进，可读性一向很好，这本书读起来也不例外。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;历史的回顾和架构师的主要职责&quot;&gt;历史的回顾和架构师的主要职责&lt;/h2&gt;

&lt;p&gt;作者在一开头就用讲故事的手法描述了一个要求保持匿名的市场领先的软件公司的例子来讲述软件架构失败可能带来的巨大危害 - 一个庞大的具有超过六百万行代码的项目，
因为明显的架构问题导致8年的时间，项目组的人手越来越多，开发和添加新的功能的成功却又直线上升导致虽然增加了很多的人手却不能得到相对应的产出；
这样的问题也就是很多书里所讲的&lt;strong&gt;可扩展性不足&lt;/strong&gt;导致的修改困难。&lt;/p&gt;

&lt;h3 id=&quot;架构师的工作重心&quot;&gt;架构师的工作重心&lt;/h3&gt;
&lt;p&gt;回头说起来软件项目和硬件项目的不同，Bob大叔认为这里主要的不同就来自于软件是可以被修改的，而硬件项目则是一旦完工就无法很容易地扩展和添加新的功能。
软件架构师的主要核心职责&lt;strong&gt;不在于功能性的需求如何被实现出来，而是如何监控和设计软件系统的结构&lt;/strong&gt;使得添加新的功能保持简单、经济和高效。&lt;/p&gt;

&lt;p&gt;虽然作者没有明确地提到，但是我们还是需要注意功能需求也是很重要的，因为很多架构的约束反而是来自于系统的功能性需求；
只是现实生活中，大部分的项目经理和管理人员更容易看到功能需求的问题，而不会特意关注系统结构上的约束，那么我猜这里作者有意不提这方面也算合理，
读者却不可不自己心神领会；如果生搬硬套就会走向歧路了。&lt;/p&gt;

&lt;h3 id=&quot;计算机行业的历史&quot;&gt;计算机行业的历史&lt;/h3&gt;

&lt;p&gt;讲起历史来，Bob大叔绝对算是行家中的行家；当初他的《Clen Code》系列视频中每一节都会加入一小部分关于天文学和物理学的历史知识作为铺垫；
甚至于我一度以为大叔是学理论物理学或者科学史出身的（后来在其它的演进里面才发现不是）。为了讲述和探讨软件行业的本质工作性质，作者又不吝文墨地回顾了整个计算机程序设计的历史；
作者给出的结论是，真正&lt;strong&gt;本质的计算机技术和程序设计思想在过去的几十年中并没有发生太大的变化&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这可以说是一个既乐观又悲观的消息。好的方面是，行业经过几十年的摸索和积淀终于积累下来了很多供后辈好好重用的宝贵经验；
可悲的地方却是商业上的超级多的&lt;strong&gt;浅层次的成功反而使得真正的技术被大部分人忽视&lt;/strong&gt;了。
工业领域的应用招致了很多不懂计算机核心技术的软件工程师，用不太严谨的做法堆砌出大量的代码，而真正的生产模块化的代码的技术和方法都是在&lt;strong&gt;想方设法限制程序员的能力&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;编程范式的历史&quot;&gt;编程范式的历史&lt;/h3&gt;
&lt;p&gt;虽然编程的本质是一样的，业界却先后流行起来三种变成编程范式，对这些范式的支持情况的不同导致了各种形形色色的编程语言的繁荣；
但是仔细琢磨的话，我们会发现这些编程语言虽然外表看起来千差万别，分解之后里面的核心特性却没有多少。&lt;/p&gt;

&lt;p&gt;面向过程的编程范式是很多人非常熟悉的范式，早期的先驱们（尤其是荷兰的牛人Dijkstra从理论物理专业转行来演进计算机理论）总结了几种基本的结构，
并不惜通过在&lt;strong&gt;一片争论声中将Goto关入牢笼&lt;/strong&gt;来强迫大家&lt;strong&gt;采用事先定义好的顺序、分支和循环三种控制流转换&lt;/strong&gt;，编写出良好的软件。
因为硬件执行过程的贴切的模拟对应，面向过程的编程范式一直是程序员的基石。&lt;/p&gt;

&lt;p&gt;面向对象的编程范式其实并没有干太多新的事情，它里面总结的各种套路其实面向过程的方法也可以做到。
有人总结了面性对象的本质特性是继承、封装和多态，然而本质上面向过程的语言用结构和函数指针的方法一样可以达到，
甚至早期兴盛的C++语言就是通过虚函数表这一机制，在底下生成额外的控制带来控制程序逻辑跳转。
从这个意义上来看，面向对象的编程范式其实是限制了程序员必须用&lt;strong&gt;间接控制流转移&lt;/strong&gt;的方法来提高可维护性。&lt;/p&gt;

&lt;p&gt;函数式编程范式则是很早的一个范式，众所周知它的历史可以追溯到和图灵同时代的逻辑学家邱奇的lambda算子推演。
这一思路的主要特征就是&lt;strong&gt;数据的不可变性&lt;/strong&gt;，同样的数据经过同样的处理必然产生同样的输出，同时数据一旦产生就不能被修改了，否则就会有副作用。
这种范式之所以能够再度流行起来，恰好又是因为更为复杂的运算需求需要增加数据之间的隔离。
前两种范式里面都有很明显的变量和赋值、操作的基本机制，而这一机制在函数式范式面前毫无用武之力。&lt;/p&gt;

&lt;p&gt;软件架构师的任务就是需要清楚地认识到这些编程范式&lt;strong&gt;只是在不同的维度上对程序员加了各种各样的约束&lt;/strong&gt;，以解决它所适应的场景的问题而已。
理顺问题的场景然后清楚地了解编程实现和交付中的各种困难，减小软件扩展和维护的成本，是架构师所面临的最根本的挑战。&lt;/p&gt;

&lt;h3 id=&quot;计算机为什么是一门科学&quot;&gt;计算机为什么是一门科学&lt;/h3&gt;
&lt;p&gt;作者不惜花费大量的笔墨来跟踪Dijkstra大师的人生轨迹和研究成功，其实是想为他最后的结论做铺垫，搞明白计算机能否成为严谨的数学。
毕竟早期的计算机先驱们都是数学家乃至逻辑学家；他们都期望找到一种严格的方式来证明计算机程序的绝对正确性。
现在大家都已经明白，这种努力无论从理论上还是时间上都已经破产了。&lt;/p&gt;

&lt;p&gt;计算机软件和编程工作只能被认为是一种科学而不是一种数学。科学的主要特征是，你永远无法证明某个事情是真的，
但是却可以用固定的重复手段去验证该事情，并有可能有一天发现这个事情不成立而推翻这个结论。
这个&lt;strong&gt;证伪的方式其实就是我们所做的软件测试&lt;/strong&gt;；我们有各种方法做形形色色的测试，而测试不通过的时候，我们可以通过修改程序来变更程序的行为，使得它贴合我们的期望。&lt;/p&gt;

&lt;p&gt;想通过分析和推倒来写出严格的没有问题的程序虽然没有指望了，我们仍然可以通过降低测试的成本，改进测试的手段和方法，
通过持续、自动化的测试和即时反馈的方法提高工作效率。这方面的思考对于架构师而言是不可或缺的。&lt;/p&gt;

&lt;h2 id=&quot;模块设计的原则和solid&quot;&gt;模块设计的原则和SOLID&lt;/h2&gt;

&lt;p&gt;架构师所关心的应该是更高层次的抽象实体而不再是一样一行具体的实现代码，因为&lt;strong&gt;唯有关注于这些做过良好分离的抽象，才能做到纵览全局心中有数&lt;/strong&gt;。
这些抽象实体之间的关系是架构师需要重点考量的；这个过程中需要用到的设计原则并不拘泥于某种编程语言或者编程范式，尽管这些设计原则是在长期的面向对象思想中被提炼总结出来的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单一职责原则&lt;/li&gt;
  &lt;li&gt;开发闭合原则&lt;/li&gt;
  &lt;li&gt;李氏替换原则&lt;/li&gt;
  &lt;li&gt;接口隔离原则&lt;/li&gt;
  &lt;li&gt;依赖导致原则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些设计原则以前一直被成为是面向对象的设计原则，一个很重要的原因应该是面向对象设计曾经风靡二十年之久；可惜的是&lt;strong&gt;大部分死背概念的架构师并没有真正的理解这些&lt;/strong&gt;设计原则。
Bob大叔则旗帜鲜明地说&lt;strong&gt;这些原则其实都需要仔细地来揣摩和理解&lt;/strong&gt;，单单是粗浅的重复字面意思而不能灵活地应用，无异于是买椟还珠，空入宝山徒手而还了。&lt;/p&gt;

&lt;h3 id=&quot;设计原则的目标和场景&quot;&gt;设计原则的目标和场景&lt;/h3&gt;
&lt;p&gt;这些设计原则的目的是帮助我们实现简单而又可靠的软件模块乃至子系统，使得&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;变更它们的成本很低&lt;/strong&gt;，因为软件系统总是要添加新功能才更有生命力，修改困难的软件就会被慢慢放弃了&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;理解起来容易&lt;/strong&gt;，因为维护软件总是需要人来做，而参与其中的人总是在流动的&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可以被轻易地重用在合适的地方&lt;/strong&gt;，因为永远也没有人可以预测未来的软件项目需求；重头再写类似的代码的代价又过于高昂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述的五大设计原则往往被认为是处理复杂软件系统内处于&lt;strong&gt;中等抽象的实体结构和相互关系&lt;/strong&gt;的指导性方法论。
这些中等粒度的抽象就是一般意义上所说的模块或者子模块；不同的模块或者子模块之间会按照这些原则来聚合而形成基本的可执行单元。
在不太复杂的软件系统中，做到这一层就可以满足所有需要了；更复杂的大型的软件系统可能需要更高层次的组合，即组件。&lt;/p&gt;

&lt;h3 id=&quot;关于设计原则的简单概括和去谬&quot;&gt;关于设计原则的简单概括和去谬&lt;/h3&gt;

&lt;p&gt;简称为SOLID的五大设计原则对于现金的架构师而言都不是什么秘密了，然而对他们的认识上的谬误还是随处可见。作者又不惜花费一个大的章节来详细阐述其中关键的思想。&lt;/p&gt;

&lt;h4 id=&quot;单一职责&quot;&gt;单一职责&lt;/h4&gt;
&lt;p&gt;最简单却又被误解最深的一个原则非单一职责原则莫属了；很多人的第一印象解读就是，一个模块应该只做一件事儿并讲这件事儿做好。
粗看起来这个解释很切合题中之义，也能在Unix编程哲学中找到KISS原则的呼应。只是这一原则的提出其实有更深刻的考虑因为&lt;strong&gt;怎么去界定前面所说的一件事儿&lt;/strong&gt;会非常困难。
单一职责的真正含义是:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个模块&lt;strong&gt;被改变的原因应该有并且只有一个&lt;/strong&gt;；或者说一个模块的&lt;strong&gt;利益相关者应该有并且只有一个&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不幸的是，这里面的原因也好，利益相关者也好，都还是有含糊而解释不清的地方，因此作者毋宁说：
&lt;strong&gt;一个模块和他相关联交互的Actor只有一个&lt;/strong&gt;，这样用UML描述模块关系的时候就比较清楚的看出这一原则有没有呗违反了。&lt;/p&gt;

&lt;h4 id=&quot;开闭原则&quot;&gt;开闭原则&lt;/h4&gt;

&lt;p&gt;开放闭合原则倒是没有那么多的误解，因为它本身就是事关怎样划分子系统、子模块乃至基本单元的。它所要求的系统应该对修改闭合对扩展开放某种程度上可以看做是对模块高内聚的要求。
要做到这一点，需要讲系统划分为不同的抽象层次的模块、子模块，并且实现良好的约束使得高层的模块不要以来于低层的实现，而&lt;strong&gt;扩展系统的方式总是维持核心模块的稳定性再增加新的低层模块&lt;/strong&gt;来完成。&lt;/p&gt;

&lt;h4 id=&quot;李氏替换原则&quot;&gt;李氏替换原则&lt;/h4&gt;

&lt;p&gt;李氏替换原则原本是来源于类型系统的定义；一般也不太会被理解错误，只是在软件设计和架构中，这里的&lt;strong&gt;类型被替换成了设计中的抽象&lt;/strong&gt;并加以深入考量。
对于有类型的静态语言来说，这意味着接口或者基类的抽象需要有足够好的普适性，扩展出来的子类必须完全遵守事前定义好的契约，因为这里的&lt;strong&gt;耦合是非常强&lt;/strong&gt;的。
对于弱类型的动态语言而言，这些约束可能是隐式的，虽然因为不必有源代码依赖上的麻烦而变得更加灵活，但是同样因为没有这些检查而使得所有违反约束的错误代码都只能在运行时才能发现。&lt;/p&gt;

&lt;p&gt;某种程度上说，缺少了编译器的检查，&lt;strong&gt;动态语言易于修改代码的优势其实带来了维护设计一致性的额外麻烦&lt;/strong&gt;；这一点不可不察。&lt;/p&gt;

&lt;h4 id=&quot;接口隔离原则&quot;&gt;接口隔离原则&lt;/h4&gt;

&lt;p&gt;接口隔离原则强调的是模块化软件关于耦合方面的分离；它的最基本的思想可以认为是：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;除了你必须要以来来完成模块定义的功能之外的东西，额外的依赖都不要引入进来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里的要求是两个方面的&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;提供功能的模块在对外提供的接口上必须保证是高度内聚的，在对应的抽象等级、粒度上给出的接口需要职责明确&lt;/li&gt;
  &lt;li&gt;使用接口的模块需要保证只引入自己使用的功能，而不能引入不必要的依赖&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;依赖倒置原则&quot;&gt;依赖倒置原则&lt;/h4&gt;

&lt;p&gt;这个原则可以看作是传统的面向对象设计里面最为烧脑的一个原则，正确理解起来一直有些不容易，因为必须&lt;strong&gt;同时考虑到代码结构的组织和实际运行时的依赖来看&lt;/strong&gt;才能体会其中的精妙。
它的核心是将程序组织的依赖和运行时的依赖跟分离开来看，构造代码的时候，从抽象角度来说需要保证&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;抽象层次高的代码必须依赖于抽象而不是具体实现；&lt;/li&gt;
  &lt;li&gt;实际的具体实现的代码就只能看到这些抽象而看不到抽象背后所隐藏的实现；&lt;/li&gt;
  &lt;li&gt;核心模块的业务规则只能看到其它外围模块的概念抽象，而看不到具体实现这些抽象的实体；这样当需要扩展新的实现方式的时候，只需要添加新的实现代码，而&lt;strong&gt;核心的业务规则可以保持稳定&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看出依赖导致原则其实潜在地暗含了其它几个原则。实际实现中还需要考虑下面一些因素&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;操作系统和平台软件的一来是不可避免的；但是这里的关键是期望减小系统的维护成本，
而这些底层的稳定的部分很少变化，所以直接依赖他们的具体实现倒是也问题不大；
如果是自己内部搭建的通用平台软件，那么则需要另外分析和斟酌；这方面的讨论也有很多。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;核心业务逻辑层的稳定提炼需要依赖于领域知识&lt;/strong&gt;，因为什么是稳定的什么是可变的跟具体的目标业务场景息息相关，没有放之四海而皆准的模板可以套用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;组件设计原则&quot;&gt;组件设计原则&lt;/h2&gt;

&lt;p&gt;组件化技术已经成为搭建大型复杂软件系统的基础技术，如何组织系统的组件子系统，安排好这些子系统之间的接口、依赖和交互关系是软件系统架构师的主要工作职责。
需要留意的是，这些技术是&lt;strong&gt;构建在基本的模块化设计开发方法之上的，因此很多模块设计的原则也被自然而然地升华和适配&lt;/strong&gt;；如果不能深刻地理解基础的模块化设计方法和里面的痛点，
生搬硬套组件设计的方法弄不好就会弄巧成拙，变成浮沙之上筑高台的游戏就很容易招徕失败。&lt;/p&gt;

&lt;h3 id=&quot;组件化技术的探索和演化历史&quot;&gt;组件化技术的探索和演化历史&lt;/h3&gt;
&lt;p&gt;组件作为复杂的软件系统发布和部署的基本单元，其形式随编程语言和平台的研究和发展而呈现不同的具体形式，可能是Java环境中的Jar打包文件，
或者是.NET环境中的动态库文件，也可能是Ruby中的Gem，Rust中的模块，NPM中的模块等。
它们的共同特征就是&lt;strong&gt;可以独立打包、发布，并且和其它组件有形形色色的依赖共生&lt;/strong&gt;关系。&lt;/p&gt;

&lt;p&gt;最早期的家算计程序不支持这些概念，所有人开发的源代码必须安置好在内存中被加载的位置，多人协作的场景下，
大家协商好自己负责的部分的加载地址，但是这种很快就变得难以为继；
于是新的可以支持重定位加载地址的技术就被发明出来，使得不同的程序可以在加载的时候，加载器通过计算给它安差一个位置，防止冲突。
这种情况下，编译出来的程序的实际加载位置是未知的，而加载器需要根据它的算法为一个可执行文件中的所有的动态加载地址计算一个没有冲突的方案来。
链接器则被用来对编译的程序安插一些可重定位的段和符号表，以便加载器在程序实际载入内存的时候安插实际的内存地址。&lt;/p&gt;

&lt;p&gt;摩尔定律和墨菲定律的交替作用始终影响着计算机软件行业的发展和演进，程序的规模变得越来越大，业务系统越来越复杂，而&lt;strong&gt;新技术的出现总是被现实中遇到的限制所驱动&lt;/strong&gt;。
传统的静态语言中，用连接器和加载器技术组织的组件化技术依然有各种各样的优势和不足，间接催生了采用不同技术决策的技术的繁荣共存；
于此同时，希望绕开这一限制的先驱们则通过创建新的编程语言（如动态语言）或者平台技术（跨越多种语言的中间语言来促进互操作）来简化组件化开发的种种问题。&lt;/p&gt;

&lt;p&gt;现在我们可以支持在程序执行的过程中，&lt;strong&gt;不重启主要系统，而将新开发的功能插入运行的系统中的办法&lt;/strong&gt;来实现功能的实时更新和扩展，
这种插件化技术甚至在很多开发环境中成为默认的扩展方式；这一技术能够工作的前提是系统的架构必须有良好的考虑和组织。&lt;/p&gt;

&lt;h3 id=&quot;组件内聚原则&quot;&gt;组件内聚原则&lt;/h3&gt;
&lt;p&gt;Bob大叔讲使用用组件划分的原则总结为基本的三条；这三条原则也是前面所说的模块化设计原则的延伸&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;重用和发布等同原则 (Common Resue/Release Equivalence Principle)&lt;/li&gt;
  &lt;li&gt;通用闭合原则 (Common Closure Principle)&lt;/li&gt;
  &lt;li&gt;通用重用原则 (Common Reuse Principle)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一条原则是关于模块的聚合和发布，现代的软件工具已经隐含地要求我们放在一起的类或者模块必须同时发布出去，所以这一个原则看起来是不言自明的。
只是这里面有个不太明显的部分在于，如果设计者将没有关联的东西随意放置在一起发布，那么不必要的&lt;strong&gt;偶然依赖就会出现使得系统变得难以维护&lt;/strong&gt;。
这些被打包在一起发布，使用同样的测试、发布流程的组件内部模块必须共同服务于同一个设计目标，并且&lt;strong&gt;遵循前面单一职责原则的思想，应该有且只有一个原因而变更&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;后边两个原则则是从其它方面深入阐述了第一条原则的重要性和潜在假设。&lt;/p&gt;

&lt;p&gt;通用闭合原则描述的是&lt;strong&gt;单一职责和开放闭合原则在组件化设计上的应用&lt;/strong&gt;；它建议我们讲同样职责并且提供单一变更或者有单一的Actor的类或者模块放置在一个组件中。
响应地，具有不同的逻辑职责或者可能有多个原因引起重新发布控制的模块或者类应该被归类放置在不同的组件中。
不同的是这里讨论的变更所在的抽象层次更高一些。&lt;/p&gt;

&lt;p&gt;最后一个原则注重于组件的重用，要求我们&lt;strong&gt;仅仅使用本组件需要用到的其它功能组件&lt;/strong&gt;，不要引入不必要的组件之间的依赖。
这个考虑之所以重要，是因为依赖关系总是有传递性的，引入不必要的依赖会使软件配置管理变得困难，测试和验证复杂度急剧上升，从而增加软件的维护成本。
毕竟软件架构的目标就是尽力提高软件系统的可扩展性和降低维护变更的成本。&lt;/p&gt;

&lt;h4 id=&quot;三个原则之间的关系&quot;&gt;三个原则之间的关系&lt;/h4&gt;

&lt;p&gt;软件架构工作可以看做是充满了妥协和折中的艺术性活动，尽管它所依赖的基本工具是各种各样的技术和业务领域知识。
这三个原则之间其实是相互掣肘，相互依赖的关系，实际应用的时候需要根据场景和需求分析和折中，而不能走向极端。&lt;/p&gt;

&lt;p&gt;如果过分考虑重用性和发布重用等价两个原则，则会引入很多不必要的软件组件，带来极高的维护成本；
过分考虑通用闭合原则和发布重用等价原则，则会违反重用原则，导致升级和发布困难。
显然&lt;strong&gt;闭合原则强调聚合而重用强调拆分，两者是互斥的两面&lt;/strong&gt;，需要综合分析和考虑。&lt;/p&gt;

&lt;p&gt;三个原则的使用和侧重也可能因为开发所处的阶段不同而变换。往往&lt;strong&gt;在项目的早期阶段，组件重用方面的考虑并不会太多&lt;/strong&gt;，否则就会因为选择困难而迟迟无法取得进展。
等到越来越多的功能被加入进来，则需要适时地拆分组件，提高可重用性。&lt;/p&gt;

&lt;h3 id=&quot;组件耦合处理原则&quot;&gt;组件耦合处理原则&lt;/h3&gt;

&lt;p&gt;模块化的软件设计方法要求我们尽力减少组件之间的耦合，而正确地处理组件的耦合从来不是一个简单的工作，&lt;strong&gt;需要考虑技术、政治和环境变化等方面的因素&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;无依赖环原则&quot;&gt;无依赖环原则&lt;/h4&gt;
&lt;p&gt;第一个重要的原则是，组件之间的依赖关系中不能出现环。&lt;/p&gt;

&lt;p&gt;这一原则的基础想法是考虑组件之间的依赖关系，并用一幅有向图来描述各个组件之间的依赖关系，并检查最终的组件依赖关系图中是否存在有环。
显然出现了依赖环的组件之间有很强的耦合，&lt;strong&gt;会带来代码改动和发布上的困难&lt;/strong&gt;，测试和集成工作也会寸步难行，&lt;strong&gt;必须依赖于高频度的同步开发，而过多的同步则必然带来并行开发效率的降低&lt;/strong&gt;。
有时候复杂的组件依赖环还会带来组件构建和发不顺序选择上的困境，很多时候发布团队不得不小心选择构建的顺序和工作流以免带来不一致。&lt;/p&gt;

&lt;p&gt;打破依赖环的常见办法有两种&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;采纳&lt;strong&gt;依赖导致原则，抽象出来接口组件&lt;/strong&gt;，然后让组件依赖于接口，而实现组件实现给定的接口组件；这样强依赖关系便被打破。&lt;/li&gt;
  &lt;li&gt;创建一个新的组件，然后把产生环形依赖的组件糅合放置在新的组件中，这样原来的环就自然消失了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样的变更意味着传统的自顶向下方法的失效，但是如果我们考虑演进式架构的方法学，总是用发展的思维看到软件架构的工作，
矛盾就自然迎刃而解了，因为复杂的组件依赖不是一夜之间突然冒出来的，
只要在&lt;strong&gt;刚刚出现问题的时候，采用务实的思路分析业务问题和组件设计约束，尽快扑灭架构腐化的苗头&lt;/strong&gt;即可。
这样的方法其实也是现在敏捷环境下软件设计的主要思路
(&lt;a href=&quot;/ /post/2016/12/24/software-design-in-agile-development-context/&quot;&gt;之前的思考见这里&lt;/a&gt;)。&lt;/p&gt;

&lt;h4 id=&quot;稳定依赖原则&quot;&gt;稳定依赖原则&lt;/h4&gt;

&lt;p&gt;软件架构从来不是一个静态的概念，构成系统的组件总是会因为各种各样的原因而不时发生变化。
这条原则讨论的是组件之间相互依赖方向的选择，即考虑哪个组件应该依赖于哪个组件的问题。
作者的经验是，&lt;strong&gt;变化相对困难的组件应该依赖于稳定而易于修改的组件&lt;/strong&gt;，而不是相反方向；否则就会引起架构的腐化和演进困难。&lt;/p&gt;

&lt;p&gt;这里的关键是，需要将&lt;strong&gt;组件的稳定性用变更的难易程度来衡量&lt;/strong&gt;，而不是实际变更的多少来衡量，因为软件组件从被设计出来的那一天开始，
就不能避免发生变化，除非它因为无法重用而慢慢消亡失去生命力。影响稳定性的因素有很多，比如代码的行数，编程语言或者领域复杂性等，
但是从架构设计的角度看，&lt;strong&gt;一个明显的因素是它所依赖的其它模块的数量和稳定性本身&lt;/strong&gt;。
如果一个模块有很多的前向依赖，那么这些依赖模块的变更都会使该模块本身变得不稳定。&lt;/p&gt;

&lt;p&gt;稳定性的度量可以用依赖关系图上面的扇入、扇出关系来简单计算，只需要简单数一下依赖于该组件的其它组件的数量（扇出值），
并用这个数字除以所有扇入扇出的所有组件的数量，就可以得到一个简单的稳定性度量。
当这个度量为１的时候，表明它没有使用其它组件，那么修改起来非常容易，不会有其它的影响。&lt;/p&gt;

&lt;p&gt;如果用上面的依赖度量值来描述稳定性依赖原则，那么我们需要保证，在组件依赖关系图上，&lt;strong&gt;沿着依赖方向组件的稳定性值需要保持递减&lt;/strong&gt;。
对于违反了这一原则的组件，一个简单的处理方法依然是&lt;strong&gt;使用依赖倒置原则创建新的抽象组件&lt;/strong&gt;，从而避免稳定的组件依赖于不稳定的组件。&lt;/p&gt;

&lt;p&gt;这样会产生一个明显的结果是有一些&lt;strong&gt;纯粹抽象的组件被创建出来，不过无需惊讶的是，成熟的软件系统中，纯抽象的接口组件随处可见&lt;/strong&gt;。
当然这个现象是静态语言编程环境中才会观察到的现象，因为静态类型系统总是需要检查声明和实现的一致性，以期及早发现编码中的问题。
动态语言编程环境由于放松了对程序员代码一致性的检查，所有的依赖都是隐性的，所以没有必要创建抽象的接口组件。&lt;/p&gt;

&lt;h4 id=&quot;稳定抽象原则&quot;&gt;稳定抽象原则&lt;/h4&gt;

&lt;p&gt;这一原则可以用一句简单的表述概况，即&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个组件的稳定程度应该和它的抽象程度想匹配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它要求我们&lt;strong&gt;将业务逻辑相关的核心策略或者非常稳定的业务规则用高度抽象的组件接口描述出来&lt;/strong&gt;。而一些不是特别重要的或者易于变化的部分可以用具体的组件模块来实现。
在面性对象系统中，这些高度稳定的部分有时候有一些默认的实现，这些实现可以用抽象类的办法来实现之。&lt;/p&gt;

&lt;p&gt;组件的抽象程度可以用一个简单的公式来度量：用组件中的抽象接口和抽象类的总和除以组件中所有的接口、类的数量就可以得到其度量值。
这种度量方法比较适合纯粹的如Java这样的面向对象语言。&lt;/p&gt;

&lt;p&gt;Bob大叔还基于上述的两个度量方法，提出了一套定量分析组件设计的稳定性和抽象程度匹配度的模型。
可以用常规的统计学方法来判断组件系统的设计是否处于良好的状态。
在这一的关联图中，设计良好的软件组件总是处于对角线的位置，而偏离对角线的地方则可能意味着有连个极端&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;过度抽象却又鲜有变化的代码表明存在着&lt;strong&gt;过度设计&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;缺乏良好抽象却又不稳定的组件会带来&lt;strong&gt;维护泥潭&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;整洁之架构&quot;&gt;整洁之架构&lt;/h2&gt;

&lt;p&gt;什么是架构和架构师，以及架构师应该需要做什么向来是充满争议的话题。
写了很多经典著作的Martin Fowler写过著名的&lt;a href=&quot;http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf&quot;&gt;Who Needs an Architect&lt;/a&gt;
指出&lt;strong&gt;架构师应该是做出关键而重要的技术决策的资深开发者&lt;/strong&gt;。
Bob大叔则进一步从软件开发人员的角阐述了架构师应该是什么而不是什么&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;架构师是最好的程序员，并且继续作为一个程序员&lt;/strong&gt;而存在；不应该相信那些架构师可以从代码中抽身而出的只关注于高级问题的砖家的说法。&lt;/li&gt;
  &lt;li&gt;架构师需要关注于如何提高程序员团队的生产率，这一要求使得架构师不能脱离程序员队伍，否则他们就无法理解实际实现中的痛点和问题。&lt;/li&gt;
  &lt;li&gt;软件架构需要关注于软件系统如何被开发、部署、运行、维护；其背后需要尽可能的少封闭一些具体实现相关的决策。&lt;/li&gt;
  &lt;li&gt;软件架构的终极目标是&lt;strong&gt;用尽可能小的成本来支持系统的生存周期，最大化地提高程序员的生产效率&lt;/strong&gt;。这就要求我们尽可能多地留出更多的扩展接口，减少系统层面的写死设计。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;保留尽可能多的选项&quot;&gt;保留尽可能多的选项&lt;/h3&gt;

&lt;p&gt;软件总是凸显两个方面的价值:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;行为模式的价值，只有实现正确的行为模式，软件才能变得有用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;结构模式的价值，唯有具备了合适的结构，软件才能成为软件&lt;/strong&gt;，而合理的结构应该是软件架构本身的重点所在；因为没有良好的架构的软件系统也能完成需要的行为&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件之所以能被称之为软件，最大的原因在于变更它的结构以便适应变化的需求的成本很小。如果想做到这一点，
我们需要把软件系统分为两个部分：策略和细节。&lt;strong&gt;策略一旦选定变化起来就比较困难，而细节实现的变化往往容易&lt;/strong&gt;。
策略的部分包括这些业务规则和过程，而细节则是具体的技术实现、数据库、通信协议、框架、库等。
由于&lt;strong&gt;商业业务规则比较稳定而技术的变化比较快，我们需要保持这些稳定的部分&lt;/strong&gt;，而尽可能的不写死具体实现这些业务规则的技术细节。&lt;/p&gt;

&lt;p&gt;举个例子来说，在系统开发的早期阶段，选择某个具体的数据库系统实现往往不是最重要的决策，因为
关键的业务规则和逻辑并不需要依赖于具体的数据存储技术和细节。那么架构师可以将这些决定留到以后需要的时候再做；系统中需要用到数据存储系统的时候，使用抽象的接口隔离它就可以了。
类似地，也不需要尽早地在系统开发的早期阶段部署REST接口，因为系统的核心业务规则并不依赖于具体的接口实现技术。是否需要使用某些SOA架构框架或者微服务框架。&lt;/p&gt;

&lt;p&gt;如果这些细节已经被别人事先选择好了，那么保持业务规则灵活的另外一个办法是隔离这些细节，然后在核心业务规则的部分假设这些细节不存在；
这样做的好处是以后万一需要修改采用另外一种方式，只需要增加一种新的实现就可以了。
&lt;strong&gt;好的架构师总是想方设法地最大化未固化的技术决策&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;单体还是微服务&quot;&gt;单体还是微服务？&lt;/h3&gt;

&lt;p&gt;微服务架构目前已经成为一门显学，而架构师则需要拨开这些喧嚣专注于自己的商业系统的核心业务规则。如果系统需要强烈的分布式架构，
那么软件系统应该很容易地扩展为分布式系统，采用SOA或者微服务系统；良好的软件架构需要保留这些选项，
使得&lt;strong&gt;扩展和变更轻而易举&lt;/strong&gt;。如果系统的所有部分都假设自己知道这些细节信息，实现这样的改变就会难于登天。&lt;/p&gt;

&lt;p&gt;关键还是要做好适当的隔离和解耦，不做过多的假设使得核心的业务逻辑仅仅依赖于系统业务逻辑本身。
所有这些应用服务器、依赖注入框架、微服务系统、容器&lt;strong&gt;技术本身是为了简化具体细节的实现&lt;/strong&gt;，而不是来替代软件架构本身。
他们不应该是软件架构的中心；重心是&lt;strong&gt;如何做才能使易于变化的部分怎样以更低的成本实现以满足业务需要&lt;/strong&gt;；其手段就是预留出足够多的扩展空间。&lt;/p&gt;

&lt;h3 id=&quot;系统边界划分&quot;&gt;系统边界划分&lt;/h3&gt;

&lt;p&gt;为了解耦系统架构设计，我们需要设计子系统或者组件，然后分割组件的边界。如何划分系统边界以便更好地实现系统的用例模式，同时减小耦合提高组件复用度不是一件轻而易举的事儿。
好的边界划分方法是&lt;strong&gt;尽可能降低一些不成熟的决策产生的影响，降低对这些容易变化的决策的依赖&lt;/strong&gt;。
我们需要在在重要的模块或者子系统和不太重要的子系统之间划分出清晰的边界；
比如数据库系统和界面显示系统往往和核心的商业业务逻辑之间有一条清晰的边界，因为数据库实现和用户界面相对于业务逻辑而言更不成熟和易于变化。
实现边界隔离的常用办法是抽象出一个接口，然后让具体的实现来提供实现这些接口，而业务规则仅仅依赖于该抽象接口，这其实就是上面的依赖导致原则。&lt;/p&gt;

&lt;p&gt;这样的架构设计方法催生的正是非常著名的允许第三方扩展的插件式架构；核心的系统业务逻辑规则被和其它的可以用各种方式实现的外围模块所分离开，
这样&lt;strong&gt;外围的实现模块就成为核心系统的插件。这些插件部分是易于扩展和替换的&lt;/strong&gt;，从而整个软件系统都变得易于修改和变更以实现新的外围需求。
具体的外围插件系统的例子包括图形界面子系统、数据库子系统等。并且大部分情况下的输入输出系统其实也应该是属于可替换的系统插件而被合适的接口所隔离。&lt;/p&gt;

&lt;h3 id=&quot;策略和分层&quot;&gt;策略和分层&lt;/h3&gt;
&lt;p&gt;核心的业务规则往往本身又可以被划分为很多子系统，这些子系统都是高度抽象的业务规则，
却可以&lt;strong&gt;按照它们和外围的输入输出的远近而被分割为不同的层次&lt;/strong&gt;。
那些和输入输出系统关系比较疏远的子系统处于比较高的层次，而较近的则处于比较低一些的层次。
同时会因为同样的原因变更的部分需要被组合在一个层次中。高层次的策略应该是更稳定的部分，
并且应该代表了更高层次的抽象，更不易发生变化。&lt;/p&gt;

&lt;h3 id=&quot;业务规则识别&quot;&gt;业务规则识别&lt;/h3&gt;
&lt;p&gt;既然业务规则是架构中最核心的部分，如何识别它们有时候不是一个显而易见的问题。
简单地来看，业务规则就是&lt;strong&gt;这些商业系统赖于赚钱盈利的过程或者业务流程&lt;/strong&gt;，这些业务流程很多时候即使没有计算机软件也可以手工来达成。&lt;/p&gt;

&lt;p&gt;这些部分是商业软件系统的核心，它们是软件系统之所以存在的核心价值所在，组成了系统的核心功能。
理想情况下，实现核心业务规则的子系统应该处于软件架构的最核心处，应该是最容易被重用的稳定的代码系统。&lt;/p&gt;

&lt;h3 id=&quot;架构意图呈现&quot;&gt;架构意图呈现&lt;/h3&gt;

&lt;p&gt;良好的软件系统应该能够&lt;strong&gt;第一眼望去就自动呈现系统实现的核心业务，而不是具体的框架、库和基础技术&lt;/strong&gt;。
新加入的程序员可以很容易地学习到系统的基本用力系统，即使他们没有办法很快熟悉系统的具体交付和支撑运行系统。&lt;/p&gt;

&lt;p&gt;这样做的一个额外的好处是，&lt;strong&gt;软件系统本身就成为更容易被隔离测试的健壮的系统&lt;/strong&gt;，因为影响可测试性的一个很大的因素就是这些外围的框架、通信协议等繁杂的细节。
反之以框架和复杂协议为中心组织的软件系统则很难被剥离出来做方便的自动化测试，系统维护的成本也会随之变高。&lt;/p&gt;

&lt;h3 id=&quot;整洁架构的特征和分层&quot;&gt;整洁架构的特征和分层&lt;/h3&gt;

&lt;p&gt;过去几十年来，先驱们发展了各种各样的想法来构建软件架构，这些方法论都致力于实现具有如下特征的软件系统&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;框架独立性：不依赖于任何库或者软件架构&lt;/li&gt;
  &lt;li&gt;可测试性，各个部分可以独立测试&lt;/li&gt;
  &lt;li&gt;界面隔离和独立，不管是命令行界面系统还是桌面客户端或者是浏览器等技术&lt;/li&gt;
  &lt;li&gt;数据库独立性，可以替换各种SQL数据库，或者是文档数据库等，核心的业务逻辑不依赖于这些具体技术&lt;/li&gt;
  &lt;li&gt;外部代理独立性，核心的业务系统并不知道外围的接口和协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bob大叔据此把整洁的软件架构分离为四个环，从内层到外依次是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;业务规则实体&lt;/li&gt;
  &lt;li&gt;应用业务规则包括核心的业务用例&lt;/li&gt;
  &lt;li&gt;接口适配器，包括控制器，展示层，网关等&lt;/li&gt;
  &lt;li&gt;外围设备，Web，界面，数据库，具体设备等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种结构可以用UML图描述如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/clean_architecture.png&quot; alt=&quot;clean-arch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据上面讨论的架构规则，处于内侧的部分是核心的业务规则，外层的部分则是实现的细节和具体机制。
依赖规则要求我们务必保证，源代码层次上的依赖顺序是，外层的代码需要依赖于内层的策略；相应地内层的部分需要对外层的实现一无所知。所有外层的部分的变化都不应该影响到内层的实现。
图中没有直接描述的还有实际的控制流，依据依赖导致原则，实际运行的控制流和依赖关系是反转的，
存在&lt;strong&gt;从Present和Controller到核心业务规则UseCaseInteractor的控制流&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;humble-object模式&quot;&gt;Humble Object模式&lt;/h3&gt;
&lt;p&gt;上图中的展现层可以细分为Presenter和View两个层次，将距离用户更近的这一层挪到View中，同时放置在View中的部分需要尽量保持简单，以为界面相关的代码是出名的难以测试。
这种做法其实是&lt;a href=&quot;http://xunitpatterns.com/Humble%20Object.html&quot;&gt;Humble Object模式&lt;/a&gt;的一种应用；
该模式可以帮助我们&lt;strong&gt;识别和保护架构的边界&lt;/strong&gt;。它通过将系统的行为拆分为容易测试的部分和不易测试的部分，极大地简化了隔离测试。
这种做法的关键是将难以测试的部分代码加以分解，只留下最基本的简单代码放在外部耦合比较大的模块中，而将比较纯粹的逻辑代码分离出来以便测试。
被&lt;strong&gt;隔离出来的代码其实包含了更少的外围细节&lt;/strong&gt;，在方便测试的同时，模块的边界也变得更加清晰起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://xunitpatterns.com/Humble%20Object.gif&quot; alt=&quot;Humble Object Pattern&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种做法很好地满足了好的软件架构总是易于测试的需要，换句话说&lt;strong&gt;具备可测性是良好的软件架构的一个重要属性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;类似的做法也适用于以下一些场景&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据库隔离层网关，我们不希望我们的业务层代码知晓数据库操作的细节，也希望把SQL操作的细节隔离在外围，那么负责数据库访问的ORM就是同样类似的Humble Object。&lt;/li&gt;
  &lt;li&gt;跨服务传递通信的细节同样也需要用Humble Ojbect来隔离，如何和其它的服务通信一样应该处于本服务的外围。
基本上在系统架构的边界上，Humble Object模式可以得到广泛的应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;部分边界&quot;&gt;部分边界&lt;/h3&gt;
&lt;p&gt;构造完整的模块边界的做法可以保证架构的灵活性和高扩展性；不幸的是这样做带来的额外开销也不小，并经常被敏捷开发专家嘲笑，他们经常用的一个敏捷术语是YAGNIT即你将来也不需要它！
不得不承认很多时候他们说的也对，因为&lt;strong&gt;没有人可以预测到未来的需求，然而作为一个架构师却又不得不如此&lt;/strong&gt;做！
变通的办法是简化这一边界隔离策略，采用&lt;strong&gt;简化版的边界来平衡潜在的扩展性需求和搭建隔离边界的开销&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一种构造部分边界的做法是，准备所有的隔离设施和抽象，但是在&lt;strong&gt;代码组织和部署上并不将他们设置为相互分开的组件&lt;/strong&gt;，
而是将它们暂时糅合在一个组件中。等到时机成熟的时候，再将他们分离开，这时候分离的代价将会很小。
这样的做法只是简化了构建和运维的成本，软件内部的结构仍然保留了良好的抽象和隔离。&lt;/p&gt;

&lt;p&gt;另外一种方法是维护单一维度的边界，即每一个服务都仅仅对服务提供者的实现做接口隔离，而在服务的调用侧，
并不对其它服务的接口做隔离和保护。这样仅仅保证了服务使用者对具体服务实现的隔离。
还有一种做法是采用门面模式讲一个服务的所有方法都放置在一个门面接口下面，这是一种更弱的隔离边界。&lt;/p&gt;

&lt;p&gt;无论采用哪一种部分边界隔离办法，架构师&lt;strong&gt;都需要做到对其中的优缺点心中有数，并且在适当的来决定&lt;/strong&gt;
是否采用部分边界的做法隔离不同的抽象模块，或者是否需要将部分边界升级为完整的边界隔离设施。
具体采用哪种策略对架构师而言是一个巨大的挑战，因为过度设计和抽象不足的代价都是极为高昂的，都会给软件的修改和维护成本带来巨大的挑战。&lt;/p&gt;

&lt;p&gt;合格的软件架构师必须能够审时度势，&lt;strong&gt;根据实际情况的需要，选择合理的抽象级别，既不落入过度设计的窠臼；
也不能掉入抽象不足写的太死的尴尬境地&lt;/strong&gt;。通过自己的智慧和经验做出明智的判断；过犹不及，恰到好处才是最好却又最难做到。
要想明智地做到这一点，很多时候甚至需要猜测和运气。幸运的是这不是一个一次性的决定，架构师可以在决定之后适时观察再谋定而后动。
发现一些地方有过度厚重的边界的时候，及时地简化以提高维护成本；发现其它一些地方的抽象不足也需要及时加重隔离的边界，为后续的扩展留上余地。&lt;/p&gt;

&lt;h3 id=&quot;主模块&quot;&gt;主模块&lt;/h3&gt;

&lt;p&gt;几乎所有的软件系统中，我们都可以看到一个主模块(Main)，无论采用什么样的编程语言或者框架都不例外。
这一模块几乎可以看到所有其它的模块（的边界），这种情况其实是一种正常的现象，因为静态结构的解耦最终反应到代码执行层面，必须有一个地方实现运行期的绑定以便执行真正的控制流运转。
因为我们&lt;strong&gt;抽象设计的一个秘密武器依赖倒置实现的秘诀就是控制流反转；所以主模块必须有非常严重的耦合不可&lt;/strong&gt;，
所以主模块必须作为一个特例并且是唯一的特例而存在。&lt;/p&gt;

&lt;p&gt;主模块其实承担了串起所有整洁架构中的抽象模块的重任，它做的是所有的脏活累活，所以将其看做是插件式架构中的一个无关紧要的插件即可。
它完成的任务正是加载外围的给定的配置和其它输入和输出设施，启动模块的主控制逻辑，然后使得整个系统按照预设的组合运转起来。&lt;/p&gt;

&lt;h3 id=&quot;测试边界&quot;&gt;测试边界&lt;/h3&gt;

&lt;p&gt;整洁的软件架构中，测试必须是架构的一部分，它是保证软件系统能够以低成本运作和维护的重要设施，所以测试也需要一个清晰的边界。
模块的设计必须要要保证考虑到可测性，&lt;strong&gt;需要避免在测试中引入一些昂贵的测试依赖和耦合&lt;/strong&gt;，比如界面的细节，
安全设施的依赖等。本质上来说，测试都依赖于非常具体的细节，所以从架构环的角度考虑，可以认为测试位于最外层的一环。
采用的手法和上面构建边界的方法类似，可以用API接口的方式提高模块或者组件的可测试性。&lt;/p&gt;

&lt;p&gt;测试的设计必须要作为软件架构设计的一个部分仔细考虑，没有加以详细考虑的测试组件必然因为过度脆弱、难以维护而逐渐被抛弃，
最终软件系统本身的维护成本反而会大幅增加而招致项目的失败。&lt;/p&gt;

&lt;h3 id=&quot;嵌入式系统架构&quot;&gt;嵌入式系统架构&lt;/h3&gt;

&lt;p&gt;嵌入式系统经常被当做一个非常特殊的存在，因为这一领域的软件总是显得和其它计算平台的软件差异巨大；因此是否可以套用上面的整洁架构技术是个值得思考的问题。
Bob大叔则旗帜鲜明地指出&lt;strong&gt;嵌入式架构本质上没有太大的特别之处&lt;/strong&gt;，即便这个领域有它自身的特别之处，这主要是因为嵌入式软件环境必须估计到它特殊的硬件、固件环境和形形色色的定制行为。&lt;/p&gt;

&lt;p&gt;作者认为从架构设计的角度来说，嵌入式软件的设计者们需要多多向外部的世界学习软件抽象和架构设计的智慧，做好良好的硬件和固件层封装是至关重要的，
考虑好上面的那些结构设计原则，总是将固件和硬件相关的部分隔离开，使得大部分核心的软件系统总是可测试的，
才能提高程序员的效率，降低改动和维护的成本：这在嵌入式开发中是一笔很大的开销，不能脱离具体固件环境的开发和测试的嵌入式开发成本是极度高昂的。&lt;/p&gt;

&lt;h2 id=&quot;总结和回顾&quot;&gt;总结和回顾&lt;/h2&gt;
&lt;p&gt;作为一个具有几十年开发经验的领域老兵，BoB大叔的软件开发生涯比我自己的声明还要长。在这样一本以文字为主的讲方法论的书中，他穿插了很多他所见到的、听到的、成功的或者失败的故事；
每一个故事背后都有很深的教训和经验值得人们深思和学习。计算机行业本身都是一个很新的行业，
更不要提专业的大规模软件开发的历史更加短暂；计算机世界里，
解决一个&lt;strong&gt;复杂问题的最本质方法之一就是分而治之&lt;/strong&gt;；很多复杂的问题的解决之道都不过是添加一些新的抽象。
这些简单的思想背后却蕴藏着巨大的威力，这一巨大的威力背后也不竟然带来巨大的风险，运用不当又很容易造成过犹不及而伤及自身。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;软件开发本身又不单单是一个纯粹的技术问题&lt;/strong&gt;，因为对绝大部分商业软件来说，我们需要考虑它的建造、维护和变更的成本。
很多时候我们面对的是一个需要维护很长时间的软件，它从&lt;strong&gt;被创建之日起，就肩负着可以被不断修改完善以便重用&lt;/strong&gt;的使命。
人们很少有奢侈的机会去重头开始写一切需要的东西，因为这样做往往无法实现软件所承载的商业价值。
软件架构师之所以要努力搭建这些不时被嘲笑是“叠床架屋”的复杂设计，其实也不过是希望有朝一日某些部分需要被修改的时候，付出的代价要小一些。
忽视这些代价而只顾一时之快的经验不足的程序员们，很难避免以后自己也踏入“以使后人而复笑后人也”的境地。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="language" /><category term="architecture" /><category term="pattern" /><category term="engineering" /><summary type="html">不经意发现Bob大叔出版了新书，延续之前的命名风格定名为《Clean Architecture》，英文版已经于2017年底正式上市； 刚好公司的账户可以访问Orielly公司的在线书城，于是就断断续续地读了起来。 Bob大叔讲故事的能力即使在久负盛名的技术作家圈里面也是闪耀出众的，可以算作是高手中的高手，行文由浅入深层层递进，可读性一向很好，这本书读起来也不例外。</summary></entry><entry><title type="html">Rust2018版：生产力提升的开始</title><link href="https://skyscribe.github.io/post/2019/01/19/rust-2018-edition-overview/" rel="alternate" type="text/html" title="Rust2018版：生产力提升的开始" /><published>2019-01-19T00:00:00+08:00</published><updated>2019-01-19T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/01/19/rust-2018-edition-overview</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/01/19/rust-2018-edition-overview/">&lt;p&gt;不同于传统的工业标准的C++/Java语言缓慢的更新节奏（最近几年大家都加快了演进的节奏），Rust从一开始就采用了滚动发布的模型，
基本上是按照固定的步伐每个六个星期就会放出来一个新版本，并且从正式发布了1.0开始，最近两年来一直是保持向后兼容的。
社区在2018年初的时候，就约定好会在18年发一个大版本出来，以便对外界宣布语言上面的一些重要变化来引起用户的关注；只是这个选择过程似乎一直难产，
之前一直时不时关注着每个新版本的进展，可惜一直没有等到官方宣布；幸好最终在&lt;strong&gt;接近年底的时候迟到但是没有爽约&lt;/strong&gt;，官方将1.31版本宣布为正式的2018版本。&lt;/p&gt;

&lt;p&gt;这个版本和其它小版本的不同在于，这种年份命名的版本的上一个还要追溯于2015年，所以在设计上有很多预留的考量，并且在工具上也给予了特殊照顾。
&lt;!--more--&gt;
正式的版本是于12月中旬发布的，前面因为时间关系并没有投入多大精力来仔细关注变更和改进之处。好在过了一个月，社区中的介绍文字也多了起来，
可以在读官方文档的基础上，再查引其它作者的解读，并且尝试着按照文档的介绍，改写了自己之前缩写的代码，加深对这些改变的理解。&lt;/p&gt;

&lt;h2 id=&quot;官方介绍&quot;&gt;官方介绍&lt;/h2&gt;

&lt;p&gt;官方社区维护了一个关于年份版本的电子书，是用&lt;a href=&quot;https://rust-lang-nursery.github.io/edition-guide/introduction.html&quot;&gt;GitBook&lt;/a&gt;方式发布在语言项目的页面上，
包含了三个部分的介绍&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;什么是“年份版本”以及它和每六周发布的常规版本的关系&lt;/li&gt;
  &lt;li&gt;每个版本包含了那些内容，目前有２个版本，那么分别有两个章节介绍2015版本和2018版本&lt;/li&gt;
  &lt;li&gt;如何做项目版本的迁移&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;年份版本的意义&quot;&gt;年份版本的意义&lt;/h2&gt;
&lt;p&gt;年份版本的用意其实跟多是出于宣传的需要，相当于软件项目中的里程碑版本；如果没有这样吸引人眼球的打包处理方式，普通的用户可能或觉得无所适从，
因为每六个星期就发布一个版本的方法虽然更加敏捷，不想跟着升级的用户或者新用户就会觉得无所适从，不知道该选择哪个版本做项目。&lt;/p&gt;

&lt;p&gt;年份版本其实是通过将一段时间内发布的语言特性和工具、库等集中起来，用特殊的版本标识符展现出来，&lt;strong&gt;给用户提供一个选择的基准&lt;/strong&gt;。
在这个新版本之前，其实只有一个2015版本，并且被设置为是默认的版本，因而如果抛去默认版本不算，2018版本可以算作是第一个新版本。
从编译器的角度来看，所有在这个编译器版本对应的&lt;strong&gt;小版本被发布之前所提供的语言特性都是可以支持和编译&lt;/strong&gt;的，不同的依赖库也可以用不同的版本编译和链接，都没有问题。&lt;/p&gt;

&lt;p&gt;从兼容性上来说，官方保证了所有的新版本都是后向兼容的，并且有些关键的语言特性也会向后加入到老的版本中。
大部分情况下如果吃不准，总是&lt;strong&gt;用新的版本&lt;/strong&gt;就没错了。&lt;/p&gt;

&lt;p&gt;新版本支持一个新的cargo属性，默认没有设置的情况下，编译器会按照2015版本来解析和编译代码；如果需要使用新版本，需要指定如下的属性&lt;/p&gt;
&lt;div class=&quot;language-toml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;py&quot;&gt;edition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2018&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新版本的改进可以看做两个部分，一个是语言特性上的改进就是纯粹的语言改进，另一个是工具链和生态系统中重要软件和工具的改进。
传统的编程语言版本更新往往只侧重于第一个方面，但是进入最近十几年的软件工程实践表明，一门语言要想维持和发展，
&lt;strong&gt;生态系统中工具的支持是至关重要&lt;/strong&gt;的；Rust社区很明智的仔细考虑了这一趋势，并花了比较大的力气改进程序员的生产效率。&lt;/p&gt;

&lt;h2 id=&quot;rust语言本身的改进&quot;&gt;Rust语言本身的改进&lt;/h2&gt;

&lt;p&gt;语言特性本身的改进比较多，大的特性方面主要包括如下几个&lt;/p&gt;

&lt;h3 id=&quot;非作用域生命周期-nll&quot;&gt;非作用域生命周期 (NLL)&lt;/h3&gt;

&lt;p&gt;这个特性其实主要是用于解决&lt;strong&gt;变量访问的引用检查过于严格&lt;/strong&gt;引起的”误杀”的问题，提高引用检查的智能化水平，
使一些人眼看起来完全没有问题的代码，也可以被编译器正确识别而编译通过，在不损失正确性的前提下，减少程序员取悦编译器的不方便之处，&lt;strong&gt;减少程序员的心智负担&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;具体来说，在老的语言版本中，下面的代码将无法通过编译器的引用声明周期检查&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//y not used any more&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;失败的原因在于，编译器的生存周期检查是和作用域绑定在一起的；在函数第二行的时候，我们声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;是前面可变变量的一个不可变引用，
编译器认为从这一行开始到当前作用域结束（这里是函数作用域，靠大括号约束）前，这个不可变引用总是存在的。
因而在&lt;strong&gt;作用域没有结束之前，编译器又发现了对同一个变量的一个可变的引用&lt;/strong&gt;，那么编译器无法放置潜在的访问冲突，为了保证安全，编译器选择不让代码编译通过。&lt;/p&gt;

&lt;p&gt;事实上，写代码的程序员却很清楚，这里的y已经不再使用了，因此再声明一个新的可变引用是没有问题的。
因为编译器不知道，在老版本的编译环境中，程序员&lt;strong&gt;不得不想办法创建一个临时的作用域&lt;/strong&gt;，绕过这个问题&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//y not used any more, out of scope here&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对用户而言，这是一个比较麻烦的心智负担，新版本通过让编译器变得更聪明，来自动检测这一情况，
自动判断这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;两个引用是进水不犯河水的，编译仍然可以畅通无阻。&lt;/p&gt;

&lt;p&gt;如果用户犯了错误，在新的可变引用之后，还想重新使用前面的不可变引用，那么编译器依然会正确的拦截这一做法，
并且给出的编译错误也会更加直观一些，&lt;strong&gt;直接了当的告诉用户&lt;/strong&gt;，两个引用冲突的点在于实际产生冲突的地方，
而不会像老版本一样给出相对混淆一些的标记于作用域结束处的错误信息。这样便极大地降低了新用户学习的门槛，
即使他们没有完全掌握引用检查的原理和机制，也可以按照编译器的指示讲代码修改正确。&lt;/p&gt;

&lt;p&gt;基于这个改进对用户的影响实在太大，同样的改进也会在后续加入到2015版本中。&lt;/p&gt;

&lt;h3 id=&quot;减少不必要的重复&quot;&gt;减少不必要的&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;重复&lt;/h3&gt;

&lt;p&gt;这个主要是用于清理宏中的复杂的样板代码，比如如下的宏定义因为第二个表达式部分是可选的，必须重复地写成复杂的形式&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;allow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused_variables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;macro_rules!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a:ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b:expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a:ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//similar like above&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新版本力争优化这一重复，通过可选部分的 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(...)?&lt;/code&gt; 结构，让宏的设计者可以写出&lt;strong&gt;更干净&lt;/strong&gt;的代码&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;allow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused_variables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;macro_rules!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a:ident&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b:expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不过宏的部分目前被很多人认为是语言设计中不太成熟的部分，不管写的很啰嗦，理解起来也很不直观，
距离成熟还有不断的路程要走；且看后面会怎样进一步发展。&lt;/p&gt;

&lt;h3 id=&quot;模块系统和库路径的简化&quot;&gt;模块系统和库路径的简化&lt;/h3&gt;

&lt;p&gt;模块系统是Rust里面比较让新手感觉迷惑的一块知识；虽然它的基本规则还是比较清晰和直观的，
但是当多个复杂的概念混合在一起的时候，滋生出来的一些&lt;strong&gt;复杂的情况却往往违反人的直觉&lt;/strong&gt;，
这一块明显会成为新手学习的”拦路虎”，使很多人忘而退却。
新版本通过引入一些小的变化来放松一些死板的规则带来的约束，宁可让编译器处理稍微复杂一点，对用户的要求更宽松一些，降低使用的门槛。&lt;/p&gt;

&lt;p&gt;主要的变化在于&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;删除了大部分强制的&lt;code class=&quot;highlighter-rouge&quot;&gt;extern crate&lt;/code&gt;声明，大部分情况下，只要在配置文件中引入了依赖的模块，代码里面就可以直接使用了，不用再啰嗦地声明一大堆的&lt;code class=&quot;highlighter-rouge&quot;&gt;extern crate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crate&lt;/code&gt;关键字指向当前的模块&lt;/li&gt;
  &lt;li&gt;用&lt;strong&gt;模块名来标记其它引用模块的绝对路径&lt;/strong&gt;，而用｀crate`来标记当前模块&lt;/li&gt;
  &lt;li&gt;模块嵌套子模块的情况下，同名文件夹和文件夹名字命名的模块声明文件可以同时存在，不需要在文件夹下面再专门声明一个&lt;code class=&quot;highlighter-rouge&quot;&gt;mod.rs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;去除臃肿的外部模块声明&quot;&gt;去除臃肿的外部模块声明&lt;/h4&gt;
&lt;p&gt;第一个改动非常直观，原来版本中繁琐而笨拙的一大堆&lt;code class=&quot;highlighter-rouge&quot;&gt;extern crate xxx&lt;/code&gt;可以全部删掉了，留下&lt;code class=&quot;highlighter-rouge&quot;&gt;use xxx::yyy&lt;/code&gt;;
这里有两个例外情况,对应于系统模块中的&lt;code class=&quot;highlighter-rouge&quot;&gt;crates&lt;/code&gt;，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;core&lt;/code&gt;这两个模块；
前者已经被编译器默认当做隐式包含而用户不需要指定（否则可以设想代码会变得臃肿不堪），而&lt;code class=&quot;highlighter-rouge&quot;&gt;core&lt;/code&gt;模块大部分情况下也不会用到。
还有一个例外情况是&lt;code class=&quot;highlighter-rouge&quot;&gt;proc_macro&lt;/code&gt;的使用，显然&lt;strong&gt;这些都是非常罕见&lt;/strong&gt;的情况。&lt;/p&gt;

&lt;h4 id=&quot;模块和路径&quot;&gt;模块和路径&lt;/h4&gt;

&lt;p&gt;对于复杂的库实现来说，为了封装内部的细节，往往需要借助于子模块嵌套的办法实现更好的逻辑拆分以提高可维护性；
而旧版本的含糊的子模块规则往往会把初学者绕晕，尤其是当某个嵌套很深的子模块需要引用比较靠顶层的模块中的结构或者函数时，
必须将库本身的名字填上来，或者用&lt;code class=&quot;highlighter-rouge&quot;&gt;super::super&lt;/code&gt;这样的方式来绕过&lt;strong&gt;重命名模块名带来的尴尬&lt;/strong&gt;。
新版本通过指定&lt;code class=&quot;highlighter-rouge&quot;&gt;crate&lt;/code&gt;本身总是指向根路径来简化重命名操作带来的代码改动。&lt;/p&gt;

&lt;p&gt;具体来说，假设我们有这样的模块结构&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;＃inside a libary named &lt;span class=&quot;s2&quot;&gt;&quot;mylib&quot;&lt;/span&gt;
lib
|-- top.rs
|-- foo
    |-- funfoo.rs
    |-- bar
        |-- funbar.rs
        |-- sub
            |-- foosub.rs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当我们在最内层的&lt;code class=&quot;highlighter-rouge&quot;&gt;foosub.rs&lt;/code&gt;里面想引用&lt;code class=&quot;highlighter-rouge&quot;&gt;top.rs&lt;/code&gt;里面定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;top_func&lt;/code&gt;,则必须要在代码里面写做&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//inside foosub.rs &lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//old 2015 edition code, need to adapt for module renaming&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mylib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//or use super to indirect, no code change needed for renaming&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而新的语言版本允许我们简单地写作&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;无需啰嗦的modrs&quot;&gt;无需啰嗦的&lt;code class=&quot;highlighter-rouge&quot;&gt;mod.rs&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这个小改进也是一个使用上的简化，更符合人的直觉一点；反过来看，老的版本必须强制程序员在创建子模块的时候，
在文件夹里面添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;modrs&lt;/code&gt;，并且上层目录里面不准有和文件夹同名的源代码文件出现，反而有点麻烦了。
现在可以很愉快地写这样的目录结构了&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.rs&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//same module and rs co-exist!&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.rs&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//no need to put dummy mod.rs here!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;统一的use语法&quot;&gt;统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;语法&lt;/h4&gt;
&lt;p&gt;老版本允许一些含混的&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;声明，尤其是在某些情况下允许声明文件中定义的默写子模块函数，而&lt;strong&gt;新版本统一了&lt;/strong&gt;可以被声明使用的具体类型，只能是如下几者之一&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;正式的模块名字&lt;/li&gt;
  &lt;li&gt;self用来表明是当前文件中的定义&lt;/li&gt;
  &lt;li&gt;super用来指明是上一级文件目录中的子模块的定义&lt;/li&gt;
  &lt;li&gt;crate用来指明是本模块顶层路径下的子模块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此相应的代码变化是&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// use foo::Bar; //valid in 2015 but not valid in 2018&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//must specify top level &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在不引入更多麻烦的情况下，&lt;strong&gt;一致性总是好于过分混乱的简洁&lt;/strong&gt;；这样才能更好的减少用户的心智负担。&lt;/p&gt;

&lt;h3 id=&quot;去除匿名trait类型的参数&quot;&gt;去除匿名&lt;code class=&quot;highlighter-rouge&quot;&gt;trait&lt;/code&gt;类型的参数&lt;/h3&gt;

&lt;p&gt;这个小改动也是为了提高代码的一致性，虽然稍微复杂了一些。具体来说，就是老的版本允许这样写&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;新版本必须给一个参数名字，或者用&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;来代替&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//use _:u8 if not used inside &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;关键字上的改进&quot;&gt;关键字上的改进&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyn&lt;/code&gt;被提升为一个更严格的关键字，而之前的版本中它是一个弱关键字；这意味着编译器会做更多的检查，
确保它没用被使用在不合适的上下文中，如变量和函数声明，结构属性定义，类型参数，生命周期限定，宏，模块等。&lt;/li&gt;
  &lt;li&gt;预留了下面几个关键字，主要原因还是对应的功能没用实现完整，先占着再说
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 用于异步编程的异步函数声明&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; 用于异步等待，和前一个结合支持协程；这方面的机制在很多语言中都支持的比较完善了&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;try&lt;/code&gt; 这方面的处理还不是很成熟，还需要观察后续语言如何进一步演化&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;编译检查改进&quot;&gt;编译检查改进&lt;/h3&gt;

&lt;p&gt;编译器检查列表中新加了２个默认的编译检查，如果不符合则会被编译器标记为拒绝&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;整数字面量越界（向上溢出）检查 -  简单来说，给出的整数值超出了类型所能表达的范围的时候编译器会明确的拒绝；
这会破坏一些从C语言迁移过来的编程习惯，比如把-1赋值给一个无符号８位数，就会被认为是越界。&lt;/li&gt;
  &lt;li&gt;未指明类型信息的裸指针解引用会被明确拒绝，避免一些低级而诡异的错误，使得底层编程更加安全&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大部分日常使用中的程序都不会被上面的２个新的检查影响到。&lt;/p&gt;

&lt;h2 id=&quot;工具的改进&quot;&gt;工具的改进&lt;/h2&gt;

&lt;p&gt;新版本带来了不少新的工具来&lt;strong&gt;提高程序员的生产效率&lt;/strong&gt;；包括官方的打包工具，格式检查，新语言特性风格上的检查
(类似于有名的质量检查工具&lt;code class=&quot;highlighter-rouge&quot;&gt;sonar&lt;/code&gt;),可惜的是不少工具还处于&lt;code class=&quot;highlighter-rouge&quot;&gt;preview&lt;/code&gt;阶段，距离正式推出还需要一些时间。&lt;/p&gt;

&lt;h3 id=&quot;cargo工具&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cargo&lt;/code&gt;工具&lt;/h3&gt;

&lt;p&gt;这一官方的打包和测试工具做了如下的改动&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;多&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;发现机制在用户制定了&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;属性的情况下，还会继续扫描和发现其它的平台架构&lt;/li&gt;
  &lt;li&gt;没有给出&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;属性的情况下，即使代码里面有&lt;code class=&quot;highlighter-rouge&quot;&gt;src/{target_name}.rs&lt;/code&gt;的存在，cargo也不会自动推断对应的路径；这个改动应该是修复一些已有的bug&lt;/li&gt;
  &lt;li&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt;不会再安装于默认的当前路径，如果用户坚持想这么做，那么必须提供“&lt;code class=&quot;highlighter-rouge&quot;&gt;--path .&lt;/code&gt;”参数来显示指定。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;fmt工具&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fmt工具&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;目前自动格式化代码的工具还处于预览阶段，没有放在正式的&lt;code class=&quot;highlighter-rouge&quot;&gt;rustup component&lt;/code&gt;中，需要通过添加&lt;code class=&quot;highlighter-rouge&quot;&gt;-preview&lt;/code&gt;后缀来获取。
看起来&lt;strong&gt;新的编程语言都不约而同地强迫大家用同一种编程风格，减少对编码风格的争吵&lt;/strong&gt;，无疑是比较明智的；
因为绝大部分人一开始在学习一门语言的时候，并没有很强烈的习惯支撑，而编码风格本身又无所谓好坏，
先入为主是个很普遍的现象，减少这方面的无畏的精力消耗，没有什么不好。&lt;/p&gt;

&lt;h3 id=&quot;clippy代码检查工具&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clippy&lt;/code&gt;代码检查工具&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;clippy&lt;/a&gt; 是一个用于Rust的代码质量检查工具，目前也是处于&lt;code class=&quot;highlighter-rouge&quot;&gt;preview&lt;/code&gt;阶段，
尤其是Windows上需要加&lt;code class=&quot;highlighter-rouge&quot;&gt;preview&lt;/code&gt;才可以下载使用。它本身已经提供了超过290个检查项，
对于每个失败的检查项，它还会提供链接告诉你应该怎么去修改，不少检查是基于对语言更深入的理解才能做到的，
因此运行的时候需要先编译项目的代码。&lt;/p&gt;

&lt;p&gt;clippy自己定义了一些检查集供用户选择，包括&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;style 检查会检查是否遵循语言本身定义的一些惯用法&lt;/li&gt;
  &lt;li&gt;complexity 则检查是否代码的复杂度可以降低却用了一些难以理解的代码&lt;/li&gt;
  &lt;li&gt;perf 检查判断是否代码可以使用更为高效的方式来实现&lt;/li&gt;
  &lt;li&gt;correctness 检查代码的行为是否总是正确的,其中如果发现无用的代码也会给出警告&lt;/li&gt;
  &lt;li&gt;cargo 附带检查项目的cargo声明文件是否符合规范&lt;/li&gt;
  &lt;li&gt;nursery开启一些尚未稳定下的检查项&lt;/li&gt;
  &lt;li&gt;pedantic模式会开启所有的检查项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目本身配置通过&lt;code class=&quot;highlighter-rouge&quot;&gt;clippy.toml&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;.clippy.toml&lt;/code&gt;来指定具体的开关，打开哪些检查项，配置复杂度阈值，
设置黑名单等功能。用户也可以通过相应的代码属性，加入&lt;code class=&quot;highlighter-rouge&quot;&gt;allow/deny/warn&lt;/code&gt;宏的方式，按需开启或者跳过某段代码的检查。&lt;/p&gt;

&lt;p&gt;该项目的文档可以从&lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&quot;一点遗憾&quot;&gt;一点遗憾&lt;/h2&gt;
&lt;p&gt;新的2018版本带来的改动不光有语言特性上的增强，还有侧重于生产率方面的工具增强和一致性改进。
略微有些美中不足的是，异步编程和协程的支持还没有很完备，不得不通过预留关键字的做法留待后续版本继续解决。&lt;/p&gt;

&lt;p&gt;另外一个没有提到的方面是关于Windows上工具链的支持和某些大的IDE工具对Nightly版本的依赖。
尤其是RLS/Racer这两个比较重要的工具时不时会出现循环的重启，还必须依赖于Nightly版本，继续社区加大bug改进力度，早日加到文档版本中去。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="language" /><category term="rust" /><category term="tools" /><summary type="html">不同于传统的工业标准的C++/Java语言缓慢的更新节奏（最近几年大家都加快了演进的节奏），Rust从一开始就采用了滚动发布的模型， 基本上是按照固定的步伐每个六个星期就会放出来一个新版本，并且从正式发布了1.0开始，最近两年来一直是保持向后兼容的。 社区在2018年初的时候，就约定好会在18年发一个大版本出来，以便对外界宣布语言上面的一些重要变化来引起用户的关注；只是这个选择过程似乎一直难产， 之前一直时不时关注着每个新版本的进展，可惜一直没有等到官方宣布；幸好最终在接近年底的时候迟到但是没有爽约，官方将1.31版本宣布为正式的2018版本。</summary></entry><entry><title type="html">现代C++语言是否走上了歧路?</title><link href="https://skyscribe.github.io/post/2018/12/30/modern-cpp-reflection/" rel="alternate" type="text/html" title="现代C++语言是否走上了歧路?" /><published>2018-12-30T00:00:00+08:00</published><updated>2018-12-30T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2018/12/30/modern-cpp-reflection</id><content type="html" xml:base="https://skyscribe.github.io/post/2018/12/30/modern-cpp-reflection/">&lt;p&gt;C++标准的演进和推出速度过慢一直被内外社区批评，甚至当第一个21世纪的语言标准终于于2011年发布的时候，标准委员会的人都自嘲说我们是一门计算机语言，所以0x需要用十六进制数表示。
进入了第二个十年之后，社区的老学究们终于决定引入时髦的＂发布火车＂的模型，滚动地推出新的功能，之后新的语言标准总算按照一个大版本一个小版本间杂而出的方式推到了程序员的面前。
只是社区中对于新的语言的发展方向一直有很多不同的声音，最近的一次大规模声讨则是起源于Aras P在&lt;a href=&quot;https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/&quot;&gt;这篇名为哀悼现代C++&lt;/a&gt;的博客文章。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;作者是一位来自Unity的游戏开发程序员，而一般意义上认为C++仍然具有顽强生命力的领域中，游戏开发是很大的一块地盘；因此这篇来自游戏社区的自己人的反思更加惹人注目；
难道是死忠粉都不愿意继续坚持自己的语言宗教信仰而要改换门庭另投明主了吗？仔细阅读了作者的文字，又发现并不是完全这样。&lt;/p&gt;

&lt;h2 id=&quot;作者为什么要挑起这个话题&quot;&gt;作者为什么要挑起这个话题&lt;/h2&gt;

&lt;p&gt;其实作者也是有感于最近的C++20语言标准正式纳入了ranges这个有名的第三方库而发（其实我个人第一次看到这个库的时候也是眼前一亮，可惜这么多年还在语言标准的门外徘徊）。
Ranges库的作者在自己的&lt;a href=&quot;http://ericniebler.com/2018/12/05/standard-ranges/&quot;&gt;博客中&lt;/a&gt;兴奋地告诉大家它的库重要要成为新的2020标准的一部分了，
并且&lt;strong&gt;信心满满地给大家演示了一个具体的例子&lt;/strong&gt;来宣传这个新的特性是如何的激动人心。不料社区众人并不买账，
很多游戏开发圈子的人给出的确是大大的不喜欢，甚至Aras直接引述了他自己写的一篇twitter消息&lt;strong&gt;将不满发泄到了整个现代的语言标准进化方向&lt;/strong&gt;上(
不知道Bjarne老爷子会不会气的跳起来，毕竟他在负责领导标准委员会中的语言演进方向工作小组)，
并直言不讳地说，负责制定语言标准的大佬们实在是走错了方向，没有真正关心一线开发人员的诉求；于是一石激起千层浪，
整个社区都充满了对语言标准委员会掌舵的演进方向的不满。&lt;/p&gt;

&lt;p&gt;撇开很是主观的争论不说，技术方面看，Aras是否太偏激了？&lt;/p&gt;

&lt;h2 id=&quot;作者的痛点&quot;&gt;作者的痛点&lt;/h2&gt;

&lt;p&gt;整篇文章写的比较长，也许是预料到很多人没有耐心仔细读完，作者在开头就简单概括了他所认为的现代语言标准的三宗罪&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;编译时间&lt;/strong&gt;是个非常重要的话题，可惜标准委员会视若不见&lt;/li&gt;
  &lt;li&gt;非优化模式即&lt;strong&gt;调试模式&lt;/strong&gt;下的编译时间尤其恐怖，调试的需求被忽视&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;心智负担&lt;/strong&gt;太重，要想轻松地写出显然正确的程序需要极其细心地推敲才行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;原始的ranges库的例子&quot;&gt;原始的Ranges库的例子&lt;/h3&gt;

&lt;p&gt;既然讨论是因为Eric的Range库而发，作者先详细描述了这个用于计算毕达哥拉斯三元组（也就是勾股定理数）的例子，原文的例子比较长，但是核心的部分还是不难理解的。&lt;/p&gt;

&lt;p&gt;首先是一些简单的匿名函数，因为原作者想用&lt;strong&gt;函数式编程&lt;/strong&gt;的写法来演示他的新库；首先是一个使用了concept约束的&lt;code class=&quot;highlighter-rouge&quot;&gt;for_each&lt;/code&gt;函数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// &quot;for_each&quot; creates a new view by applying a
// transformation to each element in an input
// range, and flattening the resulting range of
// ranges.
// (This uses one syntax for constrained lambdas
// in C++20.)
&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;for_each&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;IndirectUnaryInvocable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indirect_result_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后还需要一个&lt;code class=&quot;highlighter-rouge&quot;&gt;yield_if&lt;/code&gt;函数用于按照给定的条件，生成一个结果出来，还是典型的函数式编程的路子 (这里省略了&lt;code class=&quot;highlighter-rouge&quot;&gt;maybe_view&lt;/code&gt;泛型的定义，可以去原文中翻查)&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// &quot;yield_if&quot; takes a bool and a value and
// returns a view of zero or one elements.
&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yield_if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semiregular&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maybe_view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
             &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maybe_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主体部分则是一个用惰性方法求三元组的代码，输入是一个理论上无限长的整数序列，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;for_each&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;yield_if&lt;/code&gt;的组合调用，过滤出符合条件的所有的三元组，
最终在现实输出的时候，用新的标准库的&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;取前１０个元素打印输出。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Define an infinite range of all the
// Pythagorean triples:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yield_if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;make_tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Display the first 10 triples
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;')'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果熟悉函数式编程的常规范式，会发现这个是一个再简单不过的例子；只是示例代码的实际意义可能显得不大，
毕竟最老式的Ｃ风格代码也还是容易理解的&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printNTriples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d, %d, %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然处于代码可维护性的角度来考虑，新风格的现代C++代码要容易复用并且难出错的多，
因为代码的复杂度大大降低了，逻辑表达式的嵌套也被分散到了各个更小而又基本的组合函数上了。
不过这些因素不是Aras想要讨论的点。&lt;/p&gt;

&lt;h3 id=&quot;编译时间&quot;&gt;编译时间&lt;/h3&gt;
&lt;p&gt;作者很快毕竟了一下两个版本的编译时间，毫无悬念，现代的C++版本完败，而且差距是相当惊人的。
没有用任何模板元泛型编程手段的老C++代码只需要64毫秒就可以编译完毕，得到的可执行文件只要8KB（当然肯定是动态链接了系统库了);
这个还是带调试模式的编译，如果用上所有的优化手段，则编译耗费了71毫秒，并且在１毫秒之内得到了100组输出。&lt;/p&gt;

&lt;p&gt;而原例子中的现代的C++代码则需要用最新的C++17标准编译，在调试模式和正常模式下，
编译时间分别是2920毫秒和3020毫秒，运行时间则相差无几。所以作者得出的结论是，其他方面可能差不多，
性能也没有损失，编译时间却暴涨了几十倍。&lt;/p&gt;

&lt;p&gt;作为一个对比的例子，作者拿出来了一个开源数据库SQLLite的编译时间作为对比，并发现用同样的硬件，
可以在&lt;strong&gt;不到１秒钟的时间内完成SQLLite所有的２２万行Ｃ代码&lt;/strong&gt;的编译，这个差异还是很惊人的。
原因在哪里？无外乎是模板元和泛型的滥用导致庞大的头文件预处理和解析；这个问题在完整的模块化机制被支持之前，没有很好的解决办法。&lt;/p&gt;

&lt;p&gt;回到当前状态的range库，第三个版本的代码&lt;strong&gt;居然有180万行的代码全部包在头文件&lt;/strong&gt;中了，如果谁在自己的头文件中保护了这个库，编译的时候就真的会演变成一场灾难了。
这个抱怨和吐槽的确是稳准而狠，没法简单解决的。&lt;/p&gt;

&lt;h3 id=&quot;调试模式的编译&quot;&gt;调试模式的编译&lt;/h3&gt;

&lt;p&gt;吐槽完绝对的编译时间，作者又对调试模式下差不多的编译时间做起了批判，也许是游戏行业有很轻的需求来调试而没有很多的自动化测试吗？
另外一个第三方的例子来自于&lt;a href=&quot;https://www.youtube.com/watch?v=m1jAgV4ZOhQ&quot;&gt;Optiming OBJ Loader&lt;/a&gt;，里面给出的结论是，尽量&lt;strong&gt;避免使用STL&lt;/strong&gt;，
赤裸裸地打脸标准委员会呀。&lt;/p&gt;

&lt;h3 id=&quot;心智负担&quot;&gt;心智负担&lt;/h3&gt;

&lt;p&gt;这方面作者没有特别仔细的展开，似乎怨愤都集中在了上面的编译时间，并且在解密为什么编译时间那么长的时候，
顺带抱怨了&lt;strong&gt;模板元的滥用&lt;/strong&gt;导致非常复杂的处理规则需要小心谨记。
这方面的讨论其实已经由来已久了，因为社区的主要演进方向本来就是遵循下面的设计哲学&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果可能用库的方式来实现的特性，绝不会动用语言特性来实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一考虑的初衷主要是为了&lt;strong&gt;照顾到规模庞大的遗留代码的历史包袱&lt;/strong&gt;，B.S在他的《C++ 语言的设计与演化》一书中曾经仔细阐明了这个重要的设计原则；
可惜这一考虑毕竟是有些矫枉过正的感觉；一些通过修改语言特性可以更简单实现的现代功能偏偏要通过复杂的宏和模板元来实现，一直被很多感觉不爽的用户口诛笔伐。&lt;/p&gt;

&lt;p&gt;不得不说，后向兼容真的是个勇敢而又艰巨的选择；年轻而又没有历史包袱的程序语言曾经屡屡嘲笑C++语言的复杂，
而真正等到他们变得成熟的时候，
真正面临同样的挑战，早期开天辟地新起炉灶的痛快劲儿马上消失殆尽的时候，才能体会到实际设计的复杂和中间的不得已而为；
很多&lt;strong&gt;设计错误越是想在后期去弥补就越是显得困难&lt;/strong&gt;；而用户总是会喜新厌旧寻找新的让他们感觉舒服的工具和环境。&lt;/p&gt;

&lt;p&gt;当然C++编程语言复杂的多范式支持本身的确也会让人写起代码来畏首畏尾，这方面也没什么可说的。
不过话说回来，从来就没有人要求用户必须熟悉全部的语言特性，才可以投入生产使用；
试图去掌握全部的语言特性的想法必然不能和具有几十年生命的跨度如此大的语言融合的很好。&lt;/p&gt;

&lt;p&gt;社区会如何反应这方面的挑战，是说模块化的提案已经在加速讨论和演进吗，还是说constexpr的增强可以给编译器更多的指示信息来提高编译速度？
毕竟Herb Sutter一直在推动让现代的C++语言往更好使用的方向去走，对面Rust语言遇到的困难和获得的经验，
也许可以被社区的大佬们借鉴。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="language" /><category term="cpp" /><summary type="html">C++标准的演进和推出速度过慢一直被内外社区批评，甚至当第一个21世纪的语言标准终于于2011年发布的时候，标准委员会的人都自嘲说我们是一门计算机语言，所以0x需要用十六进制数表示。 进入了第二个十年之后，社区的老学究们终于决定引入时髦的＂发布火车＂的模型，滚动地推出新的功能，之后新的语言标准总算按照一个大版本一个小版本间杂而出的方式推到了程序员的面前。 只是社区中对于新的语言的发展方向一直有很多不同的声音，最近的一次大规模声讨则是起源于Aras P在这篇名为哀悼现代C++的博客文章。</summary></entry><entry><title type="html">用Rust来辅助报表解析</title><link href="https://skyscribe.github.io/post/2018/12/15/parsing-big-csv-with-rust-serde/" rel="alternate" type="text/html" title="用Rust来辅助报表解析" /><published>2018-12-15T00:00:00+08:00</published><updated>2018-12-15T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2018/12/15/parsing-big-csv-with-rust-serde</id><content type="html" xml:base="https://skyscribe.github.io/post/2018/12/15/parsing-big-csv-with-rust-serde/">&lt;p&gt;最近遇到一个麻烦而繁琐的操作，需要从工作用的缺陷跟踪系统中导出报表，分析其中的一些数据模式，分类整理后用更好的方式整合出来；
本来这类反复重复的零碎工作，如果不是很复杂，依赖于Excel本身的强大的表格计算功能是很容易自动化的(在线系统比较古老仅仅支持ＣＳＶ格式导出)，
只是内部的字段量比较多，并且有很复杂的相互关联，用&lt;strong&gt;脚本来自动化&lt;/strong&gt;是最直接的一个想法。&lt;/p&gt;

&lt;p&gt;刚好今年花了比较多的时间深入学习Rust了，这么这个分析工具可以作为&lt;strong&gt;第二个很好的练手项目&lt;/strong&gt;，
刚好可以用来更深入地研究和体会这门以系统编程和高效率著称的语言。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;主要目标&quot;&gt;主要目标&lt;/h2&gt;
&lt;p&gt;这里想解决的问题主要有几个方面的难点&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据量比较大，单单导出的CSV文件就有30~40MB的文本&lt;/li&gt;
  &lt;li&gt;需要提取的信息毕竟复杂，各个字段之间有很多相关性，需要解析之后做二次处理&lt;/li&gt;
  &lt;li&gt;导出格式毕竟复杂，基本用到了CSV格式文本中的所有高级特性，比如字段内包含分隔符和空行，某些字段可能是空等&lt;/li&gt;
  &lt;li&gt;处理的结果需要再次保存为csv格式的输出，以便结合Excel本身强大的报表功能，展现给最终的目标用户&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的字符串处理任务会非常繁重，因为有些字段包含有自由文本的信息，而需要提取的信息又毕竟散乱，
并没有很好的规律可寻，必须&lt;strong&gt;要有强大的正则表达式引擎&lt;/strong&gt;，否则处理效率必然堪忧。
即便是抛开学习的目的想快速解决问题也很有挑战，因为传统的Unix工具(sed/awk/grep)组合能力虽然很强，却没有很好的&lt;strong&gt;复杂CSV解析&lt;/strong&gt;的能力。&lt;/p&gt;

&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;

&lt;p&gt;处理程序本身的核心逻辑其实是个数据萃取和转换，需要从输入文件中读取原始输入，格式化为记录数据，
然后根据业务特点做过滤、提取、组合和分组，填充为新的记录格式，保存为文件。
大部分的繁琐的地方其实是在细节中，比较&lt;strong&gt;考验Rust语言的表达能力&lt;/strong&gt;，毕竟这是传统的脚本语言的专长，严肃而正经的静态语言实现起来往往是有手脚被束缚的无力感。&lt;/p&gt;

&lt;p&gt;现代的编程语言都在慢慢地往函数式编程的路子上靠拢，因为函数式语言设施更容易写出声明性的代码；
所以换句话说实现好这个工具写出地道的代码的&lt;strong&gt;重要条件还是需要好好熟悉Rust的ＦＰ&lt;/strong&gt;特性。&lt;/p&gt;

&lt;h2 id=&quot;数据数据的解析和处理&quot;&gt;数据数据的解析和处理&lt;/h2&gt;

&lt;p&gt;Rust社区的serde库提供了各种各样常见的文本格式的序列化和反序列化抽象，而&lt;a href=&quot;https://docs.rs/csv/1.0.5/csv/&quot;&gt;CSV&lt;/a&gt;提供了灵活而高效的读写CSV文件的能力，
并且和serde框架无缝融合，简单拉取就可以很简单的使用；虽然serde的文档不是很容易理解，
好在已经有前边使用json的经验，用起来&lt;strong&gt;只要结合直觉和官方文档&lt;/strong&gt;，便没有什么压力。&lt;/p&gt;

&lt;p&gt;稍微有些讨厌的是工具导出的原始CSV包含了可恶的汇总信息，这些信息并不遵循CSV的语法，
需要在解析之前先将这些额外的头去掉，然后再放入csv处理；该额外处理本来用一行shell脚本就可以很简单的完成:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;input.csv | sed &lt;span class=&quot;s2&quot;&gt;&quot;1,7d&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; input_trunct.csv&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;考虑到已经用Rust来写了，就想让这个&lt;strong&gt;工具变得纯粹一些&lt;/strong&gt;(为了学习的目的可以给自己加一些复杂一点的需求也算可以理解的吧)，能在Windows环境直接使用岂不是更好?
并且考虑到原始的文件可能比较大，正儿八经地实现的时候，不自然就加入了个缓冲机制，避免每次运行的时候都要做这个剪切操作，只需要运行起来的时候，判断文件在不在就可以了；
这方面需要用到文件系统访问相关的API，好在这方面Rust的标准库已经提供了(不知道比C++好了多少呢)&lt;/p&gt;

&lt;p&gt;文件的路径需要从输入来，所以用一个结构保存文件名和它对于的缓存文件；&lt;strong&gt;高效的前提来自于减少内存的拷贝&lt;/strong&gt;，所以这里需要用lifetime声明显示地指出这是一个引用&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputFixer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;raw_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;local_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputFixer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputFixer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;InputFixer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;raw_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;local_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}_trunct.csv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.local_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.local_fname&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.fix_and_save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对外提供的处理函数是通过一个基本的缓存文件检查来实现的，如果存在则直接返回，如果不存在，就调用真正的预处理。
真正的处理是通过跳过当前行直到遇到期望的表头而中止，然后将剩余的行拷贝到中间文件中，形成一个没有额外信息的CSV文件&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//Remove extra headlines from reports, save until we found valid header&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fix_and_save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BufWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.local_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.raw_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BufReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;found_header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Problem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;found_header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;outf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;//warn!(&quot;Skip bad line {}&quot;, line);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;info!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Copying remaining bytes...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.fill_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;outf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;info!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;New file created = {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.local_fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.local_fname&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;主要的读写方式是需要按照行来判断和进行，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;BufReader&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;BufWriter&lt;/code&gt;来提高效率，这一实际的数据其实经过了一次按块读取的拷贝，而这里的代码处理不需要任何拷贝。&lt;/p&gt;

&lt;p&gt;实际测试了一下在我的笔记本上，完成30MB的文件处理，可以在300毫秒内完成，效率还算让人满意；当然运行多次后因为磁盘缓存的原因，时间会缩短到100毫秒，基本不会太影响真正的操作了。&lt;/p&gt;

&lt;h2 id=&quot;主处理逻辑&quot;&gt;主处理逻辑&lt;/h2&gt;

&lt;p&gt;借助于Rust丰富的迭代器抽象和函数式风格支持，主处理逻辑可以用很&lt;strong&gt;直观的流式代码风格&lt;/strong&gt;写成&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在上述代码的预处理之后，将输出文件传入到CSV库中，&lt;/li&gt;
  &lt;li&gt;完成反序列化处理，并将反序列化后的记录收集到一个容器中&lt;/li&gt;
  &lt;li&gt;交于后续的解析和处理函数保存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下面的代码，含义基本上都是&lt;strong&gt;声明式而不言自明&lt;/strong&gt;的；稍微有点晦涩的是那个&lt;code class=&quot;highlighter-rouge&quot;&gt;as_mut&lt;/code&gt;转换，完全是因为后面的反序列化解析操作必须要一个可读写的对象才可以&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;analyze&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;info!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Started to parse {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fixer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;InputFixer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fixer&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.fix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;error!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Truncting file failed by {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
                &lt;span class=&quot;n&quot;&gt;rdr&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.deserialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.filter_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ParsedRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse_and_save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.map_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;error!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CSV parsing failed by {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;文本解析工具和流处理工具&quot;&gt;文本解析工具和流处理工具&lt;/h2&gt;

&lt;p&gt;Rust的字符串分由&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;类型和&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;类型两者配合完成，一般在函数参数或者返回传递的过程中，多使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt;类型，并且很多情况下，编译器也可以自动完成从&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;的引用到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt;的转换，
在某些不能自动转换的情况下，可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;as_str()&lt;/code&gt;函数来得到；只要&lt;strong&gt;通过了编译&lt;/strong&gt;(毕竟是举起了编译器驱动开发的大旗)一般就没有什么问题了。&lt;/p&gt;

&lt;p&gt;正则表达式需要对应的&lt;a href=&quot;https://docs.rs/regex/1.1.0/regex/&quot;&gt;regex&lt;/a&gt;库就可以了，使用的是类perl正则表达式语法，
基本的元字符支持的也比较全，借助于语言本身提供的raw string语法，复杂的正则表达式也照样不需要担心可读性；
当然官方文档的建议是最好不要使用不必要复杂的正则表达式，以免影响效率。
同样出于效率的考虑，正则表达式最好要&lt;strong&gt;先编译再使用，并且保证只编译一次&lt;/strong&gt;，考虑封装的情况下，单例模式是最自然的选择；
好在可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;lazy_static&lt;/code&gt;方便地封装。&lt;/p&gt;

&lt;p&gt;考虑到一个字段可能有多个可能的模式需要提取，写出来的代码可能毕竟复杂；借用Rust本身的Option类型封装，
可以用非常具有可读性的代码写出来，这里想从导出的修订历史信息中有导出多条记录，这些记录可能有不同的结构，对于的正则表达式如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//Parsing given R&amp;amp;D information and filter out interested items&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RevisionItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;lazy_static!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_DELIMITER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(, )?(201[789]-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}) &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_STATECHANGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) The state of the problem changed from ([a-zA-Z ]+) [tT]o ([a-zA-Z ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_STATECHANGE_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) State changed from ([a-zA-Z ]+) to ([a-zA-Z ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_TRANSFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) The group in charge changed from ([_A-Z0-9]+) [tT]o ([_A-Z0-9]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_STATE_REOPEN&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) Reopened&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_ATTACHED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) Problem attached to ([^. ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_DETACHED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) Problem detached. The problem report was detached from ([^., ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PATTERN_POSTPONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) ((Postponed)|(Reactivated))&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;里面用小括号括起来的字段是我们想提取的关键信息，可以用连接的方式一次解析几个正则表达式如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;PATTERN_DELIMITER&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.replace_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;format!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{}|&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.filter_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'|'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.split_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()];&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;PATTERN_STATECHANGE&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_STATECHANGE_EX&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()}))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_TRANSFER&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GroupChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()})))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_STATE_REOPEN&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Finalized&quot;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;New&quot;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()})))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_ATTACHED&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Attached&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()})))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_DETACHED&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Detached&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()})))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;PATTERN_POSTPONE&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Postpone&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Postponed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReActivated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RevisionItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
                    &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extra&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;变换处理&quot;&gt;变换处理&lt;/h3&gt;

&lt;p&gt;对于上述解析出来的原始记录，这里需要额外的处理，比如找到这个列表中的第一个组信息，
因为历史记录读进来的顺序是按照时间书序从新到老读取的，我们需要从尾部拿到第一个组变更的信息返回，病需要考虑没有这种记录的可能，
实现代码其实就是对&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;这个抽象类型的操作的组合调用&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;derive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Revisions&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;revisions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RevisionItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Revisions&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_first_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Revisions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mygrp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.revisions&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.filter_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_from_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.nth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.unwrap_or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mygrp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//definition of get_from_group in RevisionItem struct&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_from_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RevisionItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.extra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GroupChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter_map&lt;/code&gt;是个很有用的组合函数，它可以完成过滤和转换的组合功能，并且能够处理&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;函数返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;类型的能力&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;，则原来的元素就会被跳过&lt;/li&gt;
  &lt;li&gt;如果不是&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;，则把内部封装的元素取出作为后续的输入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nth&lt;/code&gt;又是一个毕竟特殊的函数，可以从结果里面取出第N个元素，如果不存在则会返回空，所以起结果本身是个&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;类型；
显然&lt;strong&gt;作为基础的&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;类型已经充斥在标准库的各个角落&lt;/strong&gt;里，同样也只有做到了这样，才能发挥函数式编程的巨大威力。&lt;/p&gt;

&lt;h2 id=&quot;简单的图算法&quot;&gt;简单的图算法&lt;/h2&gt;

&lt;p&gt;稍微复杂的一个处理是需要找出各个记录之间可能存在的关联关系，然后将具有相互关联的记录中，选择一个作为代表性的记录，
而把其它的记录都设置为重复的记录，这个对于实际的报表汇报尤为重要；同时选择的方法需要是可以定制的。
比如记录A关联到了B,C,D,而Ｃ又关联到了D,E;那么最终我们需要从A/B/C/D/E中按照外部传入的算法选择一个作为主记录，
然后其它都作为辅记录。稍微有点复杂的是，因为系统原因，这些&lt;strong&gt;相互关系在原始输入数据中是不对称&lt;/strong&gt;的，
但是简化起见，不考虑这些错误（比如上例中就没有Ｃ到A／Ｂ的记录），认为关联关系是对称的，只要在处理中修复这种错误即可。&lt;/p&gt;

&lt;p&gt;这本来是一个非常典型的图算法，用无向图可以很容易地表示，可惜没有找到很简单的图算法库；
不过用内置的集合结构来实现一个基本的图算法也不难，用两个数据结构，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;就可以实现一个出来；
这里的&lt;strong&gt;复杂性反而是由Rust的borrow checker引入&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;基本的数据结构如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;attached_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachGraph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//A set of nodes that are associated with one given first id&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;components&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为不想实际拷贝数据，所有的结构体都带入了一个外部传入的生命周期参数，以便编译器检查没有数据越界的情况发生；
生命周期的管理是Rust一个比较复杂和高级的特性，官方的指导书里面写的毕竟详细，这里不赘述。
外层的封装函数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接收解析好的数据记录集作为输入&lt;/li&gt;
  &lt;li&gt;外加一个可以作为主记录的集合以便选取主记录&lt;/li&gt;
  &lt;li&gt;返回构造好的图结构
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//Construct a graph to check attach association, returns a graph of attach information as defined above&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_attach_relations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParsedRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                      &lt;span class=&quot;n&quot;&gt;interested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachGraph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
              &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParsedRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.raw.pr_id&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;attached_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.raw.attached_list&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;get_attach_mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要的处理逻辑在内部封装的这个函数里实现,首先是构造输入数据，然后读入所有的记录，把对应的非对称的关联关系自动修复然后放入到对应的哈希映射表中，这里有２个映射表&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一个结构保存两两关联&lt;/li&gt;
  &lt;li&gt;第二个结构则收集传递关系，将所有传递关联的记录放在映射中
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_attach_mapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AttachInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachGraph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttachGraph&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;components&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;//construct attach relation ship mapping&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// A -&amp;gt; B, B -&amp;gt; C, C -&amp;gt; D, E =&amp;gt; A: A, B:A, C:A, D: A, E:E&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.my_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.components&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.contains_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;c&quot;&gt;//borrow mutable here!&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.components&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.components&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.attached_list&lt;/span&gt;
          &lt;span class=&quot;nf&quot;&gt;.split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;, &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;nf&quot;&gt;.filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.components&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上面这些输入数据，再考虑如何选取主记录，将所有的非主记录的索引都替换为符合条件的一个主记录；
因为默认情况下记录无法修改，这里用一个新的结构来替换和插入，然后在最后的地方重新绑定；因为是浅拷贝所以虽然有效率损耗，影响应该不大；
这本身也是函数式编程的一个无法忽视的问题。&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_mapping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.components&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)|&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interested&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.nth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.unwrap_or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;attached&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;new_mapping&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.mapping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;效率和打包&quot;&gt;效率和打包&lt;/h2&gt;

&lt;p&gt;最终在&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;模式下处理数据总共耗时不到900毫秒，考虑有缓存的话，多运行几次还可以更短，已经远远超出我的预料了。在大量正则表达式处理的情况下，即使是几千条记录的数据量，
因为很长的文本字段可能包好多个列表字段，需要几个正则表达式依次解析，即使是不考虑输入文件的复杂性，
用传统的Unix工具也未必能达到这么好的性能，即便是Perl/Sed/Awk的正则表达式实现的非常高效。&lt;/p&gt;

&lt;p&gt;另外一个考虑的因素是如何共享最终编译好的程序给别人使用，本来考虑的是让别人安装VC++ Redistribute Tools然后试验了一下发现太繁琐了；
于是想查找是否可以静态编译所有以来的方法，幸好这里以来的主要是微软的Ｃ运行时库，&lt;code class=&quot;highlighter-rouge&quot;&gt;Cargo&lt;/code&gt;工具链已经提供了很好的封装；
只需要在工程目录下放置一个特殊的配置文件 (&lt;code class=&quot;highlighter-rouge&quot;&gt;.cargo/config&lt;/code&gt;)，告诉工具链需要静态编辑即可，里面的内容为&lt;/p&gt;
&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;[target.x86_64-pc-windows-msvc]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;rustflags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;[&quot;-Ctarget-feature=+crt-static&quot;]&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;[target.i686-pc-windows-msvc]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;rustflags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;[&quot;-Ctarget-feature=+crt-static&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外看到Rust语言社区的第二个大版本已经出来了，以后可以再花时间琢磨一下里面有什么重大更新，毕竟目前用的版本还比官方的Rust2018早一个版本。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="language" /><category term="rust" /><category term="tools" /><summary type="html">最近遇到一个麻烦而繁琐的操作，需要从工作用的缺陷跟踪系统中导出报表，分析其中的一些数据模式，分类整理后用更好的方式整合出来； 本来这类反复重复的零碎工作，如果不是很复杂，依赖于Excel本身的强大的表格计算功能是很容易自动化的(在线系统比较古老仅仅支持ＣＳＶ格式导出)， 只是内部的字段量比较多，并且有很复杂的相互关联，用脚本来自动化是最直接的一个想法。</summary></entry><entry><title type="html">用Rust实现一个高效的REST解析工具</title><link href="https://skyscribe.github.io/post/2018/09/23/rust-parsing-jira-tickets/" rel="alternate" type="text/html" title="用Rust实现一个高效的REST解析工具" /><published>2018-09-23T00:00:00+08:00</published><updated>2018-09-23T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2018/09/23/rust-parsing-jira-tickets</id><content type="html" xml:base="https://skyscribe.github.io/post/2018/09/23/rust-parsing-jira-tickets/">&lt;p&gt;公司里面进来切换到了一个新的Backlog管理工具来管理日常的需求和项目规划，可惜新的工具虽然是名门之秀的JIRA（来自于澳大利亚的ＩＴ公司confluence），但是访问起来却异常痛苦，
经常一个页面打开需要等待大半天还是不是崩溃。有些心急的同时已经默默地回到了老的方式，导出数据到Excel然后打开Office工具来搞定。
作为一名程序员，最简单直接的想法就是&lt;strong&gt;自己撸起袖子来写代码解决&lt;/strong&gt;呗，即使是投入产出比不高，好歹是在写工具的过程中提高了自己，一举多得何乐而不为呢？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;之前用各种Shell/Awk/Sed/Grep等传统的脚本语言实现了太多类似的解析工具，这里不想再重复自己，因为耍自己熟悉的套路还有点浪费时间和生命的感觉。
简单翻阅了一下JIRADC的RESTAPI文档，发现它的API设计的还是比较完备的，当然也意味着&lt;strong&gt;解析的任务比较繁重&lt;/strong&gt;，除了解析基本的JSON文档，还要处理多个记录的分页。
考虑到服务器用浏览器打开都经常慢或者超时，那么最好也要能实现并发的请求和处理。这么多的需求考虑下来，其实传统的脚本语言的确有些勉为其难了。
当然还可以考虑被称为完成胶水的python语言，只是这么大的数据量和多并发处理，想想也挺繁琐的，况且还没有新鲜感，这个也是很重要的。&lt;/p&gt;

&lt;p&gt;于是便想到了之前每次学一半就因为太无聊而放弃的Rust语言；之前是因为只顾着读文档，走马观花地读，到了中间就读不下去了，因为&lt;strong&gt;之前太多的概念没有动手实践，总会很容易就卡壳&lt;/strong&gt;；
而Rust毕竟是被成为学习曲线很陡峭的严肃的编程语言。说不定这次可以进步更多呢，毕竟这次可是带着目标的去深入学习的，很多大师们都分享过这一绝招&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;深入学习一门语言还是要带着实际的项目去编码，才会更有效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然这些项目大多是一些私人的小项目，这里正当其时。当然我想拉取的是服务器上数千人的数据，那么数据量本身也是很大的；
这方面Rust语言本身的运行效率也是我想观察和思考的一个方面。
起码从它的实际目标来看，作为一门面向系统编程领域并追求和C++一样的&lt;strong&gt;零成本抽象&lt;/strong&gt;设计目标的Rust语言来说，用来实现高效的文本解析工作也不应该有什么难度。&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;主要的需求就是字符串解析，而且是需要解析RESTAPI中的结构化数据，并按照自己的需要来分析和处理数据。
基本的HTTP协议解析和JSON处理是必然少不得的；这方面只要按照官方文档，准备好对应的cargo文件即可，一个命令就可以拉下来所有需要的第三方包的最新版本，这方面比C++进步太多了，那边厢module的提案还在遥不可及的草案讨论中呢。&lt;/p&gt;

&lt;h3 id=&quot;异步编程处理&quot;&gt;异步编程处理&lt;/h3&gt;

&lt;p&gt;因为需要处理服务器响应慢的问题，初步估算程序运行的瓶颈应该在IO，毕竟这可是一门系统编程语言，
就那么几千条文本数据的反序列化和查询变换，应该是可以在几百毫秒级别的运算中完成的。
因此程序的设计上必然要用到多线程处理和异步编程，可惜Rust对协程的支持还没有完善，也没什么大问题，启动多个线程来做就可以了。
这方面&lt;strong&gt;Tokio库是当之无愧的王者&lt;/strong&gt;，直接拉下来用就好了，官方的crate文档写的不错，例子也很简单易懂，
很多处理和JDK的executor处理很像似，即使不读文档，&lt;strong&gt;很多API望文生义也可以差不多&lt;/strong&gt;工作。&lt;/p&gt;

&lt;p&gt;使用中发现Tokio其实已经是一个比较大的库，上一次关注它的时候还是个比较简单精致的小工具库；
随着多个版本的迭代和功能的丰富，它在提供对底层的异步操作处理的基础上还增加了上层通信模型的封装，
并提供了它自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;future&lt;/code&gt;实现，这方面和标准库中的类似设施并不完全一致，用的时候不加留意很容易陷入奇怪的编译错误无法自拔。&lt;/p&gt;

&lt;p&gt;考虑到服务器端本身不是很稳定，必须要处理好可能的失败，并且收集成功的查询，并发起对失败查询的重试直到成功为止；
HTTP协议的无状态保证和REST API的分页查询机制，使得我们只要保存查询条件，即可很方便地重试知道成功。
基本的带重试的查询是按照两步查询的思路进行的，第一步先查到总共的记录个数以便决定接下来还有多少个记录待查，
第二步则查询第一页之外的记录。&lt;/p&gt;

&lt;p&gt;出于简化期间，第一次可能的失败没有处理，大致的处理代码如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//Search by given jql and issue fields, and collect all results in one single &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// result, 2-phases based search is used to calculating paging properly.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QueryResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jql&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//first search&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.reset_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;vec!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()])&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.perform_parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.issues&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;error!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First search failed?&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Unexpected ending!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//remaining&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;info!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Got first result now, check remaining by page info!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.reset_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.create_remaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;.perform_parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perform_parallel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QueryResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.pending_jobs&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.finished&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.drain_all_jobs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.collect_all_responses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clean_finished_from_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里采用典型的&lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;结构来交换信息，因为实际的查询处理是放在future里面并行处理的；
这也是Rust Book里面示例给出的方法，&lt;strong&gt;虽然有些麻烦但是肯定不会出错&lt;/strong&gt;。
主要的查询调度是通过&lt;strong&gt;联合所有的子查询并合并为一个组合的future&lt;/strong&gt;来完成的，这是个典型的函数式编程范式的应用句号；
每一个子查询将它自己的标识符和处理结构反馈到消息通道里面返回给调用者。&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drain_all_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QueryResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub_queries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//Drain all pending jobs &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.pending_jobs&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;//query this page&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StatusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nn&quot;&gt;StatusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Ok&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;parse_query_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.ok_or_else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.startAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.startAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender1&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RequestInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.uri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.to_json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guard1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub_fetch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.fetcher&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.query_with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;.map_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
                    &lt;span class=&quot;c&quot;&gt;//TODO: handle exceptions in graceful manner?&lt;/span&gt;
                    &lt;span class=&quot;nd&quot;&gt;warn!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;This job {} has failed by {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.startAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guard1&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qry&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.startAt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; 
                    &lt;span class=&quot;s&quot;&gt;&quot;failed&quot;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_queries&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_queries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;协议解析和数据结构化处理&quot;&gt;协议解析和数据结构化处理&lt;/h3&gt;

&lt;p&gt;HTTP的解析毕竟繁琐，好在&lt;code class=&quot;highlighter-rouge&quot;&gt;hyper&lt;/code&gt;库的功能非常完备，一般能想到的都已经有支持了，
包括proxy的设置，请求响应的封装，都有丰富的API可供调用，直接用起来就行了，倒也没有太多的难点；
唯一稍微让人觉得有些不一致的是它的请求消息的设计采用的是典型的函数式的不可变设计，需要&lt;strong&gt;用一个builder来构建&lt;/strong&gt;，稍微熟悉一下即可。&lt;/p&gt;

&lt;p&gt;REST数据的处理上，有赖于REST本身强大的&lt;code class=&quot;highlighter-rouge&quot;&gt;Trait&lt;/code&gt;抽象支持，即便是没有官方的基于class的多态支持，
基于抽象数据类型的&lt;strong&gt;serde抽象还是提供了强大的代码复用能力&lt;/strong&gt;；形形色色的第三方库只要声明对各种数据类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;serde&lt;/code&gt;支持，
就可以&lt;strong&gt;方便地以非侵入的方式提供&lt;/strong&gt;给用户。只是从语法上，用户需要定义自己的结构体，
并且用头上加注解的方式添加声明让编译器知道该数据可以被放置在对应的数据解析的上下文中。&lt;/p&gt;

&lt;p&gt;Rust自身也默认规定了命名风格，并且对不符合它期望的命名一律报以警告处理；而第三方的API中的数据恰好和这一风格相悖；
好在&lt;code class=&quot;highlighter-rouge&quot;&gt;serde_json&lt;/code&gt;库也支持自己重命名另外一个名字，这样就可以绕开命名风格不一的问题，只是实际写出来的代码可能有些臃肿；
还有一种简单的办法就是告诉编译器下面的名字&lt;strong&gt;不遵循默认的下划线分隔的命名风格&lt;/strong&gt;，没有很强的强迫症或者赶时间的话到时可以务实一点跳过编译器的警告。&lt;/p&gt;

&lt;p&gt;具体的绑定json的查询结果的结构如下&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serde&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serde_json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;serde&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deserialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;serde&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;de&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[derive(Deserialize,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;Clone)]&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;#[allow(non_snake_case,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;dead_code)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QueryResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    
    &lt;span class=&quot;c&quot;&gt;//not used&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxResults&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//total records&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;//actual issue structure&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;#[serde(bound(deserialize&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;T:Deserialize&amp;lt;'de&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;))]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;issues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一个字段稍微有些复杂是因为程序中有多个不同条件的查询，返回的结构可能是不一样的，&lt;code class=&quot;highlighter-rouge&quot;&gt;serde_json&lt;/code&gt;
可以支持&lt;strong&gt;用泛型的方法来定制可扩展的抽象类型&lt;/strong&gt;。内部泛型中指定lifetime的做法在这里显得特别突兀，
但是暂时也没有更优雅的办法，因为出于效率的考虑，默认的Rust数据结构是具有移动语义的，
这里&lt;strong&gt;必须加上对应的生存周期的约束&lt;/strong&gt;，以便编译器可以在编译期间做好安全检查，防止非法的数据访问。&lt;/p&gt;

&lt;h3 id=&quot;结果的处理&quot;&gt;结果的处理&lt;/h3&gt;
&lt;p&gt;解析的结构都放在容器中，用于对取到的结果分析然后提取自己想要的信息，这方面的处理其实倒是平淡无奇，
无非是一些常规的查询和处理；当然由于本身数据是不可变的，用函数式的方法写出来代码更加清晰自然易懂。&lt;/p&gt;

&lt;p&gt;Rust本身提供了丰富的函数式操作类型，并有强大的 &lt;code class=&quot;highlighter-rouge&quot;&gt;iterator&lt;/code&gt;抽象了丰富的操作组合，但是某些稍微复杂一点的处理还是需要不少重复劳动；
&lt;code class=&quot;highlighter-rouge&quot;&gt;itertool&lt;/code&gt;这个工具库提供不少高级的功能；对于熟悉函数式编程的程序员来说，这一高级工具不容错过。比如下面这个是过滤其中某个特定领域的条目病按照某个给定条件分组之后再行统计规划状态的例子&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//check planning status&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;planned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unplanned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub_items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.into_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;area_features&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.binary_search_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cmp_with_prefix_as_equal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.sub_id&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.group_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_system_split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.sub_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;//check if ET planned&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub_items&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.activity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Testing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;planned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;planned&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;unplanned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;not planned!&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;format_args!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Fid = {}, Testing status ={}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf_writer&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.as_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;编译驱动开发&quot;&gt;编译驱动开发&lt;/h2&gt;
&lt;p&gt;其实在官方的指导文档(Rust Book)中，几位布道者就提出了所谓的&lt;strong&gt;编译驱动开发&lt;/strong&gt;的编程实践；一路实践下来果然深有体会;
因为写代码实现的过程中，大部分在其他语言中用来调试的时间都被挪用到了和编译器做斗争的事情上。
一个原因可能是本身对某些第三方库的设计还不是很熟，需要边写代码边阅读它的设计文档，
另一个原因也许是跟Rust语言本身的设计哲学有很大的关系，因为它将编译器的静态检查能力推向了一个极致的地步；
可以说&lt;strong&gt;编译器的检查是极端保守的&lt;/strong&gt;，任何可能造成程序不稳定或者有数据访问冲突或者踩踏的行为，都不会呗编译器放过。
也只有做到了这样，它才可以大胆地保证，绝大部分情况下&lt;strong&gt;只要你的程序通过了编译，那么运行起来也就是没有问题的&lt;/strong&gt;。这种思路在软件工程上不得不说是一个很激进的尝试。&lt;/p&gt;

&lt;p&gt;相比较与传统的Ｃ和C++语言选择相信程序员，还要想尽量贴近硬件，还想要给程序员很多高级的武器以提高生产效率，
最终在实际的大项目中却往往走入难以为继的泥潭；也许Rust提出了&lt;strong&gt;一条更为坚实但是也更为艰难的路&lt;/strong&gt;，有多少程序员可以克服最初的不适应期都是个很大的难题；
尤其是关于生存周期检查的处理非常晦涩难懂，不深入了解它的原理，有可能就会被奇怪的编译错误所吓倒；
而出于性能的考虑，又不好轻易地选择copy数据结构，选择往往未必是那么容易。&lt;/p&gt;

&lt;h2 id=&quot;效率的问题&quot;&gt;效率的问题&lt;/h2&gt;
&lt;p&gt;毫无疑问，效率是一开始学习和思考的出发点之一，最终程序写完了自然要考察一下它的执行效率。
不出意外对于这个简单的小程序而言，数千条数据的解析和处理都可以在几百毫秒内完成；效率还是非常令人满意的。
毕竟没有很好的运行效率的话，这门艰深的语言几乎没有什么存在的价值了；
serde_json库称自己是最快的JSON解析库，还真不是白吹的。&lt;/p&gt;

&lt;p&gt;希望下次再动手写一个工具的时候，还可以再次深入的学习Rust的其它美妙之处。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="language" /><category term="rust" /><summary type="html">公司里面进来切换到了一个新的Backlog管理工具来管理日常的需求和项目规划，可惜新的工具虽然是名门之秀的JIRA（来自于澳大利亚的ＩＴ公司confluence），但是访问起来却异常痛苦， 经常一个页面打开需要等待大半天还是不是崩溃。有些心急的同时已经默默地回到了老的方式，导出数据到Excel然后打开Office工具来搞定。 作为一名程序员，最简单直接的想法就是自己撸起袖子来写代码解决呗，即使是投入产出比不高，好歹是在写工具的过程中提高了自己，一举多得何乐而不为呢？</summary></entry><entry><title type="html">标准化和生产环境就绪的微服务</title><link href="https://skyscribe.github.io/post/2018/05/20/production-ready-microservice/" rel="alternate" type="text/html" title="标准化和生产环境就绪的微服务" /><published>2018-05-20T00:00:00+08:00</published><updated>2018-05-20T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2018/05/20/production-ready-microservice</id><content type="html" xml:base="https://skyscribe.github.io/post/2018/05/20/production-ready-microservice/">&lt;p&gt;微服务作为一种分布式的软件架构风格几乎已经席卷软件开发的各个角落；尽管它从被明确提出之后也很快经历了大量的质疑、批判乃至否定；
然而背后实践这一符合康威定律的简单（将问题分而治之）而又复杂（需要解决服务本身引起的的许多复杂的基础设施问题）的架构风格的组织却与日俱增。
其原因也不过是随着云计算技术的逐步深入，分布式架构成为最简单的选择，因为大部分情况下处于成本的考量，我们更需要水平扩展而不是垂直扩展；
微服务引入过程中的&lt;strong&gt;一些痛点也随着越来越多云原生应用的开源组件的出现而得到缓解&lt;/strong&gt;。尝试将微服务实践标准化以降低实施成本的努力也变得不再是“空中楼阁”了，
走的人多了，必然有些更容易走的”直路”显现出来。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;为什么需要标准化&quot;&gt;为什么需要标准化&lt;/h2&gt;

&lt;p&gt;Susan J.Fowler作为一名来自Uber的站点可靠性工程师(Site Reliability Engineer)见证了Uber自身将其庞大而又复杂的单体API剥离成逾千个微服务的，
并达到超过85%的微服务团队并无配备SRE这一角色也能确保自己的服务运行良好。同时她也见证了微服务团队（尤其是大型微服务架构）中SRE工程师所面临的巨大挑战：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对SRE本身的能力要求是全方位的，他/她必须是包括软件工程、系统工程、软件架构等多个方面的综合性专家&lt;/li&gt;
  &lt;li&gt;在有成百上千个微服务组成的企业应用中，大部分的团队更本不可能拥有SRE的资源；SRE也不太可能熟悉哪怕系统中大部分微服务的关键细节&lt;/li&gt;
  &lt;li&gt;SRE需要对系统整体的可靠性负责，然而任何一个微服务的SLA水平下降都可能带来整个系统的SLA下降；在大多数团队不配备SRE的情况下，
如何保证日常的开发中新引入的功能不会破坏整体的可靠性、可用性和性能的关键指标，或者如何做有效的回归和可靠性测试，并在发现可能的失败情况下，
及早地回退引起整体质量下降的服务代码，都是一个看起来几乎不可能的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Susan希望他们可以找到一种简单而又直接的方法来定义微服务实践的规范程度，即一种简单而又可靠的标准，使得组织中的每一个微服务团队都可以仅仅需要遵循这些标准就可以交付符合SLA要求的服务，
同时还保有微服务架构本身带来的诸如自由选择编程语言、技术栈的优势。这一套标准其实是用一系列检查列表（CheckList)的方式提供，微服务团队在提交自己的实现之前检查这些列表，
确保所有的实现都能满足列表的要求的情况下才将代码引入到生产环境中；这样整个系统的SLA就可以得到保证。&lt;/p&gt;

&lt;h2 id=&quot;基本原则&quot;&gt;基本原则&lt;/h2&gt;

&lt;p&gt;Susan他们给出的标准化微服务的标准大概可以划分到八个大的基本原则之下，每个微服务必须满足&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;稳定&lt;/li&gt;
  &lt;li&gt;可靠&lt;/li&gt;
  &lt;li&gt;可扩展&lt;/li&gt;
  &lt;li&gt;容错&lt;/li&gt;
  &lt;li&gt;性能良好&lt;/li&gt;
  &lt;li&gt;被合理监控&lt;/li&gt;
  &lt;li&gt;有良好的文档&lt;/li&gt;
  &lt;li&gt;容灾就绪&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这些大的原则之下，Susan他们还详细定义了每一个原则里面的详细列表，并要求每一个原则必须是&lt;strong&gt;可以量化&lt;/strong&gt;以方便提供度量结果，
从而可以极大地提高微服务系统的可用性。只有&lt;strong&gt;满足了这里列出的所有的条件&lt;/strong&gt;的微服务，才可以被认为是生产就绪的。&lt;/p&gt;

&lt;h3 id=&quot;微服务生态系统&quot;&gt;微服务生态系统&lt;/h3&gt;

&lt;p&gt;微服务从来都不是孤立从在的，它们被构建、运行和交互的环境就是它们生存的环境；大型的微服务系统的生存环境就像是一大片森林，一个沙漠或者一个大海；
将相关的&lt;strong&gt;整个环境考虑为一个生态系统&lt;/strong&gt;往往更有利于我们采用微服务风格来架构我们的应用系统。&lt;/p&gt;

&lt;p&gt;设计良好的可持续的微服务生态系统往往会尽力用一个基础设施层将底层的细节和上层的微服务应用相隔离开；这样微服务的开发人员可以像开发一个单体应用一样，
使用他们喜欢的技术和编程语言，自己决定服务内部的软件架构；并不需要过多考虑底层基础设施这些细节，比如操作系统、网络、存储等复杂的基础知识。
自然地，将这些基础设施保持地稳定、高效、可扩展并能良好地容错就成为一个非常基本的需求。&lt;/p&gt;

&lt;p&gt;微服务的生态系统可以简单地划分为四个层次，尽管有时候层次之间的界限并不是那么清晰而绝对&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;硬件层&lt;/li&gt;
  &lt;li&gt;通信层&lt;/li&gt;
  &lt;li&gt;软件应用平台&lt;/li&gt;
  &lt;li&gt;微服务层&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最底层的部分是硬件层，它负责处理诸如实际的物理资源，包括真实硬件、网络节点，乃至数据中心的机架、交换机或者SDN网络、存储设备等；这些设施可以是自己搭建的数据中心，
也可以是从其它的云服务商处租赁来，比如AWS EC2、Google GCP、MS Azure等。所有这些相关的细节被硬件层所管理。
硬件之上的操作系统，以及相关的配置，资源隔离和抽象设置，主机层面的日志、监控也需要被这一层统一提供；
具体的系统选择和日志、监控工具可能由企业应用具体的环境来选择决定。
某种意义上可以将这一硬件层看作是云时代的网络操作系统。&lt;/p&gt;

&lt;p&gt;硬件层之上的是通信层；该层本质上参与了上面两层的交互，因为&lt;strong&gt;所有微服务乃至软件应用平台的交互&lt;/strong&gt;都被这一层所处理。
从严格分层的角度来看，似乎这一层有些定义不太良好。幸运的是，基本的要素是清晰的。
它需要处理诸如网络设置、DNS解析、RPC设施、API端点控制、服务发现和注册、负载均衡等微服务底层治理设施。&lt;/p&gt;

&lt;p&gt;作为第三层的软件平台层负责处理所有微服务共享的内部工具、共享的基础服务等。
这一层必须提供整个系统范围内共享的基础应用软件设施，使得微服务团队&lt;strong&gt;不需要自己设计和维护他们自身微服务逻辑之外的复杂基础软件&lt;/strong&gt;；
从而微服务团队可以专注于自身需要实现的业务逻辑，而不是比较底层的软件技术。
设计良好的软件平台需要提供内部开发者共同使用的方便的&lt;strong&gt;内部开发工具,自动化构建和测试平台&lt;/strong&gt;，中心化的自动部署和发布方案，比如一些DevOps工具，自动发布工具，
微服务层面的日志、监控工具等。&lt;/p&gt;

&lt;p&gt;微服务层处于这个生态系统的最上层，主要负责其职责范围内的业务逻辑和API实现，并和底层的硬件、服务治理设施、通用应用软件平台隔离开。
唯一一个没有和下面几层完全隔离的就是微服务自身的配置。一种常见的做法是将所有的微服务的配置都用中心化的方式来管理和控制；然而这在大型的微服务软件中可能带来巨大的问题，
因为当微服务人员需要修改其配置的时候，往往不得不修改其下面几层的文件（因为被中心化托管），由于微服务数量庞大，开发人员往往不知应该改动哪里或者遗漏重要的配置。
这种情况下，更合理的方案是将各个微服务的配置放在自己的代码库中，然后让底层的工具或者平台可以访问这些配置文件。&lt;/p&gt;

&lt;h2 id=&quot;可靠性和稳定性&quot;&gt;可靠性和稳定性&lt;/h2&gt;
&lt;p&gt;微服务架构其实给软件系统的可靠性和稳定性带来的更多的挑战，这些挑战本质上是分布式软件架构内生的矛盾引起的，而我们又没有办法回到单体架构的时代。
从整个生态系统的角度来考虑，任何一个环节、要素的可靠性损失都会传导到相关的上下游，从而使得整个系统的可用性下降。&lt;/p&gt;

&lt;h3 id=&quot;构建稳定而又可靠的微服务的基本原则&quot;&gt;构建稳定而又可靠的微服务的基本原则&lt;/h3&gt;
&lt;p&gt;微服务架构给开发人员引入了巨大的灵活性，并使得快速的功能迭代成为可能。各个微服务团队可以选用他们自己所熟悉的编程语言、库和微观架构，
只要提供定义良好的API接口即可。每个服务的设计和功能特性都可能在随时发生着巨大的变化，因而整个系统中的任何一个微服务因为设计不良或者考虑不周引起的稳定性下降或者可靠性降低，
都会对整个系统的可用性和可靠性带来毁灭性的影响。因此我们天然期望&lt;strong&gt;微服务的任何一次代码的合入都不会引起&lt;/strong&gt;服务的可靠性、可用性水平的下降。&lt;/p&gt;

&lt;p&gt;构建和维护一个可以被称之为稳定而又可靠的微服务，意味着任何一次功能的添加、问题的修复或者代码的重构及演进不会带来整个系统的可靠性和稳定性的降低。
当然变得更好是会更受欢迎的。为了发布和维护可靠的微服务，我们需要保证有良好的开发流程来支持，并且最好有一个标准化的开发周期模型使得&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新功能的开发或者其它原因引入的代码改动&lt;strong&gt;必须经过预先定义的多个阶段的流水线检查&lt;/strong&gt;，确保问题尽可能在早期阶段被发现并及时回滚&lt;/li&gt;
  &lt;li&gt;服务之间的&lt;strong&gt;依赖失效问题可以被尽早发现并阻止&lt;/strong&gt;；一般认为对服务API打版本标签是一种反模式而不值得提倡，因为这样很容易引起沟通不足而导致下游微服务意外失效&lt;/li&gt;
  &lt;li&gt;适当的路由检查、断路器控制应该被继承到通信层上，实现对微服务出错情况下的处理，防止引起系统性的崩溃&lt;/li&gt;
  &lt;li&gt;某个特定的微服务提供的API可以被废弃或者微服务本身失效的情况下，其它的微服务不应该一并失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;稳定而又可靠的微服务开发往往经历如下的开发模型&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一旦开发人员提交代码的改动到仓库中的新分支（git模型），新的自动化构建任务即被创建起来执行，并做好自动化的代码检查和服务内部的测试&lt;/li&gt;
  &lt;li&gt;同时改动的代码需要被仔细的审查和评审，确保可能的问题被及早发现&lt;/li&gt;
  &lt;li&gt;只有当前两步的检查都没有问题的时候，新的代码才会被提交给外部的构建系统中和其它的服务做集成，打包，测试&lt;/li&gt;
  &lt;li&gt;测试通过的包会被同时发送给部署的流水线做持续部署测试和提交到服务对应的仓库中&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;部署流水线&quot;&gt;部署流水线&lt;/h3&gt;

&lt;p&gt;大型系统中的大部分错误通常都被认为是来源于错误的部署。在大型的开发组织中，可能有上百个微服务在按照各自的节奏做设计、开发和维护，
微服务团队之间通常很少有足够好的协调和沟通（因为康威定律决定了跨大型组织的沟通成本是极其高昂）。这种情况下，
任何一个微服务部署了错误的有问题的版本都有可能造成整个系统的停摆。这种情况下，引入复杂而又分阶段的部署流水线则成为保证微服务系统可靠、稳定的必需手段。&lt;/p&gt;

&lt;p&gt;当一个新的微服务版本被发送到部署流水线的时候（紧接着上一节的过程）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;该版本暂时被标记为候选的发布版本，先放置到 Staging 阶段，并运行一系列的测试&lt;/li&gt;
  &lt;li&gt;如果上述测试都通过并觉得没有太大问题，则顺序进入下一个“金丝雀部署”阶段；这里的环境其实是从正在线上运行的微服务生产环境中，
跳出一部分工作负载，让新的候选微服务版本提供服务，并观察是否有异常情况发生&lt;/li&gt;
  &lt;li&gt;如果没有问题，则可以慢慢地按照既定的策略用新的微服务版本逐步替换就的服务版本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任何一个阶段发现问题，则应当必须尽快回滚，基础设施和构建服务必须能快速回溯到出问题的改动，待对应的微服务团队诊断问题进一步修复。
通常情况下，Staging 的测试环境往往和后边两个阶段的环境有比较大的区别。金丝雀发布阶段可以根据服务实例的个数或者API的流量选择重定向一小部分到新的候选服务版本；
譬如5%到10%的生产环境的情况可以被路由到新的服务实例上做处理；一旦发生错误不致于给用户带来很大的困扰，并且的出错的情况下，应该及时终止这一部署回滚到稳定的生产环境版本，
并抓取对应的日志、诊断信息，以便SRE工程师或者具体的微服务团队解决问题，重新发布。&lt;/p&gt;

&lt;h4 id=&quot;staging&quot;&gt;Staging&lt;/h4&gt;
&lt;p&gt;Staging环境的测试虽然往往和生产环境不同，然而也需要尽量保证硬件设置上和生产环境比较接近，只是没有真正的用户流量。
由于资源的限制，在云平台上生产环境可能有数百个微服务的实例来均衡处理实际的负载，而staging环境上实例的数量可能就少得多。
用户请求的流量可以用mock的方法来模拟测试，或者用工具甚至手工测试的方法来验证。它和开发环境的本质不同是，发布到该环境的服务是可以被发布的候选版本。
开发人员&lt;strong&gt;必须用同等的重视程度和优先级来应对staging环境上可能出现的错误&lt;/strong&gt;并及时修复。&lt;/p&gt;

&lt;p&gt;有两种不同的方法来选择和构建Staging环境，一种是Full Staging，这种情况下，staging环境基本上就是生产环境的比例缩小的一个拷贝。
所有的微服务生态系统都被完整的运行，它可以和生产环境共享同样的基础设施、平台等，只是前后端的流量不是来自于真实的用户，
它也会有自己单独的数据库，并且永远不会和生产环境的微服务发生通信和交互。另外一种配置方式被称之为Partial Staging，
这种环境下，Staging和生产环境并没有完全做镜像隔离，即staging环境的微服务（往往是候选版本）可能会和生产环境中的微服务有进行交互，
从而使用生产环境中的下游微服务的API，当然处于数据保护的需要，生产环境中的数据不应该被Partial  Staging的微服务所修改，而只允许读取和访问操作。
由于Partial Staging环境中的候选版本的微服务可能访问生产环境中的服务，测试和配置的时候则需要更加小心一些，以防对生产环境造成比较大的破坏。&lt;/p&gt;

&lt;h4 id=&quot;金丝雀部署&quot;&gt;金丝雀部署&lt;/h4&gt;

&lt;p&gt;金丝雀部署的想法其实是借鉴了以前矿工下矿井的时候的准备不周，由于不确定矿井中的瓦斯含量和氧气含量是否会由于人体无法感知的异常而引起死亡等事故，
矿工们往往会带一只金丝雀下井，金丝雀对环境的敏感程度远远超过人类，如果一氧化碳含量过高，金丝雀就会停止鸣叫从而矿工们便知道井下不安全。
金丝雀部署的策略和旧时矿工们所采用的策略类似，先选择一小部分真实的环境做实验，如果没有异常出现说明可以继续放心部署下去。&lt;/p&gt;

&lt;p&gt;金丝雀部署是&lt;strong&gt;将候选的微服务版本直接放入了生产环境中&lt;/strong&gt;使用(尽管只服务一小部分流量)，因此应该认为它是生产环境部署的一部分。
所有的监控、诊断、日志信息应该和生产环境中的配置完全相同，以便开发人员可以很方便地调试和解决可能出现的问题。如果有异常的情况出现，
自动回滚金丝雀环境也是至关重要的；因为任何的错误都意味着声场环境出了问题。&lt;/p&gt;

&lt;p&gt;另外一个相关的问题是怎么确定一个服务的新候选版本应该在金丝雀部署环境中呆多长时间才可以被放心地放入大规模部署中。
这个其实取决于具体微服务的流量模式和具体的业务逻辑模型，我们需要根据服务的流量模式和业务模型确定一个金丝雀周期时间，
只有活过了事先定义好的周期时间后，对应的候选版本才能进一步部署到生产环境中。&lt;/p&gt;

&lt;h4 id=&quot;生产环境的部署&quot;&gt;生产环境的部署&lt;/h4&gt;

&lt;p&gt;任何一次的构建和发布到部署环境的改动都应该尽力保证做到稳定而可靠。经过前述各个阶段的测试和检查，
最终部署到生产环境的微服务候选版本应该是被充分测试和验证过的，&lt;strong&gt;任何情况下（除非是一些极端危急的情况），都不应该跳过前述的步骤&lt;/strong&gt;而直接放到生产环境中。
最后的部署可以是采用一次性全部部署到所有的实例上的方式，也可以采用更审慎的方式，按照某种预先指定的百分比策略逐步铺开，
比如先部署25%的实例，再慢慢到50%，75%乃至最后完全部署成功。其它的策略也可以按照服务的国家、地区、数据中心、或者混合上述这些策略来部署开来。&lt;/p&gt;

&lt;p&gt;确保上述的开发和部署流水线被正确执行是保证微服务系统稳定、可靠发布和运行的关键，因为只有如此，
才能有把握将可能出现的问题在发布之前被尽可能早地揪出来修复掉，避免破坏生产环境的稳定、可靠运行。
对某些开发者来说，严格遵循上述的周期和流水线可能显得笨拙而缓慢，然而很多情况下，期望一天可以发布数次微服务的变更而又不破坏系统的稳定性和可靠性，
在复杂的大型微服务系统中变得几乎不可能。每隔几个小时就发生变化的微服务很少是稳定而又可靠的。&lt;/p&gt;

&lt;h3 id=&quot;依赖管理&quot;&gt;依赖管理&lt;/h3&gt;
&lt;p&gt;微服务架构的一大设想就是各个微服务团队可以独立地发布和演进他们的微服务；这在理论上没什么问题，现实环境中依赖却无处不在。
从设计上来说，我们可以努力减少服务之间的依赖和耦合，却永远不能一劳永逸地消灭依赖。几乎每一个微服务都有上下游的依赖，
它需要从上游的微服务接收请求，处理返回，并在处理的过程中调用下游的微服务提供的API。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解微服务的上下游依赖，事前仔细的规划和应对可能的依赖失效、错误&lt;/strong&gt;是确保服务可靠、稳定运行的关键要素之一。因为任何上游服务的可用性下降如果没有被正确处理，
都会导致该微服务的可用性（SLA水平 ）大大下降。为了提高可用性，微服务必须对其所依赖的服务做好失效时的应对措施，采取诸如冗余备份、回滚、缓存或可选副本的方式，
以便所依赖的微服务出现失败的时候，&lt;strong&gt;整个系统不至于有单点故障&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了方便规划、跟踪和管理，微服务之间的依赖关系必须被很好地分析、文档化并实时更总变化。任何可能导致微服务系统SLA水平下降的依赖都应该被包含在本微服务的架构图中，
并放在微服务的仪表盘中被实时监控着。有可能的情况下，最好尽可能地自动产生服务实现的依赖关系图，便于跟踪和规划。有了这些东西，
接下来一个关键的步骤就是设置冗备份、缓存等；具体的情况需要依据实际微服务的具体情况而定。一种常用的设置cache的策略是所谓的LRU方法，
即最近使用的数据被放置在一个队列中，当队列满的时候则将最长时间没有使用的数据给删除掉。这种缓存策略也常常被称为防御性缓存。&lt;/p&gt;

&lt;h3 id=&quot;路由和服务发现&quot;&gt;路由和服务发现&lt;/h3&gt;

&lt;p&gt;另外一个保证可靠性和可用性的考虑是需要保证第二层即&lt;strong&gt;微服务生态中的具体的微服务实例之间的通信层总是可靠的&lt;/strong&gt;。
用于保证这一层可靠性的机制即是服务注册、服务发现和负载均衡。为了保证通信的可靠，任何时刻某个服务实例的状态必须是明确知道的，
这就潜在地要求微服务实例的健康检查必须持续地进行，以确保服务请求不会被发送到失效的节点上造成请求失败。
一种最常用的方式是，采用一个特定的和业务通信无关的通道来监控服务状态。被监控的服务最好需要返回一些有明确意义的信息而不仅仅是返回诸如200 OK这样的状态码。&lt;/p&gt;

&lt;p&gt;如果一个服务的状态变得不可用，那么负载均衡就要做好正确的路由重定向，以保后续的请求不会转发给失效的节点。
如果整个微服务实例变得不可用，那么负载均衡则需要确保在问题被修复之前，所有的请求都不会路由给失效的微服务。
然而负载均衡器并不是唯一的选择，在网络没有出现故障单大批微服务返回异常的情况下，断路器该被用来及早地断开微服务调用链路上的尽量靠近上游的节点，防止系统失败蔓延。&lt;/p&gt;

&lt;h3 id=&quot;版本升级和微服务删除&quot;&gt;版本升级和微服务删除&lt;/h3&gt;

&lt;p&gt;旧版本的API需要退出整个系统的情况并不是很少见；如果没有仔细规划和应对该情况，也会引起预料之外的系统稳定性下降。
微服务团队打算废除某些旧版本的API的时候，他们&lt;strong&gt;必须确保没有使用旧版本服务的客户端（下游）遭到波及&lt;/strong&gt;。解决这一问题本身没有很好的技术手段，
可能需要更多依赖于一些社会工程学上的手段，和具体组织的文化、组织结构密切相关。&lt;/p&gt;

&lt;p&gt;典型的流程要求旧版本的微服务用户必须被提早通知到（如果做了很好的微服务架构文档管理则不是什么难事），提供新版本的微服务团队需要告知
原有的客户怎么迁移到新的版本，何时开始彻底废弃老的版本。&lt;strong&gt;在旧版本被废除之前，监控整个系统的状况是至关重要&lt;/strong&gt;的。
删除一个过时的微服务的情况和版本迁移是类似的情况；但是经常被忽视的是，忘记删除一些不再使用的微服务也会降低系统的可靠性和可用性；
需要尽早被监控并在合适的时间尽早退出微服务生态系统。&lt;/p&gt;

&lt;h2 id=&quot;可扩展性和性能&quot;&gt;可扩展性和性能&lt;/h2&gt;

&lt;p&gt;生产环境就绪的微服务&lt;strong&gt;必须要是可扩展并且性能良好&lt;/strong&gt;的。它不但能处理大量的请求和任务，并可以根据需要动态伸缩实际使用的资源，
合理利用云平台基础设施的优势降低商业成本。确保微服务具有良好的可扩展性和性能，需要我们正确理解微服务的定性和定量的扩展因子，
硬件的效率，正确地识别资源限制和使用瓶颈，正确地估计容量和规划流量的动态扩展情况，以及存储的可扩展性和依赖的动态扩展性。&lt;/p&gt;

&lt;h3 id=&quot;保持可扩展和高性能的重要原则&quot;&gt;保持可扩展和高性能的重要原则&lt;/h3&gt;
&lt;p&gt;正确评估大型的分布式微服务架构系统的挑战比传统的单体应用要大得多，不幸的是这是由分布式软件系统和计算机架构的内生复杂性所决定的。
简单来说，你的微服务系统牵扯到的微服务越多，某单个微服务本身的性能和扩展性对整个软件系统的影响就越小 - 这里的关键是我们必须看清全局。
另一方面，在一个增长而活跃的微服务系统中，流量可能在日渐增加，&lt;strong&gt;每一个微服务都必须能够随着系统的规模的增加而良好地扩展&lt;/strong&gt;才不至于使整个系统遭遇性能问题。
对任意一个微服务我们必须对下面的这些信息做到心中有数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定量和定性的增长规模&lt;/li&gt;
  &lt;li&gt;硬件资源的使用效率情况&lt;/li&gt;
  &lt;li&gt;资源瓶颈和需求情况以便合理地做容量规划&lt;/li&gt;
  &lt;li&gt;确保微服务的依赖的下游微服务也能够随着自己很好的扩展&lt;/li&gt;
  &lt;li&gt;流量可以被用可扩展的方式所管理和控制&lt;/li&gt;
  &lt;li&gt;任务和请求可以被高效地处理&lt;/li&gt;
  &lt;li&gt;数据必须被以可扩展的方式所存储&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;增长规模&quot;&gt;增长规模&lt;/h3&gt;
&lt;p&gt;我们需要从来两个方面来分析和理解微服务的增长规模：定量增长规模和定性增长规模；两者同时在分析和规划资源分配的时候起着至关重要的作用。
定性的增长规模可以从对给定微服务在整个微服务生态系统中的重要性和对相应的上层业务逻辑的关键指标的影响上分析的来。
定量的增长规模则需要用可以度量的、定义良好的、定量的数值来确定该微服务具体可以处理多少业务流量。&lt;/p&gt;

&lt;p&gt;定量的指标经常用每秒请求次数（RPS）和每秒查询测试（QPS）来表述。前者经常用来描述微服务本身的API请求规模，后者则更多用于数据访问情况；
很多时候两者是可以互换的。这些指标很重要，但是在失去上下文（即定性指标）的情况下可能就毫无用处。
我们经常可以用负载测试的方式来衡量微服务的定量指标，和历史数据做对照来确定给定的微服务是否满足扩展性需求。&lt;/p&gt;

&lt;p&gt;考虑到&lt;strong&gt;微服务在大的微服务软件生态系统中从来不是单独存在的，我们也需要根据具体的业务逻辑规则来分析定性的增长规模指标&lt;/strong&gt;，这就是定性增长规模的用武之地了。
整个系统的业务逻辑往往是绑定在整个微服务生态系统的，而不仅仅是某一个具体的微服务。微服务团队需要根据业务分析团队传达的高层业务逻辑需要，
分解到自己的微服务的上下游逻辑，然后来确定自己的微服务需要应对什么样的扩展性要求；这些分析必然是模糊的，却和定量指标一样重要。&lt;/p&gt;

&lt;h3 id=&quot;资源有效使用情况和使用瓶颈&quot;&gt;资源有效使用情况和使用瓶颈&lt;/h3&gt;
&lt;p&gt;在一个由很多微服务构成的应用软件系统中，诸如网络、运算节点、存储等资源总是有限而昂贵的。
出于成本和资源利用率最大化的考虑，整个微服务生态系统需要&lt;strong&gt;按照所提供的业务逻辑的重要性对系统中的微服务做好优先级分类&lt;/strong&gt;，
使得优先级更高的微服务总是可以得到更大份额的资源使用。
技术上的挑战则往往来源于上述的微服务生态系统的最底层，诸如是否给某个微服务分配固定的物理资源（成本高但是可靠），或者某些类型的微服务是否可以共享某些资源，
同时微服务可靠性的潜在要求往往需要我们尽可能地隔离同一个微服务的多个实例，以提高物理硬件失效情况下的可用性。&lt;/p&gt;

&lt;p&gt;规划资源分配之前，还需要着重检查的一件事是确定微服务的资源需求情况和使用瓶颈。这些瓶颈可能来源于一些扩展性上随着资源配额的变化而不能很好扩展的具体限制。
资源需求情况是指某个微服务需要多少的物理资源才能顺畅地运行，以便&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有效地处理任务&lt;/li&gt;
  &lt;li&gt;很好地实现水平或者垂直扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最常见的需要识别的需求要素当然是微服务单个实例运行需要的CPU计算资源和RAM。这两者是微服务实现扩展的基本要素。
确定某个微服务的CPU和RAM情况可能会有如下的挑战&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;水平扩展还是垂直扩展&lt;/li&gt;
  &lt;li&gt;扩展的极限在哪里&lt;/li&gt;
  &lt;li&gt;单个服务实例需要处理的业务流量会是怎样的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;资源使用的瓶颈则往往来源于微服务自身设计上的一些限制，这些限制本身会对服务的扩展性产生决定性的影响，从而无法通过添加更多的资源提高任务处理的吞吐率。
这些资源瓶颈可能是来自于基础设施的限制，也可能来自于微服务自身内部架构设计的制约：因为任何软件架构决策都充满了取舍。&lt;/p&gt;

&lt;p&gt;当资源的瓶颈没有办法很好分析和预测的时候，一种好办法是做充分的负载测试。&lt;/p&gt;

&lt;h3 id=&quot;容量规划&quot;&gt;容量规划&lt;/h3&gt;

&lt;p&gt;容量规划用于解决当微服务的实例被提供更多的物理资源的时候，它可以以适当的方式扩展来处理更多的业务工作负载。
要达到这一目标，需要保证&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;资源被有效地使用&lt;/li&gt;
  &lt;li&gt;事先为业务增长做好规划&lt;/li&gt;
  &lt;li&gt;从&lt;strong&gt;一开始就为服务的性能和扩展性做好设计&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为确保微服务系统可以很好地随着业务量的增长很好地利用资源，&lt;strong&gt;需要做好定期的资源规划&lt;/strong&gt;，基本的原则包括&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;事先确定好每一个微服务的资源需求情况&lt;/li&gt;
  &lt;li&gt;将这些需求编制进资源预算中&lt;/li&gt;
  &lt;li&gt;确保对应的硬件被预留好可以处理阶段内的业务增长
做好定期准备的好处是，当业务增长的时候，永远不会出现因为准备不足而造成的服务不稳定或者不可用。反之，
如果微服务系统没有为业务的增长做好合适的准备和规划，带来的服务宕机或者不可用招致的损失回事巨大的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;资源容量规划上的另外一个挑战是，规划时候的认为疏忽或者错误可能引起生产环境上的线上故障从而带来损失。
一种自然的解决之道是，尽可能地将这些过程做成一个自动化的内部资源规划工具，这个工具就可以放在生态系统的第三层中维护，使得所有上层的微服务团队都可以使用来进行试算。&lt;/p&gt;

&lt;h3 id=&quot;依赖服务的扩展性&quot;&gt;依赖服务的扩展性&lt;/h3&gt;
&lt;p&gt;即使一个微服务被细心地设计以方便很好的扩展，如果它所依赖的微服务没法很好地随着业务量的增长来扩展，整个微服务系统依然是无法满足扩展性和性能要求的。
确保某个微服务所依赖的微服务都可以随着业务量的增长而顺利地扩展是确保微服务系统生产环境就绪的重要条件之一。&lt;/p&gt;

&lt;p&gt;微服务依赖链条的可扩展性必须得到满足潜在的意味着我们&lt;strong&gt;必须要保持整个组织的所有微服务都需要采用同样的标准&lt;/strong&gt;。
如果只有核心而又关键的微服务满足高可扩展性，而其他的上下游依赖的微服务不同时满足，则整个微服务系统就无法按照实际业务负载的增长顺利地实现平滑扩展。
除了保持高度的设计标准化之外，微服务团队需要尽力地确保自己所依赖的微服务可以按照自己的要求正常地伸缩扩展。
&lt;strong&gt;跨微服务团队的沟通变得至关重要&lt;/strong&gt;，否则系统的关键扩展性瓶颈就无法及时地识别；某种程度上说，这和微服务架构本身的灵活性是相互制约的。
一种策略是，确保微服务团队之间经常进行架构的评审，并将扩展性的影响和依赖服务的扩展性情况放在微服务架构设计文档中。&lt;/p&gt;

&lt;h3 id=&quot;流量管理&quot;&gt;流量管理&lt;/h3&gt;

&lt;p&gt;微服务系统必须能处理日渐增长的业务流量，并用更为智能的方式管理流量的增长；并保持良好的扩展性和效率。做到这一点需要我们&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据业务的增长规模来&lt;strong&gt;事先预估将来流量的增减&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;流量增减的模式必须被充分分析和理解，并以及做好准备；这样新引入的对微服务的改动如果会引起流量处理模式上的变化可以被预先分析和规划。
服务监控措施也可以顺利跟上，以便在出问题的时候能尽快抓住问题的根源提供快速修复，避免造成业务损失。&lt;/li&gt;
  &lt;li&gt;微服务必须能够处理流量增长过程中可能出现的爆发和流量尖峰。它必须能以可扩展的方式应对可能出现的业务俱增或者骤降，
有效地伸缩使用分配的硬件资源，防止可能的流量洪峰造成整个系统的奔溃。然而这些总是说起来容易作起来难。即使是设计良好的微服务，
即便他们拥有良好的监控、日志措施，一旦出现流量尖峰仍然可能带来系统性的问题。通常来说，这些尖峰应该在基础设施层面做好规划，
并辅以适当的负责测试措施来事先演练可能出现的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常情况下，大型的微服务系统可能跑在跨越多个地区的数据中心上，这些数据中心甚至可能跨越地理上相距甚远的国家。
&lt;strong&gt;数据中心之间的数据通信出现问题&lt;/strong&gt;并不是一个少见的现象；在基础设施层做好流量的分发和路由是一种常见的做法，
当然上层的微服务应用也要做好流量被重定向到其它数据中心的准备；这个过程中系统的可用性还不能降低太多。&lt;/p&gt;

&lt;h3 id=&quot;任务管理&quot;&gt;任务管理&lt;/h3&gt;

&lt;p&gt;任何一个微服务都需要出来来自其上游的某些任务请求，做相应的本地处理或者运算，返回处理响应给请求的发送者。
这个过程中，它可能还要产生新的请求发给其下游的微服务完成自己的处理过程；这里面的每一次处理可以成为一个任务。
线上的微服务系统在任一时刻可能有大量的任务被同时处理，性能和扩展的角度要求我们尽量提高微服务的处理能力以便更有效地使用资源。
有许多制约因素值得考虑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编程语言和对应框架的限制，很多时候多任务处理的能力和微服务本身的编程语言选择密切相关，
因为不同的编程语言可能有自己特色的平台框架来完成任务处理，并发控制，异步调度等纯技术的挑战。
某种程度上说，编程语言的选择是具体微服务设计中的最大的架构决策；这方面需要根据具体微服务的目标和团队背景合理选择，没有一种编程语言适用于所有场景。
当然选择太多的编程语言也会带来巨大的平台支持挑战。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;除了编程语言上的限制，微服务团队在设计自己的服务的时候，也需要用标准化地方式思考他们的架构怎么处理任务，这种处理的效率怎么样，
当更多的请求上来的时候它的处理机制是否容易扩展的问题。为了提高处理能力，任务处理需要支持并发和分区。
并发意味着不能采用单线程的方式一个任务处理完再调度下一个的方式，因为这样会浪费大量的资源并引起竞争和锁开销。
分区则要求我们可以将大的任务拆分成小的颗粒去并行调度和执行，执行完毕之后结果可以高效地合并起来。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据存储的扩展性&quot;&gt;数据存储的扩展性&lt;/h3&gt;

&lt;p&gt;微服务系统中的数据存储访问和管理经常成为性能和扩展的痛点。微服务&lt;strong&gt;怎样设计它的数据分割和扩展往往成为整个微服务系统扩展的一个最大的限制&lt;/strong&gt;因素。
选择正确的数据库系统（不同的微服务可能有不同的选择，完全由业务逻辑的特点决定）在微服务设计中是一个至关复杂的话题。&lt;/p&gt;

&lt;p&gt;仔细审视微服务生态系统的四个层次发现我们可以有两种思路，一种是在平台层将数据库软件作为服务提供给具体的微服务；一种思路是由各个微服务团队自己选择
采用哪种数据库，怎么集成、打包和发布他们的数据库。当然还有一种混合的思路也可以工作良好，即平台层提供数据库服务，
同时允许微服务团队在给定的数据库平台服务不匹配他们的需求的时候，选择他们自己的数据库。&lt;/p&gt;

&lt;p&gt;无论采用哪种方式，微服务团队都需要考虑应该采用关系数据库，还是采用弱结构化的NoSQL数据库；他们的业务扩张的方式是更需要水平扩展增加实例，还是水平扩展分配更多的资源。
一般来说，如果水平扩展的要求比较高，读写需要并行地进行，那么NoSQL可能是更好的选择。&lt;/p&gt;

&lt;p&gt;另外一个麻烦的挑战来源于数据库的测试，尤其是&lt;strong&gt;测试数据的构建、使用和管理&lt;/strong&gt;。
在部署流水线中，staging阶段需要读写真正的数据库，full staging的情况下，测试环境会有自己独立的数据库，所有的测试数据库访问都会和生产环境的数据隔离开了。
而partial stagging的部署情况下，测试可能需要访问生产数据库；这个时候我们需要格外小心确保生产数据库可以正确地区分测试数据不至于被写坏，
并且测试过程中产生的数据可以被定期地清除以免产生不必要的垃圾。&lt;/p&gt;

&lt;h2 id=&quot;容错和容灾演练&quot;&gt;容错和容灾演练&lt;/h2&gt;
&lt;p&gt;生产环境就绪的微服务系统需要保证能在服务出错的情况下仍然可用，并在发生灾难性故障的时候，有恰当的应对措施提供定义好的可用性等级。
这不仅要求微服务系统设计经过仔细的规划，准备好灾难处理，还要求时不时地将某些微服务置于失效的情况下，然后确保它可以正常而优雅地恢复服务。&lt;/p&gt;

&lt;h3 id=&quot;容错处理的基本原则&quot;&gt;容错处理的基本原则&lt;/h3&gt;

&lt;p&gt;在一个由很多个微服务组成的微服务系统中，任何一个可能发生错误的微服务都最终会在某个时间出错。复杂的服务间依赖关系会导致其中一个服务的错误
蔓延到其他相互依赖的服务上，如果处理不当最终会导致整个系统的失效和不可用。唯一的应对措施是，&lt;strong&gt;务必保证系统中的每一个微服务都是&lt;/strong&gt;可容错的并做好容灾准备。&lt;/p&gt;

&lt;p&gt;要想达到上述目标，第一件事情就是需要定位系统中的单点故障并竭力从设计上去除这些单点故障。所谓的单点故障是指，
某个服务（或者其他实体）出现故障的时候，整个系统就会变得不可用。在微服务生态系统中，四个层次中的每一层都可能存在潜在的单点。
有时候并不是系统中的所有单点故障都可以完美地从设计中移除。此时我们需要识别系统中可能的失败场景，并做好应对措施。&lt;/p&gt;

&lt;p&gt;从设计上我们需要做到让微服务可以应对两种可能的错误&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;内部错误，即微服务内部设计上的可能的错误&lt;/li&gt;
  &lt;li&gt;外部错误则包括微服务生态系统上其它层次的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一旦我们移除了单点，并识别到了可能的失败场景，下一件重要的事情是需要验证和测试是否我们的微服务可以在出现错误或者灾难的时候可以从容地从错误中恢复服务；
并因此&lt;strong&gt;确定微服务是否具有足够的弹性&lt;/strong&gt;来应对错误。再好的设计都必须用严格的测试来保证当具体的微服务被置于错误的场景的时候系统是否可以足够从容地恢复。
一种常见的做法是，定期而随机地将生产环境中的某些微服务置于失效的场景（杀死或者关闭某些基础设施），并测试是否系统的正常运行收到影响。&lt;/p&gt;

&lt;p&gt;由于并不是所有的错误和灾难都可以被事前预测，非技术的组织因素也应该被仔细准备。包括错误检测机制和应对策略需要被预先准备并制定好周密的计划；
一旦出现事前未预料到的故障，可以按照事前定义的策略很快地处理以恢复系统服务。&lt;/p&gt;

&lt;h3 id=&quot;避免系统单点故障&quot;&gt;避免系统单点故障&lt;/h3&gt;

&lt;p&gt;理论上说，任何一个微服务从设计上来说都不应该引入单点故障；而现实情况是，很多微服务都会经常性地编程系统的单点。
在系统真正失败的时候识别系统中的微服务单点是很容易的，而事前分析和发现系统的单点则困难得多；当然我们要也能通过坐等单点故障出现来慢慢修复单点。
一种好办法是事先和具体的微服务团队进行服务架构评审，并通过仔细的分析和提问发现潜在的单点。架构师可以和微服务团队的成员在白板前
就该微服务可能的错误场景进行讨论，借此识别可能出现的故障点。一旦识别到这些可能的故障点，要么我们需要从设计上将其从微服务架构中去除，
要么就要设计好应对措施；注意前者并不是总能够做到的。&lt;/p&gt;

&lt;h3 id=&quot;典型错误场景&quot;&gt;典型错误场景&lt;/h3&gt;

&lt;p&gt;识别可能出现的错误或者灾难场景是去除单点故障之后的下一步要做的要紧事。通常我们可以依据微服务生态系统的层次划分，将这些错误和灾难分为四类&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;最常见的错误是硬件的错误或者失效&lt;/li&gt;
  &lt;li&gt;基础设施层（通信基础设施，中间件，网关、路由、服务发现）的故障&lt;/li&gt;
  &lt;li&gt;依赖微服务的失效&lt;/li&gt;
  &lt;li&gt;微服务内部的错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整地列举所有可能的错误场景是不现实的，然而分析一些常见的失效场景却可能是非常有意义的。
这些错误可能和整个组织的文化和行为方式有密切的关系，并会对整个微服务生态系统的可靠性造成巨大的影响。
当然这也是为什么我们需要标准化的微服务实践以便更好地规避这些可能的陷阱。&lt;/p&gt;

&lt;p&gt;第一种常见的错误是缺乏足够的微服务设计和充分的架构分析和讨论，从而使得&lt;strong&gt;服务的设计低劣&lt;/strong&gt;。这在大型的组织中影响格外大需要更加小心留意。
需要避免这种错误的原因也显而易见：没有人可以有能力知道大型系统的所有细节，没有人知道四个层次中所有的关键细节知识。
当新的系统被设计，新的微服务被添加的时候，确保生态系统中的四个层次中的工程师参与设计的评审过程以决定系统或者服务应该怎样构建和运行是是至关重要的。
由于微服务系统的演进速度可能很快，定期的设计评审和文档化以保持架构的新鲜度往往是必须的：死的架构文档是没有意义的。&lt;/p&gt;

&lt;p&gt;第二种场景的错误是缺乏足够充分的代码评审。当然这个问题不是微服务架构独有的，微服务架构的方式却有意无意地放大了这个问题的严重程度。
每个微服务的设计和演进和其他微服务尽量保持解耦这一目标给微服务组织带来了新的挑战。复杂的微服务系统中，要求频繁的上下文切换，更多的汇报或者会议，
管理人员对速度的迷恋都会导致无穷无尽的bug被引入到系统中而没有被恰当的代码评审所发现。我们可以写更多的测试来覆盖可能场景，
增加更多的回归测试条件，确保如果代码bug没有被评审时候发现，那么它也可以在自动化测试或者持续部署流水线中发现。&lt;/p&gt;

&lt;p&gt;另外一种常见的问题来源于部署错误；这可能是前两种常见错误的延伸，比如没有经过仔细设计和评审的包含bug的代码在未经过充分的测试或者良好的持续部署流水线检查即进入生产环境，
往往会带来灾难性的后果造成线上环境事故。构建良好的工程师文化氛围确保&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代码评审可以被认真地对待&lt;/li&gt;
  &lt;li&gt;开发人员有足够的时间来评审他们同事的代码，并尽量在开始的时候就一次将可能做好的事情做对&lt;/li&gt;
  &lt;li&gt;构建稳定、可靠的基础设施和自动化测试环境&lt;/li&gt;
  &lt;li&gt;采纳良好的持续集成和持续部署实践&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;硬件错误&quot;&gt;硬件错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;通信层和平台层错误&quot;&gt;通信层和平台层错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;服务依赖错误&quot;&gt;服务依赖错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;服务内部错误&quot;&gt;服务内部错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;弹性测试&quot;&gt;弹性测试&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;故障检测和修复&quot;&gt;故障检测和修复&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;事故和响应处理&quot;&gt;事故和响应处理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;微服务监控&quot;&gt;微服务监控&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;文档&quot;&gt;文档&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;TBD&lt;/strong&gt;&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="architecture" /><category term="microservice" /><category term="standardization" /><summary type="html">微服务作为一种分布式的软件架构风格几乎已经席卷软件开发的各个角落；尽管它从被明确提出之后也很快经历了大量的质疑、批判乃至否定； 然而背后实践这一符合康威定律的简单（将问题分而治之）而又复杂（需要解决服务本身引起的的许多复杂的基础设施问题）的架构风格的组织却与日俱增。 其原因也不过是随着云计算技术的逐步深入，分布式架构成为最简单的选择，因为大部分情况下处于成本的考量，我们更需要水平扩展而不是垂直扩展； 微服务引入过程中的一些痛点也随着越来越多云原生应用的开源组件的出现而得到缓解。尝试将微服务实践标准化以降低实施成本的努力也变得不再是“空中楼阁”了， 走的人多了，必然有些更容易走的”直路”显现出来。</summary></entry></feed>