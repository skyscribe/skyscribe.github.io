<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://www.skyscribe.me/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.skyscribe.me/" rel="alternate" type="text/html" /><updated>2017-06-30T22:36:21+08:00</updated><id>http://www.skyscribe.me/</id><title type="html">驭风万里无垠</title><subtitle>汇小流以成江海，积跬步以至千里</subtitle><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><entry><title type="html">Excessive null checks in Java Defensive Programming?</title><link href="http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming/" rel="alternate" type="text/html" title="Excessive null checks in Java Defensive Programming?" /><published>2017-06-27T00:00:00+08:00</published><updated>2017-06-27T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/27/excessive-null-checks-in-java-defensive-programming/">&lt;p&gt;最近在参与某开发小组的&lt;a href=&quot;https://atendesigngroup.com/blog/group-code-reviews&quot;&gt;团体代码审查&lt;/a&gt;会的时候，发现组内的一线开发工程师对于何时应该做空指针检查并没有很清晰的认识；然而这在Java社区里早已经是个老生常谈的争论 。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;按照最偷懒的做法 (毕竟&lt;a href=&quot;http://threevirtues.com/&quot;&gt;懒惰是伟大程序员的美德&lt;/a&gt;之一)，可以对使用的对象不做检查，那么万一该指针为空，则运行期抛出的空指针异常&lt;strong&gt;默认行为就会将程序给crash掉&lt;/strong&gt;，你的用户会很不高兴，你公司的客户会不高兴乃至投诉你的研发老板，你的老板会更加不高兴甚至于愤怒以至于半夜将你叫起来加班解决问题；试想当你拖着睡眼惺忪的躯壳爬到办公室查看日志，迷迷糊糊一看，原来是有个地方的对象引用是null指针，没有做判断导致JVM退出了。那么最自然的方案是添加个判断了，原来的代码可能是&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;现在被改成了&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;后边可能出现了新的问题，那么你可能依法炮制，继续加上更多的分支判断。对于简单的代码片段而言这样做没什么问题，足够清晰易懂；只是实际的业务逻辑代码可能布满了各种各样的业务判断，再掺入这类判断代码，&lt;strong&gt;可维护性立刻直线下降&lt;/strong&gt;。这时候可能有个聪明的程序员跳出来说，我们不是有&lt;a href=&quot;https://en.wikipedia.org/wiki/Defensive_programming&quot;&gt;防御性编程&lt;/a&gt;大法吗，可以来的更彻底一些，&lt;strong&gt;干脆对所有的传入对象做空指针检查&lt;/strong&gt;不就可以了吗？&lt;/p&gt;

&lt;p&gt;乍看起来似乎很有道理，转而仔细想一下就会发现这里&lt;strong&gt;有很大的隐患&lt;/strong&gt;。上述的检查其实对每一次对象的调用其&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclomatic_complexity&quot;&gt;复杂度&lt;/a&gt;就会增加1，实际的业务代码里，一个类往往&lt;strong&gt;引用了很多对象&lt;/strong&gt;，每次都要去做判断很快使代码变得难以维护，尤其是考虑到一些稍微复杂一些的方法可能有多个出口的情况，条件判断的增多会直接导致内部状态变得难以分析。本质上对某个方法的实现上下文来说，当前&lt;strong&gt;所有的成员对象和传入的上下文参数对象&lt;/strong&gt;是否为null的状态都需要按照这个策略去来判断，在没有明确的前置条件约束的情况下，具体实现的业务逻辑会被埋藏在各种繁杂的空指针检查中难以理清。&lt;/p&gt;

&lt;p&gt;显然对所有的对象引用做空指针检查不是一个明智的主意。那么是否有什么方法可以减少这些检查或者有其它的提高可读性的变通之道吗？&lt;/p&gt;

&lt;h2 id=&quot;哪些情况需要判断空指针&quot;&gt;哪些情况需要判断空指针&lt;/h2&gt;

&lt;p&gt;为了探讨这个问题，我们可以详细列举一些可能需要判断的情况逐一分析一番就能做到心中有数了。因为Java语言中一切皆是对象(当然基本类型不算)，所有对象都由某个class给构造出来，所以我们&lt;strong&gt;仅仅需要讨论class中涉及到的对象&lt;/strong&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;成员对象-field&quot;&gt;成员对象 (field)&lt;/h3&gt;
&lt;p&gt;一个Java类的基本元素是其成员引用 (其实是对象指针) ，因为从成员对象开始探讨是个不错的主意。Java语言本身允许两种类型的成员对象：&lt;/p&gt;

&lt;h4 id=&quot;在构造中被初始化过的成员对象&quot;&gt;在构造中被初始化过的成员对象&lt;/h4&gt;
&lt;p&gt;构造中初始化的对象，其是否为null指针其实跟该类的设计密切相关，因为构造方法是对象”出生”的地方；其实现直接决定了构造出来的对象的内部状态。这种情况下，对象是否为null是个&lt;strong&gt;比较关键的设计决策&lt;/strong&gt;之一。&lt;/p&gt;

&lt;p&gt;对于这些纯粹是被使用到的对象(即其生存周期不由本class决定)，&lt;strong&gt;只接受合法的构造参数并确保总是生成带有非null引用&lt;/strong&gt;的成员对象，会大大减少类内部需要检查空指针的情况。这样类的职责也很容易做到单一而明确；对应的其它方法里边就无需判断某个成员对象是否为null，当然如果其他的方法中会修改某个成员为null，那么情况会变得复杂 - 当然这种情况下出现的时候，往往意味着某些方法之间在使用成员对象来存储中间状态，很可能这些方法之间的隐式依赖需要仔细分析重构。&lt;/p&gt;

&lt;p&gt;如果构造方法中的传入&lt;strong&gt;参数非法而导致某些成员对象没法被正常构造&lt;/strong&gt;出来，那么我们的确可以采用防御式编程的思路，在构造里抛出来异常即可。当然这里有些Java语言特殊的情况需要仔细考虑，譬如是否需要抛出&lt;strong&gt;待检查异常&lt;/strong&gt;还是非检查异常；并且在抛出异常的时候需要仔细小心留意没有资源泄露的情况，因为Java里没有C++中的RAII的概念，如果抛异常前已经分配的资源没有合适的释放(必须是手动的), 那么&lt;strong&gt;调用者永远也没有办法处理&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;尽管有以上诸多细微之处需要留意，在构造方法中考虑好对象的初始状态约束，是减少不必要的null指针检查的第一步(可能也是非常关键的一步)。&lt;/p&gt;

&lt;h4 id=&quot;没有在构造中初始化的成员对象&quot;&gt;没有在构造中初始化的成员对象&lt;/h4&gt;
&lt;p&gt;没有在构造中初始化的成员对象，可以有几种不同的情况。然而毕竟&lt;strong&gt;不能确保初始化对象的方法在什么时候被调用&lt;/strong&gt;了(除非有合适的设计约束)，因此成员方法中用到该对象的地方，都需要做空指针检查，否则就有可能出现意外的异常。当然详细的分析一下具体的场景也有助于我们做更深入的分析。&lt;/p&gt;

&lt;p&gt;一种常见的典型场景是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法来初始化的对象，从纯粹面向对象设计的角度来考虑，简单的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;方法其实是&lt;strong&gt;破坏封装&lt;/strong&gt;的，应该尽量避免。然而一种合理的情况是希望解决类之间的环形初始化依赖的情况，譬如依赖注入框架中的&lt;code class=&quot;highlighter-rouge&quot;&gt;setter injection&lt;/code&gt;；当然环形依赖的情况之所以出现，往往意味着没有仔细的遵循&lt;a href=&quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface&quot;&gt;基于接口编程&lt;/a&gt;的原则。即使需要用，也应该尽量避免滥用。&lt;/p&gt;

&lt;p&gt;还有一种常见的情形是在两个相互关联的方法之间传递中间状态；这种情形还可以再仔细甄别 - 如果是在两个共有方法之间共享状态，那么需要仔细考虑为何不在构造方法中设置好初始状态，也许&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern#Java&quot;&gt;空对象模式&lt;/a&gt;是个值得考虑的好主意。如果是在两个私有方法或者是一个公有方法和其内嵌的私有方法之间传递状态，那么往往意味着代码的实现出现了&lt;strong&gt;坏味道&lt;/strong&gt;，因为方法实现之间传递隐式状态很可能意味着本&lt;strong&gt;类的职责过多需要拆分&lt;/strong&gt;出来新的类，或者是用空指针来传递控制流程迁移，这类不必要的空指针检查完全可以避免；因为私有方法可以看作是实现细节的隐藏，在实现内部具体的状态迁移都应该是严格受控的，要么通过合理的参数来传递，要么考虑好具体场景而不宜随意传递可能为空的对象。&lt;/p&gt;

&lt;h3 id=&quot;静态成员对象-field&quot;&gt;静态成员对象 (Field)&lt;/h3&gt;

&lt;p&gt;静态对象是个和全局变量类似的问题，其初始化的时机其实已经超出了具体类对象的范围，会和其他的类产生&lt;strong&gt;明显的强耦合&lt;/strong&gt;。因而静态成员对象应该尽量去避免，如果真要使用，确保其生存期被正确的管理，譬如使用依赖注入框架等。&lt;/p&gt;

&lt;h3 id=&quot;方法传入参数对象&quot;&gt;方法传入参数对象&lt;/h3&gt;
&lt;p&gt;方法传入的参数对于方法的实现体而言是外部输入，因此也值得仔细判断。&lt;/p&gt;

&lt;h4 id=&quot;公有方法中的参数对象&quot;&gt;公有方法中的参数对象&lt;/h4&gt;
&lt;p&gt;显然共有方法中引入的参数对象是由调用者指定的，方法实现中需要考虑好什么样的参数是允许的，是否允许空指针传入；如果不期望空指针传入，那么可以在&lt;strong&gt;类设计中考虑进去并写入JavaDoc&lt;/strong&gt;，用具体上下文信息封装一个合适的异常传递给调用者，并保证方法调用前后，类的状态仍然是合理而符合预期的。如果允许方法中的某些参数对象为null，并依据是否为null执行不同的行为，那么建议应该尽量避免这样的设计, 空指针控制业务流程和常规的直觉不符,完全可以通过其他方式传入，或者增加新的公有方法或重载版本。仔细考虑之后，仍然决定允许为空指针，&lt;strong&gt;同样要在JavaDoc中写好&lt;/strong&gt;，方便你的用户。&lt;/p&gt;

&lt;h4 id=&quot;私有方法中的参数&quot;&gt;私有方法中的参数&lt;/h4&gt;
&lt;p&gt;私有方法往往是为想隐藏公有方法中的实现细节而准备的。显然由私有方法中引入的null类型参数是在实现某个公有方法的封装中引入的；由于公有方法的参数中没有带入这类空指针（见上述讨论），那么出现的空指针参数必然是由实现逻辑的过程中传入的；这&lt;strong&gt;往往意味着实现中出现了不自然的设计&lt;/strong&gt;，这种情形和上述的共有方法传入空指针还不一样，因为私有方法的用户始终是这个类的某个公有方法（或者是其基类)，那么更没有理由不去重构了。&lt;/p&gt;

&lt;h5 id=&quot;一个具体的例子&quot;&gt;一个具体的例子&lt;/h5&gt;
&lt;p&gt;譬如某个类有如下的实现方法&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//....&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeThing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//do something but not check param!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someConditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//construct another param returns a new valid param&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;doSomeLowLevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constuctAnotherParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//....&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeLowlevelWOrk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anotherParm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//!oops, have to check param &amp;amp; anotherParam&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//dosomething &lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anotherParam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something special&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// do something as normal&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的公有方法没有检查其传入的参数就直接将其传入了一个更底层的实现，并且显示的传入了另外一个null指针作为某个特殊的条件逻辑;这里的空指针用于决定底层实现逻辑的分支选择其实引入了不必要的跨逻辑层次依赖，属于比较明显的代码坏味道，可以将其重写如下&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something special&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someConditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomeLowlevelWork&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Now I'm sure no null passed in!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conditionMet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do some thing without another param&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anotherParam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constructAnotherParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//do something else with another param, no null objects!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;重构后的版本将外部传入参数的判断放在公有方法的顶层处理，来确保相对底层的私有实现中不引入额外的空指针，取而代之的是具体的业务逻辑条件判断；代码的可读性显然有了良性的变化。&lt;/p&gt;

&lt;h5 id=&quot;例外情况&quot;&gt;例外情况&lt;/h5&gt;

&lt;p&gt;凡事总有例外，这里毫无疑问也存在一种特殊的情况，即是在实现&lt;a href=&quot;https://sourcemaking.com/design_patterns/template_method&quot;&gt;模板方法模式&lt;/a&gt;的时候，在基类中将空参数给传递进来了；这种情况下&lt;strong&gt;如果不能修改基类的代码，那么依然不得不做处理&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;譬如在一个抽象类中定义了模板方法操作&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractBehavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;//both firstParam and secondParam can be null, but not checked in below public API&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//certain other handling&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在一个具体的实现类中，因为抽象类未做检查，子类实现必须检查父类传入的参数&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteBehavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstParm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//have to check if firstParam is null or not!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStep2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnotherParam&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//have to check if secondParam is null or not!&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;话说回来，继承一个无法修改代码的基类可能往往不是一个很好的注意，这种情况下，&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;使用组合而不是继承&lt;/a&gt;可能是一种更好的方法，如果可以的话；因为从代码的耦合上来说，&lt;strong&gt;继承关系是一种很强的耦合&lt;/strong&gt;以至于所有父类中的不良设计会被所有的子类所继承，形成无形的约束。这也许是我们需要始终对以高复用为目标的框架保持谨慎的原因。&lt;/p&gt;

&lt;h3 id=&quot;外部对象&quot;&gt;外部对象&lt;/h3&gt;

&lt;p&gt;所谓的外部对象是这些在某个方法实现中被引用到，却并没有被类如方法传入参数，也没有被放在成员对象列表中的对象。当然如果出现这种情况，往往是全局对象的引用（要么是静态全局对象，要么是单例对象）。然而不管哪种情况下，你的class已经悄无声息地引入了&lt;strong&gt;隐式依赖&lt;/strong&gt;，而隐式依赖在大部分情况下引入的问题比解决的问题要多。&lt;/p&gt;

&lt;p&gt;对于这类对象，如果用现代的依赖注入方案来解决，很自然它们就和普通的成员对象没什么区别了。关键的问题是需要考虑好，是否真的必须引入这类隐式依赖就可以了，绝大部分情况下，&lt;strong&gt;显示依赖比隐式依赖要好&lt;/strong&gt;。当然去掉了隐式依赖后，一个额外的好处是你的测试将变得更加容易了，因为不需要特殊的mock或是Stub来设置上下文了；只需要构造被测试对象的时候安插好构造参数即可。&lt;/p&gt;

&lt;h2 id=&quot;变通之道&quot;&gt;变通之道&lt;/h2&gt;
&lt;p&gt;啰嗦这么多，看起来很多地方可能还是不可避免需要去做空指针检查。是否有办法做个变通，既保证逻辑正确，也能确保代码维护性不被破坏？其实回头仔细想一下，之所以有空指针异常这回事儿，根本上还不是因为&lt;strong&gt;Java用异常机制来非正常情况的&lt;/strong&gt;处理吗，从这个角度出发，其实我们还有这些选择&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用返回值而不用异常 - 然而我们是在讨论Java，虽然依然可以用返回值对象，或者类似C或者golang的error code的方式，但是如果你以这种方式写代码，其实&lt;strong&gt;可维护性的负担反而加重&lt;/strong&gt;了,顶多是少了一些花括号而已&lt;/li&gt;
  &lt;li&gt;使用&lt;strong&gt;新的编程范式&lt;/strong&gt;，没错我们还有&lt;a href=&quot;/categories/fp/index.html&quot;&gt;函数式编程&lt;/a&gt;可以选择，因为Java8已经给我们送来了这个大礼 - Optional&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;optional&quot;&gt;Optional&lt;/h3&gt;
&lt;p&gt;Java8新引入的&lt;a href=&quot;https://www.mkyong.com/java8/java-8-optional-in-depth/&quot;&gt;Optional&lt;/a&gt;类型提供了不同于传统基于返回值或者基于异常的新的错误处理机制。一个Optional类型是一个包装类型，其封装了原有的对象类型，但是在对象的状态上，允许表达该对象&lt;strong&gt;要么是存在要么是不存在&lt;/strong&gt;的概念。表面上看起来和传统的null没有太明显的区别，然而两者之间有很大的不同&lt;/p&gt;

&lt;p&gt;譬如同样一个可能为空的对象上的一个多步骤操作，传统的方式可以写为&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ResultType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomethingWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//exceptional handling code, other return&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doExceptionalHandling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果换用Optional封装则可以写为&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSomethingWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doExceptionalHandling&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;传统的空指针或者返回值方式返回的对象是不同的类型，程序员必须&lt;strong&gt;对返回值做类型相关的处理&lt;/strong&gt;，从这种意义上说，返回值方式(包括空指针)提供的相对低层次的封装，毕竟对于C++/Java这类强类型语言而言，不同的变量类型相关处理意味着底层语言基础设施和应用业务逻辑这两个不同层次的抽象被混杂在同一个层级的代码范围内&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt;类型提供的是统一的对象类型封装，你可以对该类型做相对更高层次的封装，根据你具体的业务逻辑写出声明式的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;隐藏在optional中的模式&quot;&gt;隐藏在Optional中的模式&lt;/h3&gt;
&lt;p&gt;从上面的示例代码可以看出，Optional类其实提供了关于一些基本过程逻辑的封装，使得使用者可以&lt;strong&gt;站在更高的层次写代码&lt;/strong&gt;，关于一些基本的分支判断等过程逻辑控制，Optional提供了一些模式给程序员来调用，使得程序员可以更加关注在业务逻辑上，减少程序语言的底层实现细节的纠缠，同时又&lt;strong&gt;不丢失静态语言带来的编译器检查&lt;/strong&gt;的便利。&lt;/p&gt;

&lt;p&gt;当然Optional类型本身是一个封装类，作为函数式编程中的一个模式在Haskell中它是&lt;a href=&quot;/post/2012/04/15/haskell-functor-and-monad/&quot;&gt;一种具体的&lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt;抽象&lt;/a&gt;，其提供的方法提供了各种各样关于封装对象的高层操作，包括过滤器/映射/异常处理等，可以实现更复杂而高级的操作，这里不再赘述；细节可参考Optional的使用。&lt;/p&gt;

&lt;h3 id=&quot;java8的-type-annotation&quot;&gt;Java8的 Type Annotation&lt;/h3&gt;
&lt;p&gt;其实在Java8中，新引入的类型注解针对空指针问题提供了另外的处理方式，即通过指定&lt;code class=&quot;highlighter-rouge&quot;&gt;@Nonnull&lt;/code&gt;，编译器可以用于检测某个代码路径中有可能接受到空指针的情况，从而避免程序员处理空指针异常。IntelliJ IDEA提供了贴心的提示建议插入这个annotation从而帮助我们写出更整洁的代码。&lt;/p&gt;

&lt;h2 id=&quot;参考引用&quot;&gt;参考引用&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://enterprisecraftsmanship.com/2016/04/27/defensive-programming-the-good-the-bad-and-the-ugly/&quot;&gt;Defensive programming, the good, the bad, the ugly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6086334/is-it-good-practice-to-make-the-constructor-throw-an-exception&quot;&gt;Is it a good practice to make constructor throw exception&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composition over inheritance&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/java-platform-group/java-8s-new-type-annotations&quot;&gt;Java8 new type annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="java" /><category term="design" /><category term="patterns" /><category term="fp" /><summary type="html">最近在参与某开发小组的团体代码审查会的时候，发现组内的一线开发工程师对于何时应该做空指针检查并没有很清晰的认识；然而这在Java社区里早已经是个老生常谈的争论 。</summary></entry><entry><title type="html">Migrate blog to Jekyll</title><link href="http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll/" rel="alternate" type="text/html" title="Migrate blog to Jekyll" /><published>2017-06-24T00:00:00+08:00</published><updated>2017-06-24T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/24/migrate-blog-to-jekyll/">&lt;p&gt;之前本blog的内容是基于强大的&lt;a href=&quot;http://octopress.org/&quot;&gt;octopress&lt;/a&gt;生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的&lt;a href=&quot;http://octopress.org/2015/01/15/octopress-3.0-is-coming/&quot;&gt;新版本预告&lt;/a&gt;后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。&lt;/p&gt;

&lt;p&gt;很明显，&lt;strong&gt;octopress项目要死了&lt;/strong&gt;，这在开源软件社区是常有的事儿；但是活人不能被尿憋死，本来用octopress的目的也是因为 Jekyll 太抽象了想顺带找个近路学习学习前端知识；这些没有了借口，还是升吧。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;上新版本jekyll安装主题&quot;&gt;上新版本Jekyll，安装主题&lt;/h2&gt;

&lt;p&gt;最开始用octopress的时候，Jekyll还是 0.6 版本；这么多年过去，Github 团队官方已经发布了 3.0 版本了，功能支持的已经比较完善了。本身Jekyll是基于 gem 的，模块化做的非常好了，不像原来的 octorpess 直接fork一个代码就在里边改来改去，还要创建多个branch 防止无法升级的问题。按照 &lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;官方文档&lt;/a&gt; 的步骤按部就班即可。&lt;/p&gt;

&lt;p&gt;Jekyll支持&lt;strong&gt;丰富的插件&lt;/strong&gt;，生成好对应的site之后，修改配置文件就可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle update&lt;/code&gt; 来安装。但是默认的Jekyll主题太过于原始，所以找个适合自己口味的主题是首要的。因为本blog是托管在github上的，gith-hub pages &lt;a href=&quot;https://pages.github.com/themes/&quot;&gt;支持的主题&lt;/a&gt; 却&lt;strong&gt;比较有限&lt;/strong&gt;, 而且要没没有提供预览，要么提供的预览不适合个人口味。&lt;/p&gt;

&lt;p&gt;回头看Ocotpress发现其实现方式完全是自己生成页面的，不用Github自己的build系统；这里可以很容易的依法炮制，自己将所有的东西编译好，将生成的site内容给传上去即可。个人还是比较喜欢原来的 Octorpress提供的默认主题，简洁明快；所以最终选择的是 &lt;a href=&quot;https://mademistakes.com/work/minimal-mistakes-jekyll-theme/&quot;&gt;Minimal Mistakes&lt;/a&gt; ；浏览选择过程中，对 &lt;a href=&quot;http://phlow.github.io/feeling-responsive/&quot;&gt;Feeling Responsive&lt;/a&gt;主题也非常入眼，只是看起来文档比较复杂，可以留待以后尝试折腾下。&lt;/p&gt;

&lt;p&gt;Minimal Mistake主题支持比较多的设定，因为打算自己生成页面，所以采用类似fork的思路，安装&lt;strong&gt;自己想要的插件&lt;/strong&gt;（可以突破&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;Github-Pages的限制&lt;/a&gt;)，最后build成页面给push上去即可。&lt;/p&gt;

&lt;h2 id=&quot;自动同步&quot;&gt;自动同步&lt;/h2&gt;

&lt;p&gt;由于是自己手工编译生成静态内容，所以很希望有类似于Octopress的Rakefile，遗憾的是&lt;strong&gt;copy下来的Rakefile&lt;/strong&gt;不能正确执行。Google上search了一圈发现没有现成的方案，而且Github-pages的个人站点仅仅&lt;strong&gt;支持push到master分支&lt;/strong&gt;, 而&lt;del&gt;早期的时候是push到gh-pages&lt;/del&gt;分支的；这个细微的更新貌似很多google页面都没有提及；不过好在也不是很难发现，仅仅需要在自己site的设置页面查看build的分支就可以看到只能接受master分支了。&lt;/p&gt;

&lt;p&gt;自动化的工作最终写了个简单的shell脚本来完成, 基本的步骤是沿用 Octopress2 的步骤，设置2个入口&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一个用于初始化一个deploy目录，和github的站点内容保持同步，初始化git和remote等等。&lt;/li&gt;
  &lt;li&gt;另外一个用于每次更新内容，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 完成编译后，将生成的内容全部copy到deploy目录下，然后再同步到github的repository&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;deployDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_deploy
&lt;span class=&quot;nv&quot;&gt;siteDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_site
&lt;span class=&quot;nv&quot;&gt;siteUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://github.com/skyscribe/skyscribe.github.io.git

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;setup&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    rm -fr &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    mkdir -p &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git init
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dummy content&quot;&lt;/span&gt; &amp;gt; index.html
    git add .
    git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;dummy script init&quot;&lt;/span&gt;
    git branch -m master
    git remote add origin &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteUrl&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Setup complete for &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;deploy&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll build
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    cp -r &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&quot;&lt;/span&gt;
    git pull origin master
    git add -A
    &lt;span class=&quot;nv&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;date &lt;span class=&quot;s2&quot;&gt;&quot;+%Y-%m-%d_%H:%M:%S&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;site updated at &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$now&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git push origin master --force
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deploy completed&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in
  &lt;/span&gt;setup&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	    setup
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        deploy
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;数据搬运&quot;&gt;数据搬运&lt;/h2&gt;

&lt;p&gt;相对来说数据搬运不是很困难就是比较繁琐，原来很多Octopress支持的插件，在这里都得自己检验是否不工作或者是否有合适的插件可以替代。期间的过程就是不断的&lt;strong&gt;测试驱动&lt;/strong&gt;搬运，发现编译出错后，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;--trace&lt;/code&gt;开关，看问题出在什么地方然后一一修改之。最麻烦的一个问题是 gist 插件貌似产生了不兼容，原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;include_file&lt;/code&gt; 插件也没法再用，只好将文件内容copy过来，用Liquid的 &lt;code class=&quot;highlighter-rouge&quot;&gt;highlight&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 标签，套用如下的模板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;code/include.html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endhighlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;插件和定制&quot;&gt;插件和定制&lt;/h2&gt;

&lt;p&gt;没有了github的插件束缚，就可以装自己想要的插件了&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;jekyll-compose 可以用&lt;strong&gt;命令行来生成新的post&lt;/strong&gt;，类似于之前的octopress的命令行&lt;/li&gt;
  &lt;li&gt;jekyll-archives 可以用来生成归档页面，方便使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认的blog页面用的是post layout，但是默认没有定义，简单起见，自己在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt; 下边加一个就行，从默认的single.html拷贝过来修改一下即可。&lt;/p&gt;

&lt;h3 id=&quot;tag-cloud&quot;&gt;Tag cloud&lt;/h3&gt;
&lt;p&gt;Octopress的tagcloud插件，找了一圈也没找到好的，仿照别人家的，写了个简单的 tagcloud.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;all_tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;site.tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;h&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{absolute_url}}/categories/index.html&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;Categories&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/h&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tagCloud&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;site.categories&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;category_name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_avg&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;div:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;all_tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tag&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{absolute_url}}/categories/{{ category_name | downcase}}/index.html&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;category_name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;})&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endfor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;稍微定制下需要显示的地方，将上述html给include进去即可。&lt;/p&gt;

&lt;h3 id=&quot;布局调整&quot;&gt;布局调整&lt;/h3&gt;
&lt;p&gt;页面在高分辨率的屏幕下感觉空白太多，进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;_sass/minimal-mistakes&lt;/code&gt; 修改即可，代码相对比较清楚&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_variables.scss&lt;/code&gt; 包含一些全局变量的定义，譬如字体大小，缩进，padding等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_sidebar.scss&lt;/code&gt; 包含对边栏的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_masthead.scss&lt;/code&gt; 指定主头部元素的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_page.scss&lt;/code&gt; 包含页面主要内容部分的样式定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概对着浏览器窗口调整即可，无需赘述。&lt;/p&gt;

&lt;h2 id=&quot;未尽事宜&quot;&gt;未尽事宜&lt;/h2&gt;
&lt;p&gt;还有一些其它的问题暂时没找到解决方案，暂时不折腾了，先列在这里。&lt;/p&gt;

&lt;h4 id=&quot;无法删除的老页面&quot;&gt;无法删除的老页面&lt;/h4&gt;
&lt;p&gt;之前的blog采用的是octopress的URL设置，当在新的主题里，将permalink依法炮制的时候，发现更新的页面没有被github正确重新加载，依然显示的是老的页面。无奈之下，只好修改一下permalink的前缀部分，强制生成不一样的页面。问题是老的页面依然可以访问。&lt;/p&gt;

&lt;h4 id=&quot;页面布局&quot;&gt;页面布局&lt;/h4&gt;
&lt;p&gt;默认的布局中有很多&lt;em&gt;额外的padding&lt;/em&gt;没法去掉，尤其是PC的分辨率比较高的时候，页面右侧的边框显得特别大；用Chrome的Inspect工具打开可以看到右侧的padding有16%之多，然而修改附带的css并不能生效。&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://rafabene.com/2015/10/11/how-migrated-blog-jekyll-github/&quot;&gt;How I migrated my blog to Jekyll/Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hblok.net/blog/posts/2016/10/23/jekyll-include-partial-snippets-of-code/&quot;&gt;Include partial snippets of code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/phaer/1020852&quot;&gt;Raw tag plugin to prevent liquid from parsing given text&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="blog" /><summary type="html">之前本blog的内容是基于强大的octopress生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的新版本预告后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。</summary></entry><entry><title type="html">Kotlin语言之变量约束设计</title><link href="http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants/" rel="alternate" type="text/html" title="Kotlin语言之变量约束设计" /><published>2017-06-05T23:12:00+08:00</published><updated>2017-06-05T23:12:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/05/kotlin-variable-invariants/">&lt;p&gt;可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为&lt;strong&gt;继承/封装/多态等手法针对的都是程序组织上&lt;/strong&gt;的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖&lt;strong&gt;过程式实现跟操作系统打交道&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;函数式编程里的副作用&quot;&gt;函数式编程里的副作用&lt;/h2&gt;
&lt;p&gt;在函数式编程的世界里，事情会变得很传统的过程式处理不一样，因为这里非常讲究函数本身是否是&lt;strong&gt;有副作用&lt;/strong&gt;的，如果&lt;strong&gt;同样的输入不能保证相同的输出&lt;/strong&gt;，那么则是有副作用的。这里的输出不仅仅表示返回值，还隐含其它形形色色的对环境的影响，包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;申请但是没有释放的内存&lt;/li&gt;
  &lt;li&gt;向操作系统请求占用共享资源如网络套接字&lt;/li&gt;
  &lt;li&gt;屏幕输出，磁盘占用等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要区分副作用&quot;&gt;为什么要区分副作用&lt;/h2&gt;

&lt;p&gt;显然，副作用引入了&lt;strong&gt;额外需要程序员维护&lt;/strong&gt;的状态，而传统的线程库或基本的OS机制将其完全交给了程序员负责。从而导致在多线程编程环境下，复杂的问题随着状态的增加成&lt;strong&gt;指数上升&lt;/strong&gt;。状态意味着有共享资源需要维护，当有并发执行的进程或是线程的时候，为了保证正确的程序语意，则不得不引入锁(昂贵的操作)和竞争，从而制约性能。无锁算法通过CAS+重试机制，可以&lt;strong&gt;部分缓解锁的开销&lt;/strong&gt;，却不能从本质上解决问题。&lt;/p&gt;

&lt;p&gt;无副作用的函数则是天然适合并发的，因为没有共享自然可以并行不悖地执行，问题不是完美解决了吗？然而&lt;strong&gt;现实世界总是不允许绝对完美二字存在&lt;/strong&gt;的，纯粹无副作用的函数几乎一无是处，因为它本质上没什么用，什么也做不了。&lt;/p&gt;

&lt;p&gt;退而求其次的想法是，能否尽量隔离两者的实现，然后又可以优雅地将二者集成起来完成实际功能？&lt;strong&gt;HASKELL用其优雅的monad抽象&lt;/strong&gt;回答了这个问题。然而对于抽象思维能力不是那么强（或者没有那么好数学基础）的程序员而言，&lt;strong&gt;Monad实在是太阳春白雪&lt;/strong&gt;了而难以接近；想更加接地气一点的程序语言无一不选择和Monad保持距离，即使某些构造和设计的思想就来源于Monad, 譬如随处可见的Optional，基本的map/reduce链式操作等。&lt;/p&gt;

&lt;p&gt;对于这些没有显示引入monad的非纯函数式语言来说，严格的隔离就显得有些太激进了。取而代之的相对折中一点的&lt;strong&gt;平庸&lt;/strong&gt;策略是语言机制本身提供某些基础机制，剩下的怎么用这些基本机制，一切由程序员自己来定夺。&lt;/p&gt;

&lt;h2 id=&quot;kotlin的语言层面基本机制&quot;&gt;kotlin的语言层面基本机制&lt;/h2&gt;

&lt;p&gt;kotlin通过关键字 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 来声明&lt;strong&gt;只读&lt;/strong&gt;的变量，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 来声明可变量。任何函数只要引入对可变量的使用，则其本身就是有明显的副作用的。然而一个变量声明为只读，仅仅表示在其对应的作用域中，不允许修改此变量的值，并&lt;strong&gt;不意味着实际指向的数据对象本身是不可变&lt;/strong&gt;的， 因为在可能有其他的地方使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 的方式来操作此变量，或者有显示的方式将一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 的变量转换回可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;考虑下边的例子：&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// field1 是只读的，在本class中不允许修改它
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// can only modify field2, but not field1
&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//calling site
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;someTypeInst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someTypeInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// someTypeInst can still be changed by others! Not recommended!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;someTypeInst&lt;/code&gt;是以只读方式传入&lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的，然而并不能保证没有其它的线程并发地修改实际的对象，如果发生这种情况，&lt;strong&gt;程序员仍然需要保证数据的一致性和安全&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;只读变量的初始化&quot;&gt;只读变量的初始化&lt;/h3&gt;

&lt;p&gt;显然不可变变量则仅仅能够初始化一次，后续使用中不能再修改了。这样也带来一些限制，譬如在 &lt;code class=&quot;highlighter-rouge&quot;&gt;init block&lt;/code&gt; 里想一次性初始化某些资源然后将其设置为在class内部是只读，则无能为力。一种变通的方式是将其设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 类，然而这样做我们就损失了只读约束；另外一种做法则需要使用property构造来封装。&lt;/p&gt;

&lt;h2 id=&quot;核心集合类&quot;&gt;核心集合类&lt;/h2&gt;
&lt;p&gt;kotlin对来自JAVA的集合类库进行了二次封装，清晰地划分了只读集合类和可变集合。&lt;/p&gt;

&lt;h3 id=&quot;接口定义&quot;&gt;接口定义&lt;/h3&gt;
&lt;p&gt;常用的集合类接口在&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin,collections&lt;/code&gt; 包中被重新定义 ( 源码中位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.kt&lt;/code&gt; )&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//...
// by default not mutable
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//... }
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// mutable iterable supports removing elements during iterating
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Only read access to collection
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Supports read/write operations
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的集合类接口则选择从以上接口中&lt;strong&gt;选择对应的&lt;/strong&gt;来扩展实现，因而对同一个类型有两种实现，分别是只读的 (没有前缀) 的和可变类型 (&lt;strong&gt;用 Mutable 做前缀区分&lt;/strong&gt;) 。譬如 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; 类就定义为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Read only list interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
// Mutable list
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，实际的具体实现类是复用Java中的定义，可参考collection包中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeAliases.kt&lt;/code&gt; 文件&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;默认的集合操作以及Streams API返回的大部分是不可变接口对象。&lt;/p&gt;

&lt;h3 id=&quot;集合类扩展工具函数&quot;&gt;集合类扩展/工具函数&lt;/h3&gt;
&lt;p&gt;除了使用默认的JDK实现来生成具体集合类对象，Kotlin标准库中同时提供了大量的封装函数方便程序员使用，某些来源于对JDK的直接封装，有一些则是直接inline实现。&lt;/p&gt;

&lt;p&gt;譬如返回空list的包装和初始化形形色色的list&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new read-only list of given elements.  */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * Returns an immutable list containing only the specified object [element].
 * The returned list is serializable.
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@JvmVersion&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成可变List的函数封装大多也是清晰明了 , 并且有很多种类的封装，使得就地生成 List 的工作大大简化；大部分情况仅仅需要&lt;strong&gt;使用已有的函数&lt;/strong&gt;即可，不需要发明新的轮子&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [MutableList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [ArrayList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new [MutableList] with the given elements. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayAsCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isVarargs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它集合类  (set/map等) 的实现原理&lt;strong&gt;大概类似&lt;/strong&gt;，可以通过查看对应源码。&lt;/p&gt;

&lt;h3 id=&quot;不可变集合转换为可变集合&quot;&gt;不可变集合转换为可变集合&lt;/h3&gt;
&lt;p&gt;很多场景下，API返回的都是不可变集合，将其变成一个可变对象再行编辑修改是常见不过的变成任务；kotlin 通过其&lt;strong&gt;自身的扩展机制&lt;/strong&gt;将这些工具函数自动添加到了对应的集合类上&lt;/p&gt;

&lt;p&gt;如果想要将一个只读的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt; 对象变为一个可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableList&lt;/code&gt;，那么其实现是通过重新初始化一个新对象实现的：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Below code is copied from generated standlib as _Arrays.kt
//  see https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于具体的Array类，有不同的实现，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;ByteArray&lt;/code&gt; 的初始化方法则有所不同，直接调用其构造函数，然后注意添加现有的各个元素&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ByteArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;之所以如此，是因为具体这些子类是被映射到具体的 JVM 对象上的。如ByteArray的文档如是说&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;public final class ByteArray defined in kotlin
An array of bytes. 
When targeting the JVM, instances of this class are represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;byte[]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而对于CharArray，则其映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;char []&lt;/code&gt;类型上去。&lt;/p&gt;

&lt;h2 id=&quot;idea支持&quot;&gt;IDEA支持&lt;/h2&gt;
&lt;p&gt;作为官方的IDE环境，IDEA对可变量的引用做了显示的&lt;strong&gt;下划线&lt;/strong&gt;提醒，程序员可以一目了然地看到代码中对可变量的使用。&lt;/p&gt;

&lt;p&gt;然而想要更深入的查看整个实现调用链中，哪些引入副作用哪些没有，工具的支持就比较有限了。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="fp" /><summary type="html">可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为继承/封装/多态等手法针对的都是程序组织上的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖过程式实现跟操作系统打交道。</summary></entry><entry><title type="html">Kotlin语言之函数式编程</title><link href="http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming/" rel="alternate" type="text/html" title="Kotlin语言之函数式编程" /><published>2017-06-04T22:32:00+08:00</published><updated>2017-06-04T22:32:00+08:00</updated><id>http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming</id><content type="html" xml:base="http://www.skyscribe.me/post/2017/06/04/kotlin-language-functional-programming/">&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin语言&lt;/a&gt;是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其&lt;a href=&quot;https://techcrunch.com/2017/05/17/google-makes-kotlin-a-first-class-language-for-writing-android-apps/&quot;&gt;2017年的I/O大会上将其列为Android平台官方支持的语言&lt;/a&gt;而窜上了热点。&lt;/p&gt;

&lt;p&gt;本文尝试从函数式编程的角度管窥Kotlin的特性。&lt;/p&gt;

&lt;h2 id=&quot;jvm上的函数式语言生态&quot;&gt;JVM上的函数式语言生态&lt;/h2&gt;
&lt;p&gt;作为一门比较年轻的编程语言，要想在既有的数百种语言中脱颖而出，成功吸引开发者的心，对新的&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;函数式编程范式&lt;/a&gt;的支持是必然不可少的 - 这一点基本成为语言出品商心照不宣的潜规则了，当然在21实际，不支持面向对象的范式也是说不过去的。&lt;/p&gt;

&lt;p&gt;作为基于JVM平台的语言，和Java的互操作性肯定是一个重要的优势，当然这方面已经有成熟的函数式语言&lt;a href=&quot;https://www.scala-lang.org/&quot;&gt;scala&lt;/a&gt;和更早一点的&lt;a href=&quot;https://clojure.org/about/rationale&quot;&gt;clojure&lt;/a&gt;在前。可能比较遗憾的是，正统的函数式编程风格太难被传统的OO程序员所接受，因此基于传统Lisp的clojure一直曲高和寡，scala在近年来有变得更加流行的趋势，只是目前看来&lt;a href=&quot;https://dzone.com/articles/the-rise-and-fall-of-scala&quot;&gt;仍然没有跨越期望的引爆点&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;有丰富的特性还希望有速度&quot;&gt;有丰富的特性还希望有速度&lt;/h3&gt;
&lt;p&gt;传统印象中的静态函数式语言的编译速度往往会比较慢，这一点在工程实践上是个很重要的因素。&lt;/p&gt;

&lt;p&gt;Kotlin作为后来者，其开发者认为静态语言的编译速度是个至关重要的，然后Scala的编译速度远不能令人满意。对大型的项目而言，笨拙的编译速度浪费的可是大量的时间和金钱；毕竟天下武功唯快不破，更快的编译时间意味着更快的反馈周期，更多次的迭代开发。Kotlin的目标之一是期望编译速度可以像Java一样快，&lt;a href=&quot;https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d&quot;&gt;benchmark分析&lt;/a&gt;也表明了二者的速度是差别不大的。&lt;/p&gt;

&lt;h2 id=&quot;基本特性&quot;&gt;基本特性&lt;/h2&gt;
&lt;p&gt;函数式语言的基本元素就是function，这一点kotlin倒是没有玩太多花头。用&lt;code class=&quot;highlighter-rouge&quot;&gt;fun&lt;/code&gt;关键字来声明函数，函数是第一等公民，可以支持函数作为参数，返回函数等基本特性。&lt;/p&gt;

&lt;h3 id=&quot;不可变类型支持&quot;&gt;不可变类型支持&lt;/h3&gt;
&lt;p&gt;Kotlin强制要求程序员声明某个特定的变量是否是可变类型。&lt;/p&gt;

&lt;p&gt;如果是可变类型，则需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;var &lt;/code&gt;来声明；那么后续程序中任何地方访问变量都会被IDE给highlight出来，提醒可能的副作用。因为可变类型意味着内部存储着状态，从函数式编程的角度来看，状态会&lt;strong&gt;影响函数的纯度&lt;/strong&gt;，带来副作用和复杂性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5275528-e33afde1447172d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;immutable_hints.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;函数声明&quot;&gt;函数声明&lt;/h3&gt;
&lt;p&gt;基本的函数声明是这样的&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsAFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当然这里的类型后置语法和传统的C家族语言有些不同，但是适应起来倒也不是难事儿。&lt;/p&gt;

&lt;h3 id=&quot;类型推导&quot;&gt;类型推导&lt;/h3&gt;
&lt;p&gt;Kotlin也支持强大的类型推导，从而在很多情况下，可以省略不必言的类型指定，简化代码；譬如函数的返回类型可以被自动推断的时候，其类型声明可以被省略。&lt;/p&gt;

&lt;h3 id=&quot;特殊的返回类型-unit&quot;&gt;特殊的返回类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;是一个特殊的类型，用于指定某个函数返回的值可以被省略，类似于Java8的&lt;code class=&quot;highlighter-rouge&quot;&gt;Void&lt;/code&gt;类型。如果一个函数没有返回值，那么可以指定其返回&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;或者直接省略其返回&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something with arg
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// no return needed
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// same as above
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;中缀表达式&quot;&gt;中缀表达式&lt;/h3&gt;
&lt;p&gt;中缀表达式写法更替进人的思维习惯，在定义某些操作符的时候是非常有用的。此用法往往用于扩展已有类型的操作，定义的时候需要满足以下条件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;属于某个类的成员函数，或者是定义某个类的扩展函数(后边再回头来看)，因为这里我们&lt;strong&gt;必须知道左侧的操作对象&lt;/strong&gt;是谁&lt;/li&gt;
  &lt;li&gt;必须只有一个函数参数（操作符后边的对象）&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;infix&lt;/code&gt;关键字来标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;譬如&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;infix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;/// implementation of shl operation
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// call site
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;命名参数和默认值&quot;&gt;命名参数和默认值&lt;/h3&gt;
&lt;p&gt;这点和Python很像在多个参数的复杂函数的使用上有很大帮助，能极大提高可读性减少维护成本。调用方可以在调用点指定需要传入的参数的名字；也可以省略掉不需要指定的参数。&lt;/p&gt;

&lt;p&gt;譬如有如下的&lt;code class=&quot;highlighter-rouge&quot;&gt;reformat&lt;/code&gt;函数用于格式化&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;normalizeCase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;upperCaseFirstLetter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;divideByCamelHumps&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用点可以简单写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// equals to
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个功能在传统的C++/Java里边没有提供，但是IDEA提供了只能提示可以弥补Java的不足；而Kotlin则将其内置在语言中了；本身没多少复杂性在里边。&lt;/p&gt;

&lt;h2 id=&quot;高阶函数和语法糖&quot;&gt;高阶函数和语法糖&lt;/h2&gt;

&lt;h3 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h3&gt;
&lt;p&gt;函数的参数可以是一个函数，这个在Kotlin的库里已经有大量的例子，譬如基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt;的filter函数携带一个谓词函数，其针对给定的参数返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt; Boolean&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FilteringSequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;单参数函数的表达式形式&quot;&gt;单参数函数的表达式形式&lt;/h3&gt;
&lt;p&gt;当函数只有一行实现的时候，可以省略其函数体，直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;来书写，就像复制给一个变量一样&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add2Numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lambda和匿名函数&quot;&gt;Lambda和匿名函数&lt;/h3&gt;
&lt;p&gt;匿名函数用大括号括起来，上面的例子也可以写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;add2Numbers2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;函数调用的形式省略&quot;&gt;函数调用的形式省略&lt;/h3&gt;
&lt;p&gt;当函数仅仅有一个参数的时候，其参数名字默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;保留关键字可以不用显示指定。&lt;/p&gt;

&lt;p&gt;当函数的最后一个参数是一个函数的时候，其函数体可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;块的方式来书写，获得更好的可读性。&lt;/p&gt;

&lt;p&gt;譬如如下的例子用于打印指定数目个偶数&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;printEvens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;一个具体一点的例子&quot;&gt;一个具体一点的例子&lt;/h3&gt;

&lt;p&gt;假设要实现如下功能的函数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;遍历某个目录树&lt;/li&gt;
  &lt;li&gt;找出所有符合条件的文件夹&lt;/li&gt;
  &lt;li&gt;取其文件绝对路径&lt;/li&gt;
  &lt;li&gt;归并为一个字符串列表返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以通过如下几个函数完成&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里每个函数的含义都是比较清楚易懂的。如果利用上述的省略规则，那么可以更简略的写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;类型扩展函数&quot;&gt;类型扩展函数&lt;/h2&gt;
&lt;p&gt;Kotlin 支持对已有的类型添加扩展，值需要在任何想要的地方添加想要的功能，则原有的类型即可像被增强了一样具有新的功能，该机制提供了OO之外新的灵活的扩展方式。&lt;/p&gt;

&lt;p&gt;譬如默认的Kotlin的&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;类没有提供并发的&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;操作，可以通过扩展机制很容易的写出来一个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;来并发循环的版本&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parallel for each, see also https://stackoverflow.com/questions/34697828/parallel-operations-on-kotlin-collections
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRuntime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableProcessors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// default size is just an inlined version of kotlin.collections.collectionSizeOrDefault
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;destination&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DAYS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里在函数体中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;自动会绑定于被扩展的对象。&lt;/p&gt;

&lt;p&gt;如果我们想实现一个自动将一大堆plantuml文件转换为png格式并copy到指定目录，因为默认的plantuml的API是单线程的，我们可以基于上述的parallelForEach实现来并发调度UML的生成过程，对应的代码可以写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;markDownFileLists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SourceFileReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generatedImages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstOrNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copyFileToDirWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pngFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCopyTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${System.currentTimeMillis()} - Created png for $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="fp" /><summary type="html">Kotlin语言是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其2017年的I/O大会上将其列为Android平台官方支持的语言而窜上了热点。</summary></entry><entry><title type="html">Software Design in Agile Development Context</title><link href="http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context/" rel="alternate" type="text/html" title="Software Design in Agile Development Context" /><published>2016-12-24T19:32:00+08:00</published><updated>2016-12-24T19:32:00+08:00</updated><id>http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context</id><content type="html" xml:base="http://www.skyscribe.me/post/2016/12/24/software-design-in-agile-development-context/">&lt;p&gt;在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;软件设计的刚需被敏捷了吗&quot;&gt;软件设计的刚需被敏捷了吗？&lt;/h2&gt;

&lt;p&gt;工作流程的变更以及开发节奏的加快并不能绕开一个很核心的问题：&lt;strong&gt;写出容易维护方便扩展的代码的复杂程度本质上没有改变&lt;/strong&gt;；软件的维护周期越长，迭代的版本越多，这个基本问题就越突出。要想顺利解决这一问题，只能&lt;strong&gt;依赖于系统具有相对良好的设计&lt;/strong&gt;，使得添加新的功能不会轻易破坏原有的结构，出现问题的时候，不需要大范围地对系统做出变更。&lt;/p&gt;

&lt;p&gt;传统的瀑布式方法希望通过借鉴成熟的建筑行业的做法，采用预先大规模的架构设计，对系统做好明确的分割；继而进行不同层次的设计，直到所有可以预见到的需求都得以满足，然后才开始进行的代码的编写和构建。这种方法生产出来的软件交付工期很长，适应性很差，除了少数特殊行业之外基本已经被市场所淘汰。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://agilemanifesto.org/&quot;&gt;敏捷宣言&lt;/a&gt; 提出了一些基本的原则来指导我们怎样用相对更”&lt;strong&gt;敏捷&lt;/strong&gt;“的方式开发和交付我们的软件；通过多个不同的迭代，增量式的构建和持续交付系统来降低风险。然而软件本身的复杂性导致我们不能将客户的需求一对一的翻译成代码，像搭积木一样构建出来一个可以轻易维护的系统。因为新加入的需求很可能导致原有的代码结构无法适应新的需求；某些为了尽快完成需求而做出的&lt;strong&gt;关键的假设可能必须被打破&lt;/strong&gt;导致添加新的需求会破环大量已有的功能。如何做出恰如其分的软件设计，既能满足现有的短期需求，又能平衡潜在的变更。&lt;/p&gt;

&lt;p&gt;各种不同的敏捷实践方法论对如何管理用户的需求，如何增强不同角色的沟通，如何实施日常的开发和测试活动，如何验证需求保证已经交付的承诺不被变更所破坏，如何规划和平衡资源和进度等复杂问题都给出了丰富的可选实践供项目管理人员裁剪；对于如何做软件设计以及做多少软件设计并没有很详尽的描述。就连基本的是否需要软件设计，以及需要多少软件设计，怎样算作过度设计都语焉不详。&lt;/p&gt;

&lt;h2 id=&quot;真的需要软件设计吗&quot;&gt;真的需要软件设计吗？&lt;/h2&gt;

&lt;p&gt;大部分情况下，对于这个基本的问题我想答案应该是肯定的，除非你是在做一个很小的个人项目。如果需要牵扯到多个人一块合作并且最终的产品需要维护比较长时间，那么起码&lt;strong&gt;某种程度的软件设计&lt;/strong&gt;应该是不可或缺的。毕竟&lt;strong&gt;软件开发活动本身也是围绕着人展开&lt;/strong&gt;的，既然需要多个不同知识背景，不同技能，不同角色的人一起来协作交付功能复杂多变的软件，那么必然需要一些设计保证&lt;strong&gt;参与其中的人有一致的理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;敏捷运动的早期一个常见的误解就是，敏捷软件开发不需要软件设计，不需要软件架构，只需要采用极限编程，将人们聚集一个公共空间里，直接动手写代码就行了；复杂的设计文档都是浪费，都是可以避免掉的，代码就是最好的设计文档。这样的过程可能适合于几个能力超强的程序员聚在一起做的临时小项目，放到更广泛的商业环境则难以持续下去。人员的流动，特殊需求的变更，性能问题的修补会使一个一开始看起来极其简单的几个源代码文件组成的小项目演进成&lt;strong&gt;难以维护的“庞然大物”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果系统没有明确的分工和边界，没有相对清晰的职责分工和交互限制，软件的结构很容易陷入“大泥球”结构而不可维护，试想如果代码里的每一个包或者类都有可能和另外其它的任意一个类有交互关系，即使是一个绝对代码行数很小的项目也会变得无法继续添加新的功能。&lt;/p&gt;

&lt;h2 id=&quot;哪些东西应该包含在软件设计中&quot;&gt;哪些东西应该包含在软件设计中？&lt;/h2&gt;

&lt;p&gt;所谓的设计其实可以理解为关于如何组织软件各个部分（特性和行为分割）的一些决策，以及做出相应决策的一些原因。&lt;/p&gt;

&lt;p&gt;敏捷场景下，重构的重要性以及早已经深入人心，因而容易经&lt;strong&gt;由重构来去掉“坏味”的部分就不宜放在设计&lt;/strong&gt;中。因为一般为了重用的目的都会将设计决策写下来供后续使用；如此一来必然产生一些维护成本；而维护设计文档的开销一般比代码要大很多。因此容易通过重构而优化的部分，放在专门的软件设计中显得有些得不偿失了。毕竟敏捷软件开发的基本思路就是&lt;strong&gt;消除浪费&lt;/strong&gt;，使得&lt;strong&gt;投入产出比最大&lt;/strong&gt;化。&lt;/p&gt;

&lt;p&gt;某些跟具体实现技术相关而和核心业务需求关系比较远的决策，大部分也&lt;strong&gt;不适宜包含在软件设计&lt;/strong&gt;中。譬如期望某部分关键数据需要做持久化以保证系统异常重启的时候依然可以恢复。对于业务需求而言，这块数据需要持久化是重要的，但是如何做持久化，又可能是易变的，譬如今天是考虑用文件来做持久化就可以了，将来可能发现不够必须用关系数据库，或者甚至关系数据库可能也不是一个合适的选择，得要用键值对数据库。&lt;strong&gt;识别到可能变化的部分，并将不变的部分抽象出来，放入设计中&lt;/strong&gt;可能就足够了。这样技能照顾到当前的需求，又能满足将来扩展的需要。至于具体是怎样实现的，看代码就足够了。&lt;/p&gt;

&lt;p&gt;需求的&lt;strong&gt;概念抽象化，和软件的静态模型可以作为设计的中心&lt;/strong&gt;之一，必须详细考虑并归档维护。之所以要对需求进行抽象化处理，是因为用户的期望可能是模糊不清的，甚至是“朝令夕改”的。敏捷方法强调持续交付就是为了使用户早期得到反馈，&lt;strong&gt;及时修正他们的需求&lt;/strong&gt;，更好的管理客户的期望，避免开发出不符合客户真正预期的产品，浪费开发资源不说也浪费了客户的投资。软件的静态模型是关于大的软件职责的拆分和交互边界，这一部分不仅是当前进一步开发的基本依据，日后万一需要重构也是很重要的参考，值得花力气仔细讨论达成一致，减少日后维护成本。&lt;/p&gt;

&lt;p&gt;软件的部署和核心模块的交互在有这方面的变更的时候（新加入模块或者服务等）也需要仔细考虑并作为软件设计的关键活动。模块的边界是粗粒度的系统耦合的地方，一些关键的交互流程也适宜详细讨论并放在软件设计文档中。&lt;/p&gt;

&lt;p&gt;系统核心的模块/类以及之间的交互，如果有发生变更，也需要第一时间考虑清楚并放置在设计过程中产生合适的产出，便于沟通和交流。如果模块的粒度足够大（譬如估计有很多的代码），那么哪些部分是对外交互的接口也应该提早考虑清楚，并提取出来以便后续写代码以及代码评审的时候对照，确保设计被正确遵守。&lt;/p&gt;

&lt;h2 id=&quot;什么时候应该停止继续设计&quot;&gt;什么时候应该停止继续设计？&lt;/h2&gt;

&lt;p&gt;敏捷语义下，任何的浪费都是可耻的，代价巨大的设计工作自然也不例外。知道何时还需要仔细讨论搞清楚，何时应该停止变得尤其困难，甚至需要一些接近于艺术化的方法，&lt;strong&gt;需要经过大量的实践经验累积和反思&lt;/strong&gt;才能做到不偏不倚。&lt;/p&gt;

&lt;p&gt;如果发现所讨论的问题可能代码实现很容易就能完成，如果考虑不完备，那么修改代码的代价非常小，那么就可以立即停止了；因为设计的目的是为了更好的写代码，更好的维护既有的代码。因此只有重构代码的代价远远大于预先仔细设计付出的代价是，才应该花费力气去做这些烧脑的工作。发现代码实现已经很容易没什么问题的时候，就放手去写代码或者重构代码吧。这种情况往往发生在我们想去“设计”一些内部实现细节，而这些细节对模块的边界以及待修改模块和核心部分耦合很小的情况。&lt;/p&gt;

&lt;p&gt;如果是在构建一个新的模块，而这个模块和已有的系统有形形色色的复杂联系（耦合），那么如果这个模块和已有的系统的各个部分的交互已经比较清楚，而且其内部实现估计工作量也很小的时候，那么就可以放心将剩下的工作交给聪明的程序员去继续了。将一些&lt;strong&gt;细微的工作也放入设计中，只会使设计文档变得庞大而又难以维护&lt;/strong&gt;。毕竟可工作的代码比完美的文档更重要，虽然后者也很有价值。&lt;/p&gt;

&lt;p&gt;如果对于是否应该继续设计有分歧，可以和其它准备实现的程序员坐在一起讨论（其实任何时候都应该如此，如果团队规模比较小而且时间允许），看将要写代码的程序员是否觉得足够清楚，返工的风险是否足够得小。如果对于一些核心的模块或者类的职责还有不同的认识，或者程序员不知道某些改动是应该新创建一个子包，还是应该在已有的摸个包中修改来实现，那么&lt;strong&gt;很可能有些关键的部分没有设计&lt;/strong&gt;清楚。&lt;/p&gt;

&lt;p&gt;决定何时应该适可而止也和你的程序员团队的&lt;strong&gt;实际水平和能力&lt;/strong&gt;密切相关。一群天才程序员可能需要极少的设计来达成基本的共识就可以产出高质量易维护的代码，而水平平庸的程序员团队则需要更多设计上的预先讨论沟通以达成基本共识，减少返工。&lt;/p&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;p&gt;软件工程的一个关键要素就是工具。软件设计自然也离不开合适的工具，尤其是软件设计又是对需求进行抽象的结晶；选择合适的工具可以增进协作和沟通，使得设计输出是有实际指导作用的而不仅仅是纯粹的文档工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;轻量级的文档工具&lt;/strong&gt;往往使维护和修改变得更加容易，因为设计输出本身也是一个迭代的过程；便于多人评审和协作显得尤其重要。目前主流的方式基本都是基于Markdown和Plantuml的；前者可以用来存放文本，后者则可以用文本的格式来描述UML图。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="agile" /><category term="methodologies" /><summary type="html">在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。</summary></entry><entry><title type="html">A software design and test guideline for C++ project</title><link href="http://www.skyscribe.me/post/2016/04/07/a-software-design-and-test-guideline/" rel="alternate" type="text/html" title="A software design and test guideline for C++ project" /><published>2016-04-07T00:00:00+08:00</published><updated>2016-04-07T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2016/04/07/a-software-design-and-test-guideline</id><content type="html" xml:base="http://www.skyscribe.me/post/2016/04/07/a-software-design-and-test-guideline/">&lt;p&gt;To make large scale C++ software project in good shape is not an easy job, especially when you have &lt;strong&gt;a pretty big development team that may form multiple sub-teams&lt;/strong&gt;. One of the key actions is to have &lt;strong&gt;common understanding on software design and testing strategies, rules and guidelines&lt;/strong&gt;, which are far more important than simply coding guidelines.&lt;/p&gt;

&lt;p&gt;This article is my personal understanding and suggestion on such a critical (yet controversial) topic.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;designtest-strategy&quot;&gt;Design/Test Strategy&lt;/h1&gt;
&lt;p&gt;Here’s the general rules regarding design and testing strategy.&lt;/p&gt;

&lt;h2 id=&quot;testing-strategy&quot;&gt;Testing Strategy&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Software testing strategy would be &lt;strong&gt;UT + SCT&lt;/strong&gt; during development.&lt;/li&gt;
  &lt;li&gt;Obsolete MT(module test) cases in all domains in the long run, consider adding SCT to cover specific scenarios while counting whole binary as SUT&lt;/li&gt;
  &lt;li&gt;Consider UT and SCT as different level of tests, so &lt;strong&gt;SCT coverage wouldn’t replace UT coverage&lt;/strong&gt;, vice versa&lt;/li&gt;
  &lt;li&gt;Remove legacy MT case when it’s considered to be too heavy to maintain&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DONOT&lt;/strong&gt; test &lt;del&gt;against internal implementation of an entity&lt;/del&gt; (either a class or binary), test its interface (public methods or exposed component interfaces) intensively&lt;/li&gt;
  &lt;li&gt;Design complicated scenarios into different layers, so unit tests can be written &lt;strong&gt;separately in different levels&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Avoid writing tests that treats different layers of implementations as SUT, write testing against lowest layer directly as possible&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;class-design-for-testability&quot;&gt;Class Design For Testability&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Program your class to interface than implementation&lt;/li&gt;
  &lt;li&gt;Keep class as &lt;strong&gt;small with single responsibility&lt;/strong&gt; as possible&lt;/li&gt;
  &lt;li&gt;Design your class so it can easily be tested, with small interface, clear responsibility and explicit collaboration with other classes&lt;/li&gt;
  &lt;li&gt;Also take SCT testability into account in design&lt;/li&gt;
  &lt;li&gt;Wrap utility functions within nested namespaces, and test them individually. DONOT place them in a class with static qualifier.&lt;/li&gt;
  &lt;li&gt;DONOT add code to a legacy big smelly class, consider &lt;strong&gt;extract the changes into smaller classes&lt;/strong&gt; and use &lt;strong&gt;dependency injection&lt;/strong&gt; to make changes testable&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;technical-detailed-guidelines&quot;&gt;Technical Detailed Guidelines&lt;/h1&gt;
&lt;p&gt;A few detailed guidelines are listed here for reference.&lt;/p&gt;

&lt;h2 id=&quot;class-design&quot;&gt;Class Design&lt;/h2&gt;
&lt;p&gt;Class is the basic element of object oriented software, the majority of the unit tests shall be taken a single class as SUT. Here lists some general guidelines:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A class should not provide too many public interfaces, generally 3~7 public methods shall be preferred&lt;/li&gt;
  &lt;li&gt;A class should not leak its internal states to external users by public interfaces&lt;/li&gt;
  &lt;li&gt;A class should initialize its collaborators through &lt;strong&gt;dependency injection&lt;/strong&gt; than directly construct by instance&lt;/li&gt;
  &lt;li&gt;A class should not work on different abstract levels&lt;/li&gt;
  &lt;li&gt;High level classes (working towards the center of business logic interaction) should not work directly with low level details - design lower level classes to finish the low level work&lt;/li&gt;
  &lt;li&gt;A class should not collaborate with too many external classes, no specific number is suggested here, while working with &lt;strong&gt;tens of external classes would be definitely problematic&lt;/strong&gt; in most cases&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;boundary-class-design&quot;&gt;Boundary Class Design&lt;/h3&gt;
&lt;p&gt;A boundary class is designed to be the interface to external entities (module or higher level entities), the design should apply below guidelines&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It should be an abstract class with visible interfaces, main intention is the &lt;strong&gt;separation of concerns&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;It should never reveal internal design details&lt;/li&gt;
  &lt;li&gt;It should not bring unnecessary dependencies (like introducing template meta-programming elements)&lt;/li&gt;
  &lt;li&gt;It should not handle processing details rather act as the bridge to other entities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Above guidelines also holds for general class design, while special care shall be taken when you’re designing a boundary class, since violation of them might turn overall software architecture into &lt;em&gt;a big ball of mud&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. &lt;strong&gt;These systems show unmistakable signs of unregulated growth, and repeated, expedient repair&lt;/strong&gt;. Information is shared promiscuously among distant elements of the system, often to the point where &lt;strong&gt;nearly all the important information becomes global or duplicated&lt;/strong&gt;. The overall structure of the system may never have been well defined. If it was, it may have eroded beyond recognition. Programmers with a shred of architectural sensibility shun these quagmires. Only those who are unconcerned about architecture, and, perhaps, are comfortable with the inertia of the day-to-day chore of patching the holes in these failing dikes, are content to work on such systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;— Brian Foote and Joseph Yoder, Big Ball of Mud. Fourth Conference on Patterns ? Languages of Programs (PLoP ‘97/EuroPLoP ‘97) Monticello, Illinois, September 1997&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Also be careful not to introduce too many boundary classes.&lt;/p&gt;

&lt;h3 id=&quot;application-logic-class-design&quot;&gt;Application-logic Class Design&lt;/h3&gt;
&lt;p&gt;Application logic specific classes are those who are created to fulfill certain specific business logic. It shall comply with below guidelines&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It should be kept as low in coupling and high in cohesion&lt;/li&gt;
  &lt;li&gt;It should have single responsibility, have &lt;strong&gt;good balance between SOLID principles&lt;/strong&gt;, and not violate the law of Demeter
    &lt;blockquote&gt;
      &lt;p&gt;Each unit should have only limited knowledge about other units : only units “closely” related to the current unit.&lt;/p&gt;

      &lt;p&gt;Each unit should only talk to its friends; don’t talk to strangers.&lt;/p&gt;

      &lt;p&gt;Only talk to your immediate friends.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;It should never work on different abstraction levels, like a &lt;strong&gt;manager/controller class handles low level platform APIs should be discouraged&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;It should not contain too many data members, which is typically sever violation of single responsibility&lt;/li&gt;
  &lt;li&gt;They may further by abstracted into different levels, if this is the case, keep &lt;strong&gt;dependency inversion principle&lt;/strong&gt; followed such that abstractions (higher level classes) shall not depend on implementation details (lower level classes)
    &lt;blockquote&gt;
      &lt;p&gt;A. High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/p&gt;

      &lt;p&gt;B. Abstractions should not depend on details. Details should depend on abstractions.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tmp-usage&quot;&gt;TMP Usage&lt;/h3&gt;
&lt;p&gt;Template-meta-programming are widely adopted by modern programmers, unfortunately it’s quite often misused/overused. When it’s overtaken, compiling dependence might be a serious problem, and compiler diagnostics messages might kill your time. It’s not a problem of generics itself, but rather a limitation of compilers and c++ language.Here’s some general ideas&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DONOT bring TMP to public interfaces unless you’re designing low level utilities&lt;/li&gt;
  &lt;li&gt;Balance OOD and TMP, hide TMP into implementation details would be a good idea&lt;/li&gt;
  &lt;li&gt;DONOT reinvent the wheels, make good use of standard libraries&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unit-test-design&quot;&gt;Unit Test Design&lt;/h2&gt;
&lt;p&gt;This chapter would &lt;strong&gt;not&lt;/strong&gt; cover basic howtos about unit testing, although some important guidelines are listed. Walk through &lt;a href=&quot;cpri_handler_unit_test_guide.md&quot;&gt;unit test guide&lt;/a&gt; for that purpose.&lt;/p&gt;

&lt;h3 id=&quot;general-rules&quot;&gt;General Rules&lt;/h3&gt;
&lt;p&gt;Below general rules shall be applied always as possible&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Each non-trivial classes shall be tested&lt;/li&gt;
  &lt;li&gt;DONOT test against factory method or classes since they’re designed to bring up other objects - it’s still valuable to test against complicated startup procedures&lt;/li&gt;
  &lt;li&gt;Keep &lt;strong&gt;test design and class design as synchronized&lt;/strong&gt; - whenever class design is changed, test design shall be refined accordingly&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-case-intention-and-focus&quot;&gt;Test Case Intention And Focus&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A test case/suite shall &lt;strong&gt;test against a sinle class in most of the time&lt;/strong&gt;, testing against multiple classes without abstraction generally makes tests fragile and hard to maintain; be careful when you want to bring multiple classes into SUT&lt;/li&gt;
  &lt;li&gt;A test case shall &lt;strong&gt;test against the public (exposed) interface&lt;/strong&gt; only, and consider the SUT (specific class) as black box as possible&lt;/li&gt;
  &lt;li&gt;A test case shall focus on the behavior (business intention) of its SUT than internal implementation, which are more subject to change&lt;/li&gt;
  &lt;li&gt;Different test cases shall be added to &lt;strong&gt;cover both normal scenarios and exceptional scenarios based on intention&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;A test case shall be as specific as possible, and shall have &lt;strong&gt;clear expectation and strict validation&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;DONOT try to cover more than one scenario in one test case, feel free to add more cases for exceptional scenarios&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;testing-interaction-with-mocksstubs&quot;&gt;Testing Interaction With Mocks/Stubs&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Be careful on heavy mocks, and &lt;strong&gt;add strong checks on matchers and set desired actions&lt;/strong&gt; if you want to validate the output (interaction) in customized mocks&lt;/li&gt;
  &lt;li&gt;Prefer grouping mocks in different test suites than organizing them in common functions, the latter is harder to maintain&lt;/li&gt;
  &lt;li&gt;Combine stubs with mocks wisely&lt;/li&gt;
  &lt;li&gt;DONOT create threads before careful reasoning - introducing threads to unit tests makes test cases hared to maintain and track&lt;/li&gt;
  &lt;li&gt;DONOT introduce real timers to test cases - advance a mocked timer to simulate the timeout behavior makes tests more stable and predictable&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Never sleep nor wait&lt;/strong&gt; in test cases&lt;/li&gt;
  &lt;li&gt;Make unit tests run fast as possible - generally one unit test shall not take over &lt;strong&gt;300 milliseconds&lt;/strong&gt; to finish&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;test-cases-groupingsuites&quot;&gt;Test Cases Grouping/Suites&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Generalize common operations and reuse them&lt;/strong&gt; as test fixtures that can be shared by multiple test cases&lt;/li&gt;
  &lt;li&gt;Prefer split big/complicated tests into smaller ones and group them according to logical abstractions - big tests typically indicates design smelly in SUT&lt;/li&gt;
  &lt;li&gt;DONOT create very large fixtures, consider ways to re-organize setups/fixtures by abstraction&lt;/li&gt;
  &lt;li&gt;Keep one test group (based on a common fixture typically) in one or more source files, &lt;strong&gt;DONOT&lt;/strong&gt; place irreverent tests in one source file&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://agilemodeling.com/artifacts/crcModel.htm&quot;&gt;Class Responsibility Collaboration(CRC) models: An Agile Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card&quot;&gt;Wikipedia:CRC Cards&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.laputan.org/mud/&quot;&gt;Big Ball of Mud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="programming" /><category term="test" /><category term="strategy" /><category term="guideline" /><summary type="html">To make large scale C++ software project in good shape is not an easy job, especially when you have a pretty big development team that may form multiple sub-teams. One of the key actions is to have common understanding on software design and testing strategies, rules and guidelines, which are far more important than simply coding guidelines.</summary></entry><entry><title type="html">Faster build optimization for large CMake based project</title><link href="http://www.skyscribe.me/post/2016/03/03/faster-large-cmake-project-build-optimization/" rel="alternate" type="text/html" title="Faster build optimization for large CMake based project" /><published>2016-03-03T00:00:00+08:00</published><updated>2016-03-03T00:00:00+08:00</updated><id>http://www.skyscribe.me/post/2016/03/03/faster-large-cmake-project-build-optimization</id><content type="html" xml:base="http://www.skyscribe.me/post/2016/03/03/faster-large-cmake-project-build-optimization/">&lt;p&gt;Building time is always a big concern for large scale C/C++ based software projects, there’ve been a lot of outstanding tools invented to relief the pain, CMake is an emering de-facto standard for big projects, however there’re lots of misuse that may slow down project building dramatically. This post would cover a real life case on how to correct those gotchas to improve build time and enable delta build to boost R&amp;amp;D efficiency.
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;In daily development work, engineers are frequently frustrated by the slow build system&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Even without no single line of code change, re-triggering the execution of test cases takes up to &lt;strong&gt;3 minutes&lt;/strong&gt; before testing results are given back&lt;/li&gt;
  &lt;li&gt;When build servers are busy (indicates more people are compiling), the feedback time would be longer&lt;/li&gt;
  &lt;li&gt;This would make TDD near to impossible and programmers just throw their changes to CI (Jenkins) jobs and let CI give them feedback.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;initiatives-from-ci-and-the-delima&quot;&gt;Initiatives from CI and the delima&lt;/h3&gt;
&lt;p&gt;Around 2015, solution development office already innovated a lot of smart ideas to shorten the CI efficiency, including&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Introduced &lt;strong&gt;scache&lt;/strong&gt; to share the intermediate object files to reduce unnecessary re-generating object files&lt;/li&gt;
  &lt;li&gt;Deployed multiple cloud instances and dispatched CI jobs to multiple cloud instances so jobs can run in parallel&lt;/li&gt;
  &lt;li&gt;Transformed to Git and Gerrit to alleviate the infamous check/export issues of subversion&lt;/li&gt;
  &lt;li&gt;Take the power of Gerrit and link CI jobs with every patch set on Gerrit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Above ideas are awesome from CI side, unfortunately daily TDD cycle is quite different with CI. For &lt;strong&gt;majority of the time, developers just want to change a small sub-set of the source code&lt;/strong&gt;, and they hardly need to rebuild the whole system. Every piece of efforts were invested on CI even makes programmers think their only rescue is to ask CI to do the build/testing. When they make some changes, they just &lt;del&gt;create a patch and throw it to Gerrit&lt;/del&gt;, do something else for a while and get back to check if Jenkins jobs are done with positive (or negative) feedbacks. Things do work well with their own downside:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Jenkins/CI becomes more busy&lt;/strong&gt; due to more and more engineers push their local changes (not verified locally) to CI&lt;/li&gt;
  &lt;li&gt;There is &lt;strong&gt;less and less room to improve from CI&lt;/strong&gt; side unless more budget can be assigned (allocate more cloud instances)&lt;/li&gt;
  &lt;li&gt;Programmers are still quite distracted due to &lt;strong&gt;task switches&lt;/strong&gt;(waiting for building/testing results), everybody knows it’s bad, and lots of them get depressed and think nothing can change&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;untouched-dark-side&quot;&gt;Untouched dark side&lt;/h3&gt;
&lt;p&gt;Looking at the Jenkins jobs of TDD CPRI, it is sad that every time the job is triggered, it will discard previous build space, and &lt;strong&gt;build everything from scratch&lt;/strong&gt;. Thanks to the &lt;strong&gt;clever scache&lt;/strong&gt;, most of the object files won’t be rebuilt, however each source file’s checksum has to be re-calculated and compared to ensure cache is still valid. This is quite non-trivial considering the fact that probably &lt;strong&gt;tens of (even hundreds of) engineers may work on the same Linux box&lt;/strong&gt;, let it alone strace is implemented in bash and the &lt;strong&gt;compare part relies on the time-consuming strace&lt;/strong&gt;. This also contribute to high system load and makes build servers slower and slower - some times we even see the shell is out of service due to memory swapping.&lt;/p&gt;

&lt;p&gt;The motivation sounds like pretty simple and intuitive - we need the &lt;strong&gt;incremental build&lt;/strong&gt;, so only changed part are really checked and rebuilt. If the computer (make system) has the &lt;strong&gt;correct and reliable&lt;/strong&gt; knowledge of what needs to be rebuilt, CPU resources can be saved, and feedback cycle would be significantly shortened.&lt;/p&gt;

&lt;p&gt;The challenges are also quite outstanding:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Increment build is hard though possible - too many factors may make it broken.&lt;/li&gt;
  &lt;li&gt;Keeping increment build stable and reliable is even harder - definitely true when your project demands a lot of 3rd party libraries/headers For&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fortunately things would be easier and the target is to reduce programmers cycle time, based on below facts&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Programmers typically stick to a fixed set to external resources for daily work, for most of his/her time&lt;/li&gt;
  &lt;li&gt;When external references change, we can still &lt;strong&gt;fall back to scache&lt;/strong&gt;, this only happens when people needs to merge/rebase code, and it is much safer to do clean build under such circumstances&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;domain-specific-buildtesting&quot;&gt;Domain specific build/testing&lt;/h3&gt;
&lt;p&gt;Another difference between CI and daily development cycle is: developers typically work in a narrow scope of the source tree, so they’re confident that their changes won’t break much. He/she may want to verify if small changes breaks legacy system or not, or if newly added code/tests works as expected or not.&lt;/p&gt;

&lt;p&gt;It is &lt;strong&gt;too over kill to build the whole system and run all the tests for such relatively trivial tasks&lt;/strong&gt;. Things would be perfect if we can &lt;strong&gt;do building/testing selectively, on a folder&lt;/strong&gt; (is generally called an internal domain). By narrowing down the scope, feedback cycle will be naturally shorter.&lt;/p&gt;

&lt;p&gt;Whenever a developer changes a few places and want to verify the impacts by unit tests (we like the idea of TDD, as long as it can be more practical), he/she only to follow below steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Identify the domain/folder under testing&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trigger a single build step that only build/test impacted parts:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Target source library can be successfully built and linked&lt;/li&gt;
      &lt;li&gt;Legacy test cases can be rebuilt and rerun&lt;/li&gt;
      &lt;li&gt;Newly added test cases (if any) can be automatically built and checked&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Building/test results can be given back shortly (&lt;strong&gt;by seconds would be optimal&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The Solution&lt;/h2&gt;

&lt;p&gt;Ideas being simple and straightforward, implementations/optimizations seldom are. Walking through the building system of TDD CPRI, below shortcoming has to be coped with:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mixed use of GNU make and CMake and the glue layer is complicated&lt;/li&gt;
  &lt;li&gt;3rd party libraries are stored on SVN as external references, while main codebase is managed by Git/Gerrit&lt;/li&gt;
  &lt;li&gt;A wrapper python script was written to generate hierarchical make files brings more complexity&lt;/li&gt;
  &lt;li&gt;CMake binary was wrapped by an external project and provisioned as &lt;em&gt;crosscmake&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;separate-developer-commands-from-ci-commands&quot;&gt;Separate Developer Commands From CI Commands&lt;/h3&gt;

&lt;p&gt;CI jobs take use of below commands:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make fsmf_target&lt;/code&gt; to generate package for entity testing&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make fsmf_test&lt;/code&gt; to generate testable for UT/MT&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make fsmf_test_run&lt;/code&gt; to run previously generated test cases&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make fsmf_clean&lt;/code&gt; to cleanup whole build workspace&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Almost all above commands would invoke &lt;strong&gt;slow svn commands&lt;/strong&gt; to do sanity checking on external links, and trigger external CMake system. &lt;strong&gt;This is not needed for daily usage&lt;/strong&gt; and can be skipped.&lt;/p&gt;

&lt;p&gt;For daily work, developer may need to verify below typical scenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If test build pass, check if UT/MT works&lt;/li&gt;
  &lt;li&gt;Verify changes for a given domain can pass compile for UT/MT binaries&lt;/li&gt;
  &lt;li&gt;Verify if source changes can still make a valid knife/package&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Introducing extra command line options can alleviate the work so Make system can detect what would be done.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If user passes &lt;code class=&quot;highlighter-rouge&quot;&gt;domain=bbswitch&lt;/code&gt;, only bbswitch domain specific targets would be rebuilt.&lt;/li&gt;
  &lt;li&gt;If user passes &lt;code class=&quot;highlighter-rouge&quot;&gt;use_gcov=1&lt;/code&gt;, coverage flag would be turned on - not a typical scenario for daily development jobs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In case people want to verify multiple domains, a list of domains can be supported, this facility further reduce the requirement to invoke building everything.&lt;/p&gt;

&lt;h3 id=&quot;keep-cmake-cache-as-reliable&quot;&gt;Keep CMake Cache As Reliable&lt;/h3&gt;

&lt;p&gt;Legacy make scripts (the top wrapper) manages the CMake sub-system, and translate user commands into internal CMake sub-system. For some reason, the cached files are re-configured and generated each time people want to make something. This brings considerable overhead, &lt;strong&gt;CMake is not designed to work like this&lt;/strong&gt;, being a &lt;strong&gt;Meta-build system&lt;/strong&gt;, it’s better to respect CMake and let itself to manage its build system’s integrity.&lt;/p&gt;

&lt;p&gt;The solution is simple once external factors that may invalidate CMake’s cache system are identified:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Things that impact compilation flags shall be controlled by CMake variables&lt;/li&gt;
  &lt;li&gt;Things that shall be decided by run time (like which domain to run tests) shall be passed as runtime parameters, than CMake variables - note each time a variable is changed, &lt;strong&gt;CMake has to be unnecessarily reconfigured&lt;/strong&gt;, and we want to reduce cache rebuilding as possible!&lt;/li&gt;
  &lt;li&gt;Give explicit target than relying on the &lt;strong&gt;default&lt;/strong&gt; make target - previously almost every sensible targets (libraries/binaries/custom_targets) were specified to be built by default; this makes a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;make &lt;/code&gt; command takes minutes to return&lt;/li&gt;
  &lt;li&gt;A few bugs were identified like test binaries were removed each time cmake refresh its cache, while linking is quite time consuming, and the old binaries should have been reused instead&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another subtle bug introduced by &lt;code class=&quot;highlighter-rouge&quot;&gt;crosscmake&lt;/code&gt; was also fixed due to the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake -H&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake -D&lt;/code&gt; options are not compatible. CMake system relies on &lt;code class=&quot;highlighter-rouge&quot;&gt;-H&lt;/code&gt; option to rebuild its make files as necessary, while crosscmake makes this impossible. It was suspected this would be one reason why global team choose to regenerate makefiles every time.&lt;/p&gt;

&lt;h2 id=&quot;benchmark-result&quot;&gt;Benchmark Result&lt;/h2&gt;

&lt;p&gt;Exciting results were perceived.&lt;/p&gt;

&lt;p&gt;Previously, no code change (simply invoking &lt;code class=&quot;highlighter-rouge&quot;&gt;fsmf_target&lt;/code&gt;) took 2~3 minutes to complete on a decent free Linux server. After those enhancements/optimizations, only &lt;strong&gt;7~8 seconds&lt;/strong&gt; were consumed to do the make stuff. Note in this scenario, no real code changes were made.&lt;/p&gt;

&lt;p&gt;When one or two files are changed, typically 1~2 binaries needs to be re-built besides the object file generation. The net time for make system checking can still be saved, extra gain comes from less targets scanned/linked. It typically takes &lt;strong&gt;10~30 seconds&lt;/strong&gt; to complete, while in the past, we need to wait &lt;strong&gt;4~6 minutes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When large amount of code changes are made, the benefit might be less obvious since the C++ compilation/linkage time dominates the overall time slices.This is right the place where &lt;strong&gt;scache&lt;/strong&gt; are designed for.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;This is of course not the end of our story - we don’t touch the incremental build part of CI yet and it’s full of potential. The characteristics of CI is quite different with daily development, however below ideas would be interesting:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Take use of better file system to boost compiling speed, like using memory mapped file system - a lot of GCC’s runtime are spent on IO&lt;/li&gt;
  &lt;li&gt;Saving previous workspace (or tagged workspace) and not cleaning everything&lt;/li&gt;
  &lt;li&gt;Using distcc/ninja for better C++ building performance&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="build" /><category term="tools" /><category term="cmake" /><category term="cpp" /><summary type="html">Building time is always a big concern for large scale C/C++ based software projects, there’ve been a lot of outstanding tools invented to relief the pain, CMake is an emering de-facto standard for big projects, however there’re lots of misuse that may slow down project building dramatically. This post would cover a real life case on how to correct those gotchas to improve build time and enable delta build to boost R&amp;amp;D efficiency. Background In daily development work, engineers are frequently frustrated by the slow build system</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - 4</title><link href="http://www.skyscribe.me/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - 4" /><published>2013-08-24T19:32:00+08:00</published><updated>2013-08-24T19:32:00+08:00</updated><id>http://www.skyscribe.me/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4</id><content type="html" xml:base="http://www.skyscribe.me/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4/">&lt;p&gt;本文是第四部分，主要讨论方法论和方法设计的一些基本规则，已经如何清晰地&lt;strong&gt;定制和应用&lt;/strong&gt;这些规则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/14/agile-software-development-the-cooperative-game-reading-2/index.html&quot;&gt;第二部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/18/agile-software-development-the-cooperative-game-reading-3/index.html&quot;&gt;第三部分&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;构建发布软件的生态系统&quot;&gt;构建发布软件的生态系统&lt;/h2&gt;

&lt;p&gt;方法论的目的在于使用所有可行的手段来保证我们可以发布预期的软件，并且这样的方法是可以&lt;strong&gt;确定持续&lt;/strong&gt;进行的。方法学本身即使社交行为的创建过程。方法本身是一个关于职位描述，过程，团队中每个人需要遵守的传统的集合。&lt;/p&gt;

&lt;p&gt;每一个组织都有自己的方法论，这些方法就是他们怎样做商业的方式。一种方法论可以说是你的组织同意采取的一种传统；这些过程可能在大部分公司并没有很正式的打印出来或者写下来。这种一致同意的传统需要我们不时得&lt;strong&gt;重新审视&lt;/strong&gt;，&lt;strong&gt;持续的&lt;/strong&gt;构建。&lt;/p&gt;

&lt;h2 id=&quot;方法论概念&quot;&gt;方法论概念&lt;/h2&gt;

&lt;p&gt;方法论是关于一些方法的固化和规则定义，其对过程的约束是它不同于方法本身的地方 - 你可以在不同的时候采用不同的方法；然而在一系列开发过程中，方法论代表着一直认可的基本规则和约定。&lt;/p&gt;

&lt;p&gt;集合一群聪明人又想获得成功，我们就必须做好协调/合作和协调，离开这些手段，最聪明的人组合的团队也会变得杂乱无章，从而很难取得成功。&lt;/p&gt;

&lt;h3 id=&quot;结构性术语&quot;&gt;结构性术语&lt;/h3&gt;

&lt;p&gt;方法学有如下几个结构性要素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;角色：明确的角色分工至关重要，什么样的角色需要什么样的&lt;strong&gt;职责和技能&lt;/strong&gt;等&lt;/li&gt;
  &lt;li&gt;技能：角色需要的技能和专长&lt;/li&gt;
  &lt;li&gt;团队：不同的情况之下工作于一起的一种集体角色&lt;/li&gt;
  &lt;li&gt;技术：赖以完成具体工作的技术技能，关于怎样完成某种特定工作的一些知识&lt;/li&gt;
  &lt;li&gt;活动：人们怎样完成某些特定工作的过程，譬如计划，编码，测试等&lt;/li&gt;
  &lt;li&gt;过程：各种各样的活动如何连接在一起&lt;/li&gt;
  &lt;li&gt;工作产品： 可以是中间过程的产出，如CRC卡或者故事卡片等&lt;/li&gt;
  &lt;li&gt;里程碑：一些关键的时间节点，往往是关于整体进度的一个节点&lt;/li&gt;
  &lt;li&gt;标准：关于一些工具/类库/方法的一些传统/约束等&lt;/li&gt;
  &lt;li&gt;质量：关于活动和工作产物的质量属性&lt;/li&gt;
  &lt;li&gt;团队价值：什么样的价值被大家普遍认可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的方法论在上述的要素上有很多各不相同之处。&lt;/p&gt;

&lt;p&gt;依据上述的结构性要素，常见的方法类可以划分为以下类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Normative方法，强调采用的步骤或者解决方案是完全遵守已有的工作记录。&lt;/li&gt;
  &lt;li&gt;Rational方法，基于工具和方法来构建&lt;/li&gt;
  &lt;li&gt;Participative方法，基于利益相关方和客户参与的方面&lt;/li&gt;
  &lt;li&gt;Heuristic方法，基于已经学习得到的经验，启发式进行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很多情况下，随着人们经验的基积累，方法论可能沿着Heuristics的方法慢慢固化下来，慢慢演进到Normative方法；譬如在计算机编程领域，算法设计方面就达到了标准化的地步；而关于将人们放在开放的办公区还是私有的办公室的方面却没有。&lt;/p&gt;

&lt;p&gt;大部分的软件开发货活动还处于&lt;strong&gt;Heuristic方法就足够适用&lt;/strong&gt;的阶段。&lt;/p&gt;

&lt;h3 id=&quot;范围&quot;&gt;范围&lt;/h3&gt;

&lt;p&gt;一种方法论的范围涵盖了关于它要关注的角色范围和相关的一些活动。早期的面向对象方法论被认为是设计师作为核心的角色，活动主要是讨论技术工具和描述对应标准图形的活动；然而这样的描述&lt;em&gt;不够宽泛&lt;/em&gt;的同时，又显得&lt;strong&gt;限制太多&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;方法论的范围可以被概括为如下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生命周期的覆盖，什么时间开始，什么时候结束&lt;/li&gt;
  &lt;li&gt;角色覆盖，什么样的角色参与什么样的活动&lt;/li&gt;
  &lt;li&gt;活动覆盖，什么样的活动在什么样的情况下开展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从这样的角度看，早起的面向对象方法仅仅局限于讨论一个很狭窄的领域，只有设计师参与，仅仅关系到项目设计阶段，从而导致经验丰富的面相对象设计师认为他们不适合参与项目的整个生命周期。从这些因素来考虑，有助于我们更好的理解怎样的方法论在怎样的场景下是更合适的。&lt;/p&gt;

&lt;h3 id=&quot;概念性要素&quot;&gt;概念性要素&lt;/h3&gt;

&lt;p&gt;为了更好的设计和定制方法论，我们需得考虑如下一些要素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方法论本身的规模大小，有多少标准，活动，质量度量物，技术描述等&lt;/li&gt;
  &lt;li&gt;正规性，多大的精度控制和什么程度的过程控制是需要的，是否需要更严格的控制和错误容忍率&lt;/li&gt;
  &lt;li&gt;方法论的重度，控制元素的个数，流程/活动的数目&lt;/li&gt;
  &lt;li&gt;问题域大小，需要多少问题去解决，&lt;strong&gt;内部复杂性&lt;/strong&gt;如何&lt;/li&gt;
  &lt;li&gt;项目本身的大小，&lt;strong&gt;多少个人&lt;/strong&gt;需要协调&lt;/li&gt;
  &lt;li&gt;系统重要性，如果发生了错误，造成的损害如何，是仅仅&lt;strong&gt;损失钱财还是造成人命有关的灾难&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;精确度如何，譬如设计的粒度如何，高层设计到什么样的程度为好&lt;/li&gt;
  &lt;li&gt;准确度，怎样更接近真是精确度，如何算好&lt;/li&gt;
  &lt;li&gt;相关性，什么样的讨论是不相关的&lt;/li&gt;
  &lt;li&gt;错误容忍度&lt;/li&gt;
  &lt;li&gt;可见行 - 外部怎么知道某种方法论是否被很好遵循，是否需要审计等&lt;/li&gt;
  &lt;li&gt;扩展性&lt;/li&gt;
  &lt;li&gt;稳定性 - 多大程度上它可能发生变化&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;发布一种方法论&quot;&gt;发布一种方法论&lt;/h3&gt;

&lt;p&gt;发布方法论需要发布两种组件，一时可视的&lt;strong&gt;形象化视图&lt;/strong&gt;，一是&lt;strong&gt;文本&lt;/strong&gt;本身。形象化的视图可能无法显示实践/标准和其它一些对组织很重要的协作方式描述。这些信息很难作出一个形象化的视图来呈现，这时候我们必须用文本来列出来。&lt;/p&gt;

&lt;p&gt;发布出来的方法论文本需要描述技术/活动/会议/质量度量/工作角色的指责标准这样的东西。方法论的文本可能变得异常庞大，即使一个很&lt;em&gt;细微&lt;/em&gt;的方法论，譬如只有4种角色，每种角色只有4种产出，每个产出只有4个里程碑，最终也会产生出&lt;strong&gt;68=4+16+48&lt;/strong&gt;个互锁的子部分需要描述清楚。即使是以轻量级著称的XP方法论，最初只有200页那么多，现在已经达到了1000页才可以描述清楚。&lt;/p&gt;

&lt;p&gt;但是很多时候，公司组织并不会将这些东西打印出来，因为&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;理解这些比文档本身重要 - Jim Highsmith&lt;/li&gt;
  &lt;li&gt;组织的需求总是在变化的，固定下来的文本很容易过时也没有实用性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组织需要不断的演进既有的方法论，变更不合适的部分，在组织内部的&lt;strong&gt;不同团队之间传递好的习惯和实践&lt;/strong&gt;。有很多中方法来减少这些方法论文本的厚度:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提供工作产出物的范本&lt;/li&gt;
  &lt;li&gt;移除技术操作指南，让人们用更自然的方式协作&lt;/li&gt;
  &lt;li&gt;根据角色来组织方法论文本，某种产出物按照不同的角色给出简单的描述&lt;/li&gt;
  &lt;li&gt;做些关于流程的小实践，通过小的练习实践这些方法，然后再用于具体的工作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;方法论设计原则&quot;&gt;方法论设计原则&lt;/h2&gt;

&lt;h3 id=&quot;常见的设计错误&quot;&gt;常见的设计错误&lt;/h3&gt;

&lt;h3 id=&quot;成功的方法论项目&quot;&gt;成功的方法论项目&lt;/h3&gt;

&lt;h3 id=&quot;作者敏感度&quot;&gt;作者敏感度&lt;/h3&gt;

&lt;h3 id=&quot;七大准则&quot;&gt;七大准则&lt;/h3&gt;

&lt;h2 id=&quot;审视xp&quot;&gt;审视XP&lt;/h2&gt;

&lt;h2 id=&quot;究竟为何需要方法论&quot;&gt;究竟为何需要方法论&lt;/h2&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第四部分，主要讨论方法论和方法设计的一些基本规则，已经如何清晰地定制和应用这些规则。</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - 3</title><link href="http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - 3" /><published>2013-08-14T20:32:00+08:00</published><updated>2013-08-14T20:32:00+08:00</updated><id>http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3</id><content type="html" xml:base="http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3/">&lt;p&gt;本文是第三部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/14/agile-software-development-the-cooperative-game-reading-2/index.html&quot;&gt;第二部分&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;信息交换和流动&quot;&gt;信息交换和流动&lt;/h2&gt;

&lt;p&gt;如果我们将软件开发活动看作是协作游戏，那么如果Kim知道一些Pat需要的信息，则项目的进度就取决于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pat需要花多少时间了解到Kim知道他想要的信息&lt;/li&gt;
  &lt;li&gt;Pat和Kim需要耗费多少时间和其它成本来完成对于信息的交流和转移&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;各种情况的开销&quot;&gt;各种情况的开销&lt;/h3&gt;

&lt;p&gt;有六种不同的情况可以考量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Kim和Pat在同一台计算机前做结对编程，这样的交互成本几乎为零。&lt;/li&gt;
  &lt;li&gt;Kim和Pat在相邻的位置上；Pat可以通过观察Kim知道他可能在找某些东西而他恰好知道 - 有一些发现问题的成本&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在两个背对的位置，只有Kim主动提出问题，否则Pat不可能知道他想要某些信息&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在一个有一堵墙隔开的相邻位置，Kim必须站起来，看看Pat是否在位置上，然后才能交互信息&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在不同的隔间，甚至不同的楼层，kim必须走过去看看，这时候Pat可能不在位置上！&lt;/li&gt;
  &lt;li&gt;Kim和Pat在不同的办公区或者不同的地方，他们的沟通和交互就很少能有效和及时&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果用需要花费的时间和精力为参考单位（ergo-seconds），那么上述不同情况的开销是递增的。项目成本的上升是和人们需要花费多少时间来理解彼此的想法是&lt;strong&gt;成正比&lt;/strong&gt;的。&lt;/p&gt;

&lt;h3 id=&quot;osmotic-communication&quot;&gt;Osmotic Communication&lt;/h3&gt;

&lt;p&gt;写代码/阅读/学习的同事，我们随时提取周围环境中发生的谈话，利用背景噪音的模式，选取我们关心的内容随时参与讨论，对于不关心的则过滤出去。这种方式的沟通极大的降低了信息流动的成本。办公环境的部署过于分散可能有不提问题造成的潜在时间开销，信息传输的开销和人们无法在谈话中随时给出意见的额外开销。根据此理论，赞助物理分散的分布式团队需要三思而行。然而简单将所有人扔在一起也未必像相像的那样可以很好的解决问题。&lt;/p&gt;

&lt;p&gt;人们在传递什么样的信息？团队个人的习惯偏好如何？不同种类的信息是否会相互干扰？很常见的做法是，将负责实现的程序员安排在大楼的一侧，而将负责需求分析和商业策略领域专家安排在另一侧；因为他们彼此讨论的话题往往形成很强的噪音。然而这种方式也有明显的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;两者之间沟通的成本变高&lt;/li&gt;
  &lt;li&gt;两个团体可能形成自己小的社区并进而对对方进行指责和抱怨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cockburn的偏好是将一个商业专家安排在几个程序员的中间；如果做不到，那么通过其它的方式加强他们之间的沟通和理解，譬如定期的会议，审查等。Feature team的做法是鼓励跨只能的团队，用Feature的方式将各个领域的人聚集在一个团队，减少信息沟通的成本，加快信息的流动。&lt;/p&gt;

&lt;p&gt;个人偏好也是个需要考虑的问题，譬如有的程序员就是喜欢自己安静的空间，不希望有很多的背景噪音干扰。还有些人对哪些人在自己的周围有强烈的偏好 - 如果某个高级的程序员由此选择离开，那么成本之高就变得无法接受。因此调整位置的时候，需要尽量考虑到个人的偏好。&lt;/p&gt;

&lt;h3 id=&quot;信息辐射器&quot;&gt;信息辐射器&lt;/h3&gt;

&lt;p&gt;信息辐射器可以显示任何一个路过的人都可以看到的关于项目的信息；这样他们就不会专门跑过来问某些上面已经有的信息。这样做的好处有两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;辐射器上的信息总是随着时间的变化在实时更新&lt;/li&gt;
  &lt;li&gt;人们花费很少的精力就可以注意到这些信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;白板墙可以作为很好的信息辐射器，而公共的Wiki或者Web页面就不是；因为人们不用什么力气就可以随时看到墙上的东西，而web页面需要人们动鼠标打开那个网址。&lt;/p&gt;

&lt;p&gt;人们可以用辐射器显示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下个迭代的任务分解情况&lt;/li&gt;
  &lt;li&gt;每天的任务完成进度情况 - burndown chart等&lt;/li&gt;
  &lt;li&gt;自动化测试通过情况和通过率&lt;/li&gt;
  &lt;li&gt;回顾会议的输出&lt;/li&gt;
  &lt;li&gt;验收测试通过情况&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;热空气理论应用&quot;&gt;热空气理论应用&lt;/h3&gt;

&lt;p&gt;很多公司都意识到在咖啡机旁边放一些白板或者宣传栏的益处。人们可以在停下来聊天的时候注意到这些公开的信息。但是还有一个重要的地方不能漏掉的是，我们要尽量确保这些东西在视线之内，或者可以被清晰的听到。人们在讨论某些东西的时候，可以在身边随手可得的白板上写下自己的设计思路和想法，快速的和对方沟通。&lt;/p&gt;

&lt;p&gt;任何一个项目团队都应该力求&lt;strong&gt;减少发现和传递信息的整体开销&lt;/strong&gt;。这意味着随时发现并加速信息的流动和交换，利用Osmotic Communication的好处，注意潜在的问题和限制，最终减少成员之间信息交换的成本，搬开座位安置不合理造成的障碍。&lt;/p&gt;

&lt;h2 id=&quot;跨越沟通交流的沟壑&quot;&gt;跨越沟通交流的沟壑&lt;/h2&gt;

&lt;p&gt;为了提高沟通的效率，我们需要提高信息的发送方和接受方在可能存在沟通障碍的时候能够尽最大的可能跳过这些障碍的可能性。双方应该能以最快速方便的方式提供反馈，并尽可能地&lt;strong&gt;消除&lt;/strong&gt;可能存在的希望表达的&lt;strong&gt;意识偏差&lt;/strong&gt;。人们在沟通的时候，很可能使用语言之外的其它方式来表述意图(可能是积极的但也可能是消极的负面反馈)，如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;距离上的疏远或者靠近&lt;/li&gt;
  &lt;li&gt;空间感觉和反应(视频聊天就在这方面缺失了空间信息)&lt;/li&gt;
  &lt;li&gt;人身上的体味对方是否习惯或者反感&lt;/li&gt;
  &lt;li&gt;肢体上的接触&lt;/li&gt;
  &lt;li&gt;声音语调的变化&lt;/li&gt;
  &lt;li&gt;肢体语言&lt;/li&gt;
  &lt;li&gt;提问回答的热情程度&lt;/li&gt;
  &lt;li&gt;是否有其它方面的干扰&lt;/li&gt;
  &lt;li&gt;相互之间的信任和愿意从对方学习的情绪&lt;/li&gt;
  &lt;li&gt;是否使用共享的信息辐射器来共享常见的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上边这些因素和机制利用得当能够极大的提高沟通的效率。反之，移除其中一些，人们就不得不用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;电话 - 无法从物理上解除对方&lt;/li&gt;
  &lt;li&gt;电子邮件 - 没有声音&lt;/li&gt;
  &lt;li&gt;单向的沟通&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果这些机制都没有被很好的利用，就会出现&lt;em&gt;文档作为沟通的主要方式&lt;/em&gt;。因而好的项目领头人会推荐如下这些实践：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将所有人丢在一个会议室里边&lt;/li&gt;
  &lt;li&gt;保持每个团队的短小精干&lt;/li&gt;
  &lt;li&gt;多用白板表述意图，而不是负责的绘图软件&lt;/li&gt;
  &lt;li&gt;办公区的白板和咖啡角随处易得&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然这些warmmer communication方式仅仅使用于传递想法和真正沟通的时候。传统的cooler communication方式仍然在其它一些场合发挥着重要作用。如果一个高级设计人员在会议中始终占据着发言权和白板，那么系统自组织性的丧失就会很快让沟通变得更加的困难。邮件的允许人们发送之前仔细审视的特点更容易让人们澄清他们真正表述的观点 - 如果这些观点需要慎重的思考的话。&lt;/p&gt;

&lt;h2 id=&quot;团队即社区&quot;&gt;团队即社区&lt;/h2&gt;

&lt;p&gt;一个团队即时一个社区，每时每刻都有很多信息在流动；但是每个团队个体成员可能有不同的兴趣和目标，有自己的专长和侧重。在一个高效的团队中，成员通过&lt;strong&gt;pull&lt;/strong&gt;的方式提取自己感兴趣的信息，反馈给其它成员。人们根据&lt;strong&gt;整个团队的方向&lt;/strong&gt;来协调这些信息的讨论和流动；因此整个团队需要保持一致的方向。&lt;/p&gt;

&lt;h3 id=&quot;小幅度改进&quot;&gt;小幅度改进&lt;/h3&gt;

&lt;p&gt;只需要让每个人改变一个小小的方面 - 这些方面很可能对他个人而言是无足轻重的，最终也可以带来很大的整体效应；因为每个人都向着共同的目标改进一小点，所以每个人对变化的感受都是很细微的，但是因为人们对其它密切相关的同事贡献出他自己的想法，而不是各干各的，最终整个团队的效率会得到巨大的提升。&lt;/p&gt;

&lt;p&gt;为了达到真个团队大方向上的一致，开发人员和项目利益相关人需要讨论和定制每个成员都需要认可的整体决策，这也同时要求很多决定必须是&lt;strong&gt;团队整体的承诺&lt;/strong&gt;而不是经理们的个人意愿。在项目发展的过程中，优先级可能发生巨大的变化或者调整，这个时候，所有人必须被重新集中起来沟通这些变化，确保所有人都知道并且同意这个变化。&lt;/p&gt;

&lt;h3 id=&quot;冲突和纪律&quot;&gt;冲突和纪律&lt;/h3&gt;

&lt;p&gt;团队保持紧密一致不意味着不能有冲突发生。一个团队中几乎没有冲突发生也是不正常的，因为这很可能意味着大家可能更愿意保持沉默不再说出自己的真正想法。&lt;strong&gt;当人们向团队中的其他人掩盖一些信息的时候，潜在的开支就默默地急剧上升&lt;/strong&gt;。人们需要在正常的冲突中讨论出最优的方案使得各方一致满意；这样的结果恰恰是更有利于最终问题的解决。&lt;/p&gt;

&lt;p&gt;良好的社区纪律需要人们用对他人有益（当然间接对自己有益）的方式来共事。它需要成员&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;按时参加会议&lt;/li&gt;
  &lt;li&gt;回答别人提出的问题，如果知道答案的话&lt;/li&gt;
  &lt;li&gt;不烦于提出注意到的状况&lt;/li&gt;
  &lt;li&gt;遵从整体的编码规范/传统&lt;/li&gt;
  &lt;li&gt;使用一致的代码库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些要求对一些编码规范不满的程序员通过协商的方式定制出共同认可的编程风格 - 虽然个人可能不认可当前的规范，但是通过协商得到&lt;em&gt;稍微看得过去的&lt;/em&gt;规范也比完全没有强。当然，这些纪律需要尽可能在正常的工作时间内实施，而不是通过&lt;strong&gt;加班&lt;/strong&gt;来延长工作时间。&lt;/p&gt;

&lt;h3 id=&quot;团队建设&quot;&gt;团队建设&lt;/h3&gt;

&lt;p&gt;好的团队建设最好的方式是通过一些小小的成功来实施，不管是多小或者多大的成功。混乱的大规模团队建设活动在很多情况下可能仅仅是浪费钱财。真正的团队建设可以通过&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使团队正在凝聚在一起 - 譬如让物理上分散的团队能尽量经常见面，通过共同的工作取得一些进展，然后不时将这些人放在一些社交活动中。&lt;/li&gt;
  &lt;li&gt;产生成绩 - 这样可以产生和传递&lt;strong&gt;正能量&lt;/strong&gt;，消除恐惧和不信任感。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;团队文化背景差异和协作&quot;&gt;团队文化背景差异和协作&lt;/h3&gt;

&lt;p&gt;团队的沟通和交互需要更多的采取&lt;strong&gt;协作而非合作&lt;/strong&gt;的形式。协作意味着人们通过频繁的交互和沟通达成一致意见，而合作则意味着通过分工/各自独立工作/集成的方式来达成目标。不同的文化背景可能对这些方面有不同的假设前提，不过敏捷方法论的做法是尽可能得通过协商达成一致。&lt;/p&gt;

&lt;p&gt;具有多个领域特长的专家（譬如精于项目管理和设计倾听的程序员）可以在不同的对象之间充当翻译，以便提高不同的专业人员之间的沟通效率。每一个人都需要更多的联系实践和倾听的技巧：&lt;strong&gt;不管对方的看法多么的疯狂和颠覆，先那样听，然后再决定是否要反对&lt;/strong&gt;，因为那些疯狂的论断可能在另外一个价值体系里边确实司空见惯的常识。&lt;/p&gt;

&lt;h2 id=&quot;视团队为生态系统&quot;&gt;视团队为生态系统&lt;/h2&gt;

&lt;p&gt;一个软件项目的建立同时也创建了一个新的生态系统，这个系统由特质各异/文化背景相左的个体组成。观察这个生同系统的要素，我们可以得到&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;办公室的墙壁成为隔离的壁垒，公共的空间提供交互场所&lt;/li&gt;
  &lt;li&gt;特性各异的个体好比不同的物种&lt;/li&gt;
  &lt;li&gt;每一个具有不同特性的个体的工作方式极大得影响着整个生态系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个项目团队都是独一无二的，原则上并没有太具体的原则和实践可以误差别地施加于你的团队。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有团队中的人才可以决定什么样的方式在那个特定的环境中工作的更好 - 调整环境来服务你的团队&lt;/li&gt;
  &lt;li&gt;如果团队中一些人有很好的方法学知识，他就能很好的回顾和反思他观察的并逐步改进 - 发现每个人的长处，找到一个最好的方式以便发挥各自的优势&lt;/li&gt;
  &lt;li&gt;视每个团队的方法实践为一种&lt;strong&gt;新的建设&lt;/strong&gt;，没有一种现有的办法可以不经修改完全适用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键的团队自身需要通过不断的反思来自适应，逐步改进工作的方法，并逐渐找到更优的方式。&lt;/p&gt;

&lt;h2 id=&quot;ken-auer的程序员办公室&quot;&gt;Ken Auer的程序员办公室&lt;/h2&gt;

&lt;p&gt;这是一种典型的值得参考的办公环境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个大的用于编程的房间，中间是结对编码区域，四个长桌子围成长方形，人环座四周，长的一侧的桌子允许两对人工作，短的一侧允许一对，这样可以容纳最多12个人结对&lt;/li&gt;
  &lt;li&gt;编程办公室的四周靠墙壁的地方放置用于私人空间的编程工作 - 人们可以再这里创建私有的空间来做一些不受打扰的思考工作&lt;/li&gt;
  &lt;li&gt;编程办公室的南边是接待室和销售人员办公室，设备和浴室也在这一块儿空间；接待室在中间相隔，实现动静分离&lt;/li&gt;
  &lt;li&gt;编程办公室的西边是厨房和与之相隔的更远一点的会议室&lt;/li&gt;
  &lt;li&gt;西南是图书馆和客户办公室，图书馆在中间做一个动静分隔的作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;待续。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第三部分。</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - part2</title><link href="http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - part2" /><published>2013-08-14T20:32:00+08:00</published><updated>2013-08-14T20:32:00+08:00</updated><id>http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2</id><content type="html" xml:base="http://www.skyscribe.me/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2/">&lt;p&gt;本文是第二部分(&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;)。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;作为个体的人&quot;&gt;作为个体的人&lt;/h2&gt;

&lt;p&gt;人们常常选择性的忽略了软件开发和实际过程是由一个一个的&lt;strong&gt;个体的人&lt;/strong&gt;来完成的；然而人都有弱点，容易犯错，有固定的失败模式/成功模式，以及通用的行为模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;人们的行为通常是难以预测的&lt;/li&gt;
  &lt;li&gt;人性本身有些固有的失败模式&lt;/li&gt;
  &lt;li&gt;总有一些方式比另外一些方式更容易让人们共同工作，即使对同样一群人&lt;/li&gt;
  &lt;li&gt;有很多模式引起失败，那么什么样的方式才能达成成功?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;人的行为模式&quot;&gt;人的行为模式&lt;/h3&gt;

&lt;p&gt;人的行为总是非线性的并且比一般的物理实体复杂的多；给予双倍的奖励，或者双倍的惩罚，甚至于双倍的时间，都不能确定的提高一个人的思考速度/思考质量/编程设计输出。一个每周工作40个小时的人可能在下周工作60个小时就可以得到双倍的进展，但是接下来一周再工作60个小时，可能不仅不能维持之前双倍的效率，可能反而不及最初正常的效率，因为人们会产生疲惫。&lt;/p&gt;

&lt;p&gt;人的行为会突然发生偶然的变化，某某可能突然对测试工作发生兴趣；一个偶然的小事儿可能导致一个高级工程师的离开等；某个工程师可能在一种情况下显得特别容易沟通而换了一种环境则会变得难以沟通。人们协作的方式也可能有巨大的差异，不同的文化背景可能青睐于不同的沟通方式；直接或者保守在不同的文化氛围中显得完全不同。真因为这些不可避免的差异，所以才有各种各样的技术方法被发明出来，然后，&lt;strong&gt;没有一种方法是绝对有效&lt;/strong&gt;的。这个结论是明显的，然后人们往往容易忽略之，而盲目的鼓吹某种方法是&lt;strong&gt;正确&lt;/strong&gt;的方式并且期望所有人按照这种方式来工作。&lt;/p&gt;

&lt;p&gt;人的行为在很多方面表现出巨大的不同，并不意味着一些通用的方法就没有意义；还是有些东西在很大的范围内行之有效的。基于此，我们就可以在承认人与人之间巨大差异的基础上来建立大家认可的方法，但是并不能由此期望人们的具体行为会趋同或者可以严格预测。&lt;/p&gt;

&lt;p&gt;有效的过程方法的意义在于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;允许人们更容易地表述他们的想法&lt;/li&gt;
  &lt;li&gt;可以完成一个人无法独立完成的工作&lt;/li&gt;
  &lt;li&gt;将复杂而又繁琐的工作自动化&lt;/li&gt;
  &lt;li&gt;使得人们的相互沟通更容易&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;失败模式&quot;&gt;失败模式&lt;/h3&gt;

&lt;p&gt;有如下五种比较普遍的失败模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;人们总是会犯错&lt;/strong&gt; - 简单但又常常被人们忽略；敏捷和迭代开发的巨大进步意义就在于承认人总是会出错，但是通过一连串小的错误来及早暴露风险；持续不断的解决问题而不是固守详细周密的计划 - 没有错误的计划似乎只存在于真空之中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;倾向于保守谨慎&lt;/strong&gt; 在最终结果一致的情况下，同样的问题通过不同的方式呈现出来，人们的反应却有可能大不相同。当我没可能获得比较高的潜在收益的时候，人们总是倾向于去冒险，然后在可能失去某些东西的时候，人们则会倾向于选择更保守的方式。一个有很多瀑布模式成功经验的manager（其实这些成功的经验有多大程度上算作成功就很难考量）在一个初级的工程师提出尝试迭代开发的模式的时候可能持激烈的反对态度；他可能更愿意采用传统的策略，能产生“确定“的输出而不是”可能产生更大收益“但是又”看起来奇怪“的方式&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;习惯的不一致性&lt;/strong&gt; 如果人们总能保持一致，那么就不会有减肥/锻炼的问题。问题是&lt;strong&gt;我们从来不缺少方法实践，缺少的恰恰是实践这些方法&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;倾向于发明新的东西而不是研究已有的方案&lt;/strong&gt; 大概跟人们接受的教育有关 - 鼓励原创的论文/独立完成的作业等等；而不是团队工作。很多时候人们需要更好的重用已有的成果而不是自己从头发明一切&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自律和适当容忍的妥协&lt;/strong&gt;  强调高度的自律往往是一厢情愿，然后过度的妥协又容易导致越来越多的混乱。项目经理可能对严格要求团队遵循某个方法实践所带来的副作用感到惊讶。譬如XP实践强调结对编程和Coach，然后很多Team在实践的过程中却将重构的工作丢下不理，等待更高级的工程师去做&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;某些方式总是比其它的更好&quot;&gt;某些方式总是比其它的更好&lt;/h3&gt;

&lt;p&gt;尽管人与人之间的差异是巨大的，然而总有一些方法是更有效的。人们倾向于做的更好，如果他们&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从具体的例子开始&lt;/li&gt;
  &lt;li&gt;从容易处理的东西开始着手&lt;/li&gt;
  &lt;li&gt;从已有的东西入手寻找替代/优化的方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些方法也更容易让人们取得积极的进展：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过观察和学习的同时做工作&lt;/li&gt;
  &lt;li&gt;支持精力集中的思考并同时支持积极的沟通 - 设置安静时间和公共沟通区域来加强沟通&lt;/li&gt;
  &lt;li&gt;根据人们的长处进行任务分配&lt;/li&gt;
  &lt;li&gt;选择最好的人才&lt;/li&gt;
  &lt;li&gt;激励方式的选择 - 开发人员的工作激情/成就感/贡献荣誉感觉&lt;/li&gt;
  &lt;li&gt;清晰有效的反馈 - 越及时效果越好&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;寻找成功模式&quot;&gt;寻找成功模式&lt;/h3&gt;

&lt;p&gt;作者长期面试成功项目团队的经验中，如下的申明频繁的出现： &lt;strong&gt;一小部分人在关键的时间介入，作出了一切需要做的工作&lt;/strong&gt;。看起来是很随意的描述，然而更仔细的审视发现，如下的一些成功因素慢慢浮现出来:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;擅长于四处观望式的扫视 - 设计文档未必需要每一个细节都和实现保持一致，只要大致结构的一致即可。做维护工作的开发者就可以通过快速的浏览找到需要的部分，剩下的就是具体怎么做了，细节的准确意义并没有想的那么大了。文档只需要&lt;strong&gt;保持足够的精确&lt;/strong&gt;即可，能完成主要的工作，使得人们不用费很大功夫就可以找到对应的细节即可。Tech Lead仅仅需要大致看一下问题大概在什么地方并知道其它工程师去做即可，而不是处理每一个细节&lt;/li&gt;
  &lt;li&gt;人们持续不断的学习 - 敏捷过程提出的持续改进就是这么一个思想，回顾当前迭代中那些值得改进的，持续的需西和发现不足，人们就能不断的进步。&lt;/li&gt;
  &lt;li&gt;可以改变的韧性 - 通过团队的集体氛围来慢慢提高个体的韧性，使之适应并改变 - 当然并不是每个个人都可适应这个过程，然后他就会离开&lt;/li&gt;
  &lt;li&gt;主动承担和贡献&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;融合这些成功的因素&quot;&gt;融合这些成功的因素&lt;/h4&gt;

&lt;p&gt;是否有融合这些成功因素的方法存在？&lt;strong&gt;自组织团队&lt;/strong&gt;的想法给出了一种思路，但是实现的过程自然是充满崎岖的。需要培养这样的氛围，每个人都需要能够第一时间发现系统中的错误，不管这个人的职位和角色是什么；&lt;strong&gt;他将错误传递到能够正确纠正错误的人的成本&lt;/strong&gt;往往决定了&lt;strong&gt;整个项目的成本&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;平衡各种策略&quot;&gt;平衡各种策略&lt;/h2&gt;

&lt;p&gt;很多时候看起来很好的策略并不意味着在大部分情况都是好的 - 譬如让一个Team的成员坐在一起。&lt;a href=&quot;http://pmdoi.org&quot;&gt;PMDOI&lt;/a&gt;认为，我们可以通过具体情况具体分析的策略/工具和方法来真正提高效率和可靠性。一个真正好的策略需要平衡各种足够好的基本策略，将其打包调整其中的某些不合时宜的做法。想想人们常说的，坐在一起的团队和面对面的沟通总是能达到最好的效果；但是为了达到&lt;strong&gt;真正高效的沟通&lt;/strong&gt;(因为这才是&lt;strong&gt;最高优先级的事情&lt;/strong&gt;),我们还需考虑到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;人们有时候需要安静的思考和集中注意力的工作&lt;/li&gt;
  &lt;li&gt;有时候需要进行一些安静的对话来交换一些深思熟虑的意见&lt;/li&gt;
  &lt;li&gt;有时候需要放松的心态学习一些新的语言/工具等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Osmotic Communication要求人们做的足够的近以便周围人的谈话都很容易被听清楚，这样有什么问题就可以马上作出反应；信息传递的成本几乎为零。这样一些复杂的问题可能会被周围的专家以最快的速度解决。然后Cone of Silence策略则提出了一种相反的做法：一个或者多个团队成员坐得距离其它人远远的从而可以排除沟通干扰。但是这种策略也有典型的适用场合，譬如Tech Leader本来应该用于安排解决艰难负责的问题，然而由于周围的人不断得分散其注意力，导致复杂的问题没有被解决，进度不断被延误，进而导致情况更加恶化。Cockburn认为，相互沟通的两个人的距离超过一辆公交车的长度时，沟通的效果就会急剧下降。&lt;/p&gt;

&lt;p&gt;策略的平衡意味着，安排座位的时候需要考虑某些负面的影响 - 有些时候需要将人们适度分隔开来而不是聚越来越多的人在一个大的空间。当周围的噪音和干扰越来越大的时候，人们容易觉得压抑和头疼，很多重要的工作都无法正常的完成。每一种策略都有一定的限制；明智的决策什么时候&lt;strong&gt;Osmotic Communication&lt;/strong&gt;是有效的，什么时候它因为人太多而失去意义是个重要的事情。&lt;/p&gt;

&lt;p&gt;待续。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第二部分(第一部分)。</summary></entry></feed>