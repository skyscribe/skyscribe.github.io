<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="https://skyscribe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://skyscribe.github.io/" rel="alternate" type="text/html" /><updated>2017-06-24T23:16:21+08:00</updated><id>https://skyscribe.github.io/</id><title type="html">驭风万里无垠</title><subtitle>汇小流以成江海，积跬步以至千里</subtitle><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><entry><title type="html">Migrate blog to Jekyll</title><link href="https://skyscribe.github.io/post/2017/06/24/migrate-blog-to-jekyll/" rel="alternate" type="text/html" title="Migrate blog to Jekyll" /><published>2017-06-24T00:00:00+08:00</published><updated>2017-06-24T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2017/06/24/migrate-blog-to-jekyll</id><content type="html" xml:base="https://skyscribe.github.io/post/2017/06/24/migrate-blog-to-jekyll/">&lt;p&gt;之前本blog的内容是基于强大的&lt;a href=&quot;http://octopress.org/&quot;&gt;octopress&lt;/a&gt;生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的&lt;a href=&quot;http://octopress.org/2015/01/15/octopress-3.0-is-coming/&quot;&gt;新版本预告&lt;/a&gt;后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。&lt;/p&gt;

&lt;p&gt;很明显，&lt;strong&gt;octopress项目要死了&lt;/strong&gt;，这在开源软件社区是常有的事儿；但是活人不能被尿憋死，本来用octopress的目的也是因为 Jekyll 太抽象了想顺带找个近路学习学习前端知识；这些没有了借口，还是升吧。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;上新版本jekyll安装主题&quot;&gt;上新版本Jekyll，安装主题&lt;/h2&gt;

&lt;p&gt;最开始用octopress的时候，Jekyll还是 0.6 版本；这么多年过去，Github 团队官方已经发布了 3.0 版本了，功能支持的已经比较完善了。本身Jekyll是基于 gem 的，模块化做的非常好了，不像原来的 octorpess 直接fork一个代码就在里边改来改去，还要创建多个branch 防止无法升级的问题。按照 &lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;官方文档&lt;/a&gt; 的步骤按部就班即可。&lt;/p&gt;

&lt;p&gt;Jekyll支持&lt;strong&gt;丰富的插件&lt;/strong&gt;，生成好对应的site之后，修改配置文件就可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle update&lt;/code&gt; 来安装。但是默认的Jekyll主题太过于原始，所以找个适合自己口味的主题是首要的。因为本blog是托管在github上的，gith-hub pages &lt;a href=&quot;https://pages.github.com/themes/&quot;&gt;支持的主题&lt;/a&gt; 却&lt;strong&gt;比较有限&lt;/strong&gt;, 而且要没没有提供预览，要么提供的预览不适合个人口味。&lt;/p&gt;

&lt;p&gt;回头看Ocotpress发现其实现方式完全是自己生成页面的，不用Github自己的build系统；这里可以很容易的依法炮制，自己将所有的东西编译好，将生成的site内容给传上去即可。个人还是比较喜欢原来的 Octorpress提供的默认主题，简洁明快；所以最终选择的是 &lt;a href=&quot;https://mademistakes.com/work/minimal-mistakes-jekyll-theme/&quot;&gt;Minimal Mistakes&lt;/a&gt; ；浏览选择过程中，对 &lt;a href=&quot;http://phlow.github.io/feeling-responsive/&quot;&gt;Feeling Responsive&lt;/a&gt;主题也非常入眼，只是看起来文档比较复杂，可以留待以后尝试折腾下。&lt;/p&gt;

&lt;p&gt;Minimal Mistake主题支持比较多的设定，因为打算自己生成页面，所以采用类似fork的思路，安装&lt;strong&gt;自己想要的插件&lt;/strong&gt;（可以突破&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;Github-Pages的限制&lt;/a&gt;)，最后build成页面给push上去即可。&lt;/p&gt;

&lt;h2 id=&quot;自动同步&quot;&gt;自动同步&lt;/h2&gt;

&lt;p&gt;由于是自己手工编译生成静态内容，所以很希望有类似于Octopress的Rakefile，遗憾的是&lt;strong&gt;copy下来的Rakefile&lt;/strong&gt;不能正确执行。Google上search了一圈发现没有现成的方案，而且Github-pages的个人站点仅仅&lt;strong&gt;支持push到master分支&lt;/strong&gt;, 而&lt;del&gt;早期的时候是push到gh-pages&lt;/del&gt;分支的；这个细微的更新貌似很多google页面都没有提及；不过好在也不是很难发现，仅仅需要在自己site的设置页面查看build的分支就可以看到只能接受master分支了。&lt;/p&gt;

&lt;p&gt;自动化的工作最终写了个简单的shell脚本来完成, 基本的步骤是沿用 Octopress2 的步骤，设置2个入口&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一个用于初始化一个deploy目录，和github的站点内容保持同步，初始化git和remote等等。&lt;/li&gt;
  &lt;li&gt;另外一个用于每次更新内容，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 完成编译后，将生成的内容全部copy到deploy目录下，然后再同步到github的repository&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;deployDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_deploy
&lt;span class=&quot;nv&quot;&gt;siteDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/_site
&lt;span class=&quot;nv&quot;&gt;siteUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://github.com/skyscribe/skyscribe.github.io.git

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;setup&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    rm -fr &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    mkdir -p &lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git init
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dummy content&quot;&lt;/span&gt; &amp;gt; index.html
    git add .
    git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;dummy script init&quot;&lt;/span&gt;
    git branch -m master
    git remote add origin &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteUrl&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Setup complete for &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;deploy&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;jekyll build
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    cp -r &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$siteDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$deployDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&quot;&lt;/span&gt;
    git pull origin master
    git add -A
    &lt;span class=&quot;nv&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;date &lt;span class=&quot;s2&quot;&gt;&quot;+%Y-%m-%d_%H:%M:%S&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
    git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;site updated at &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$now&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    git push origin master --force
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deploy completed&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in
  &lt;/span&gt;setup&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	    setup
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        deploy
        &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;数据搬运&quot;&gt;数据搬运&lt;/h2&gt;

&lt;p&gt;相对来说数据搬运不是很困难就是比较繁琐，原来很多Octopress支持的插件，在这里都得自己检验是否不工作或者是否有合适的插件可以替代。期间的过程就是不断的&lt;strong&gt;测试驱动&lt;/strong&gt;搬运，发现编译出错后，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;--trace&lt;/code&gt;开关，看问题出在什么地方然后一一修改之。最麻烦的一个问题是 gist 插件貌似产生了不兼容，原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;include_file&lt;/code&gt; 插件也没法再用，只好将文件内容copy过来，用Liquid的 &lt;code class=&quot;highlighter-rouge&quot;&gt;highlight&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 标签，套用如下的模板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;code/include.html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endhighlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;插件和定制&quot;&gt;插件和定制&lt;/h2&gt;

&lt;p&gt;没有了github的插件束缚，就可以装自己想要的插件了&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;jekyll-compose 可以用&lt;strong&gt;命令行来生成新的post&lt;/strong&gt;，类似于之前的octopress的命令行&lt;/li&gt;
  &lt;li&gt;jekyll-archives 可以用来生成归档页面，方便使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认的blog页面用的是post layout，但是默认没有定义，简单起见，自己在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt; 下边加一个就行，从默认的single.html拷贝过来修改一下即可。&lt;/p&gt;

&lt;h3 id=&quot;tag-cloud&quot;&gt;Tag cloud&lt;/h3&gt;
&lt;p&gt;Octopress的tagcloud插件，找了一圈也没找到好的，仿照别人家的，写了个简单的 tagcloud.html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;all_tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;site.tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;h&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{absolute_url}}/categories/index.html&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;Categories&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/h&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tagCloud&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;site.categories&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;category_name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_avg&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;div:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;all_tags&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tag&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{absolute_url}}/categories/{{ category_name | downcase}}/index.html&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;category_name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;cat_count&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;})&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endfor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;稍微定制下需要显示的地方，将上述html给include进去即可。&lt;/p&gt;

&lt;h3 id=&quot;布局调整&quot;&gt;布局调整&lt;/h3&gt;
&lt;p&gt;页面在高分辨率的屏幕下感觉空白太多，进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;_sass/minimal-mistakes&lt;/code&gt; 修改即可，代码相对比较清楚&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_variables.scss&lt;/code&gt; 包含一些全局变量的定义，譬如字体大小，缩进，padding等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_sidebar.scss&lt;/code&gt; 包含对边栏的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_masthead.scss&lt;/code&gt; 指定主头部元素的样式定义&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_page.scss&lt;/code&gt; 包含页面主要内容部分的样式定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概对着浏览器窗口调整即可，无需赘述。&lt;/p&gt;

&lt;h2 id=&quot;未尽事宜&quot;&gt;未尽事宜&lt;/h2&gt;
&lt;p&gt;还有一些其它的问题暂时没找到解决方案，暂时不折腾了，先列在这里。&lt;/p&gt;

&lt;h4 id=&quot;无法删除的老页面&quot;&gt;无法删除的老页面&lt;/h4&gt;
&lt;p&gt;之前的blog采用的是octopress的URL设置，当在新的主题里，将permalink依法炮制的时候，发现更新的页面没有被github正确重新加载，依然显示的是老的页面。无奈之下，只好修改一下permalink的前缀部分，强制生成不一样的页面。问题是老的页面依然可以访问。&lt;/p&gt;

&lt;h4 id=&quot;页面布局&quot;&gt;页面布局&lt;/h4&gt;
&lt;p&gt;默认的布局中有很多&lt;em&gt;额外的padding&lt;/em&gt;没法去掉，尤其是PC的分辨率比较高的时候，页面右侧的边框显得特别大；用Chrome的Inspect工具打开可以看到右侧的padding有16%之多，然而修改附带的css并不能生效。&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://rafabene.com/2015/10/11/how-migrated-blog-jekyll-github/&quot;&gt;How I migrated my blog to Jekyll/Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hblok.net/blog/posts/2016/10/23/jekyll-include-partial-snippets-of-code/&quot;&gt;Include partial snippets of code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/phaer/1020852&quot;&gt;Raw tag plugin to prevent liquid from parsing given text&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="blog" /><summary type="html">之前本blog的内容是基于强大的octopress生成为静态站点，然后将生成的内容静态拷贝到 github-pages 上去的。当octopress的作者宣布重构后的新版本预告后便急冲冲上去升级了本站内容，可惜很多插件都不工作了。眼见2年多过去了，貌似正式的3.0版本还没有被宣布，官方页面的帮助依然停留在2.0版本时代。</summary></entry><entry><title type="html">Kotlin语言之变量约束设计</title><link href="https://skyscribe.github.io/post/2017/06/05/kotlin-variable-invariants/" rel="alternate" type="text/html" title="Kotlin语言之变量约束设计" /><published>2017-06-05T23:12:00+08:00</published><updated>2017-06-05T23:12:00+08:00</updated><id>https://skyscribe.github.io/post/2017/06/05/kotlin-variable-invariants</id><content type="html" xml:base="https://skyscribe.github.io/post/2017/06/05/kotlin-variable-invariants/">&lt;p&gt;可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为&lt;strong&gt;继承/封装/多态等手法针对的都是程序组织上&lt;/strong&gt;的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖&lt;strong&gt;过程式实现跟操作系统打交道&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;函数式编程里的副作用&quot;&gt;函数式编程里的副作用&lt;/h2&gt;
&lt;p&gt;在函数式编程的世界里，事情会变得很传统的过程式处理不一样，因为这里非常讲究函数本身是否是&lt;strong&gt;有副作用&lt;/strong&gt;的，如果&lt;strong&gt;同样的输入不能保证相同的输出&lt;/strong&gt;，那么则是有副作用的。这里的输出不仅仅表示返回值，还隐含其它形形色色的对环境的影响，包括&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;申请但是没有释放的内存&lt;/li&gt;
  &lt;li&gt;向操作系统请求占用共享资源如网络套接字&lt;/li&gt;
  &lt;li&gt;屏幕输出，磁盘占用等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要区分副作用&quot;&gt;为什么要区分副作用&lt;/h2&gt;

&lt;p&gt;显然，副作用引入了&lt;strong&gt;额外需要程序员维护&lt;/strong&gt;的状态，而传统的线程库或基本的OS机制将其完全交给了程序员负责。从而导致在多线程编程环境下，复杂的问题随着状态的增加成&lt;strong&gt;指数上升&lt;/strong&gt;。状态意味着有共享资源需要维护，当有并发执行的进程或是线程的时候，为了保证正确的程序语意，则不得不引入锁(昂贵的操作)和竞争，从而制约性能。无锁算法通过CAS+重试机制，可以&lt;strong&gt;部分缓解锁的开销&lt;/strong&gt;，却不能从本质上解决问题。&lt;/p&gt;

&lt;p&gt;无副作用的函数则是天然适合并发的，因为没有共享自然可以并行不悖地执行，问题不是完美解决了吗？然而&lt;strong&gt;现实世界总是不允许绝对完美二字存在&lt;/strong&gt;的，纯粹无副作用的函数几乎一无是处，因为它本质上没什么用，什么也做不了。&lt;/p&gt;

&lt;p&gt;退而求其次的想法是，能否尽量隔离两者的实现，然后又可以优雅地将二者集成起来完成实际功能？&lt;strong&gt;HASKELL用其优雅的monad抽象&lt;/strong&gt;回答了这个问题。然而对于抽象思维能力不是那么强（或者没有那么好数学基础）的程序员而言，&lt;strong&gt;Monad实在是太阳春白雪&lt;/strong&gt;了而难以接近；想更加接地气一点的程序语言无一不选择和Monad保持距离，即使某些构造和设计的思想就来源于Monad, 譬如随处可见的Optional，基本的map/reduce链式操作等。&lt;/p&gt;

&lt;p&gt;对于这些没有显示引入monad的非纯函数式语言来说，严格的隔离就显得有些太激进了。取而代之的相对折中一点的&lt;strong&gt;平庸&lt;/strong&gt;策略是语言机制本身提供某些基础机制，剩下的怎么用这些基本机制，一切由程序员自己来定夺。&lt;/p&gt;

&lt;h2 id=&quot;kotlin的语言层面基本机制&quot;&gt;kotlin的语言层面基本机制&lt;/h2&gt;

&lt;p&gt;kotlin通过关键字 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 来声明&lt;strong&gt;只读&lt;/strong&gt;的变量，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 来声明可变量。任何函数只要引入对可变量的使用，则其本身就是有明显的副作用的。然而一个变量声明为只读，仅仅表示在其对应的作用域中，不允许修改此变量的值，并&lt;strong&gt;不意味着实际指向的数据对象本身是不可变&lt;/strong&gt;的， 因为在可能有其他的地方使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 的方式来操作此变量，或者有显示的方式将一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 的变量转换回可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;考虑下边的例子：&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// field1 是只读的，在本class中不允许修改它
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;field2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// can only modify field2, but not field1
&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//calling site
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;someTypeInst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someTypeInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// someTypeInst can still be changed by others! Not recommended!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;someTypeInst&lt;/code&gt;是以只读方式传入&lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 的，然而并不能保证没有其它的线程并发地修改实际的对象，如果发生这种情况，&lt;strong&gt;程序员仍然需要保证数据的一致性和安全&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;只读变量的初始化&quot;&gt;只读变量的初始化&lt;/h3&gt;

&lt;p&gt;显然不可变变量则仅仅能够初始化一次，后续使用中不能再修改了。这样也带来一些限制，譬如在 &lt;code class=&quot;highlighter-rouge&quot;&gt;init block&lt;/code&gt; 里想一次性初始化某些资源然后将其设置为在class内部是只读，则无能为力。一种变通的方式是将其设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; 类，然而这样做我们就损失了只读约束；另外一种做法则需要使用property构造来封装。&lt;/p&gt;

&lt;h2 id=&quot;核心集合类&quot;&gt;核心集合类&lt;/h2&gt;
&lt;p&gt;kotlin对来自JAVA的集合类库进行了二次封装，清晰地划分了只读集合类和可变集合。&lt;/p&gt;

&lt;h3 id=&quot;接口定义&quot;&gt;接口定义&lt;/h3&gt;
&lt;p&gt;常用的集合类接口在&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin,collections&lt;/code&gt; 包中被重新定义 ( 源码中位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.kt&lt;/code&gt; )&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//...
// by default not mutable
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//... }
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// mutable iterable supports removing elements during iterating
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Only read access to collection
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Supports read/write operations
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableIterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的集合类接口则选择从以上接口中&lt;strong&gt;选择对应的&lt;/strong&gt;来扩展实现，因而对同一个类型有两种实现，分别是只读的 (没有前缀) 的和可变类型 (&lt;strong&gt;用 Mutable 做前缀区分&lt;/strong&gt;) 。譬如 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; 类就定义为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Read only list interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
// Mutable list
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，实际的具体实现类是复用Java中的定义，可参考collection包中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeAliases.kt&lt;/code&gt; 文件&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;kotlin.collections&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;默认的集合操作以及Streams API返回的大部分是不可变接口对象。&lt;/p&gt;

&lt;h3 id=&quot;集合类扩展工具函数&quot;&gt;集合类扩展/工具函数&lt;/h3&gt;
&lt;p&gt;除了使用默认的JDK实现来生成具体集合类对象，Kotlin标准库中同时提供了大量的封装函数方便程序员使用，某些来源于对JDK的直接封装，有一些则是直接inline实现。&lt;/p&gt;

&lt;p&gt;譬如返回空list的包装和初始化形形色色的list&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyList&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new read-only list of given elements.  */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty read-only list. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * Returns an immutable list containing only the specified object [element].
 * The returned list is serializable.
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@JvmVersion&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成可变List的函数封装大多也是清晰明了 , 并且有很多种类的封装，使得就地生成 List 的工作大大简化；大部分情况仅仅需要&lt;strong&gt;使用已有的函数&lt;/strong&gt;即可，不需要发明新的轮子&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [MutableList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns an empty new [ArrayList]. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@SinceKotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@kotlin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InlineOnly&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Returns a new [MutableList] with the given elements. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayAsCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isVarargs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它集合类  (set/map等) 的实现原理&lt;strong&gt;大概类似&lt;/strong&gt;，可以通过查看对应源码。&lt;/p&gt;

&lt;h3 id=&quot;不可变集合转换为可变集合&quot;&gt;不可变集合转换为可变集合&lt;/h3&gt;
&lt;p&gt;很多场景下，API返回的都是不可变集合，将其变成一个可变对象再行编辑修改是常见不过的变成任务；kotlin 通过其&lt;strong&gt;自身的扩展机制&lt;/strong&gt;将这些工具函数自动添加到了对应的集合类上&lt;/p&gt;

&lt;p&gt;如果想要将一个只读的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt; 对象变为一个可变的 &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableList&lt;/code&gt;，那么其实现是通过重新初始化一个新对象实现的：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Below code is copied from generated standlib as _Arrays.kt
//  see https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于具体的Array类，有不同的实现，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;ByteArray&lt;/code&gt; 的初始化方法则有所不同，直接调用其构造函数，然后注意添加现有的各个元素&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Returns a [MutableList] filled with all elements of this array.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ByteArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;之所以如此，是因为具体这些子类是被映射到具体的 JVM 对象上的。如ByteArray的文档如是说&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;public final class ByteArray defined in kotlin
An array of bytes. 
When targeting the JVM, instances of this class are represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;byte[]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而对于CharArray，则其映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;char []&lt;/code&gt;类型上去。&lt;/p&gt;

&lt;h2 id=&quot;idea支持&quot;&gt;IDEA支持&lt;/h2&gt;
&lt;p&gt;作为官方的IDE环境，IDEA对可变量的引用做了显示的&lt;strong&gt;下划线&lt;/strong&gt;提醒，程序员可以一目了然地看到代码中对可变量的使用。&lt;/p&gt;

&lt;p&gt;然而想要更深入的查看整个实现调用链中，哪些引入副作用哪些没有，工具的支持就比较有限了。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="fp" /><summary type="html">可变状态的泛滥往往被认为是软件维护灾难的元凶之一，尤其是当过程封装遇上多线程，普通的面向对象编程技巧完全不堪大用，因为继承/封装/多态等手法针对的都是程序组织上的处理措施，具体到底层实现上，传统的C/C++/JAVA依然依赖过程式实现跟操作系统打交道。</summary></entry><entry><title type="html">Kotlin语言之函数式编程</title><link href="https://skyscribe.github.io/post/2017/06/04/kotlin-language-functional-programming/" rel="alternate" type="text/html" title="Kotlin语言之函数式编程" /><published>2017-06-04T22:32:00+08:00</published><updated>2017-06-04T22:32:00+08:00</updated><id>https://skyscribe.github.io/post/2017/06/04/kotlin-language-functional-programming</id><content type="html" xml:base="https://skyscribe.github.io/post/2017/06/04/kotlin-language-functional-programming/">&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin语言&lt;/a&gt;是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其&lt;a href=&quot;https://techcrunch.com/2017/05/17/google-makes-kotlin-a-first-class-language-for-writing-android-apps/&quot;&gt;2017年的I/O大会上将其列为Android平台官方支持的语言&lt;/a&gt;而窜上了热点。&lt;/p&gt;

&lt;p&gt;本文尝试从函数式编程的角度管窥Kotlin的特性。&lt;/p&gt;

&lt;h2 id=&quot;jvm上的函数式语言生态&quot;&gt;JVM上的函数式语言生态&lt;/h2&gt;
&lt;p&gt;作为一门比较年轻的编程语言，要想在既有的数百种语言中脱颖而出，成功吸引开发者的心，对新的&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;函数式编程范式&lt;/a&gt;的支持是必然不可少的 - 这一点基本成为语言出品商心照不宣的潜规则了，当然在21实际，不支持面向对象的范式也是说不过去的。&lt;/p&gt;

&lt;p&gt;作为基于JVM平台的语言，和Java的互操作性肯定是一个重要的优势，当然这方面已经有成熟的函数式语言&lt;a href=&quot;https://www.scala-lang.org/&quot;&gt;scala&lt;/a&gt;和更早一点的&lt;a href=&quot;https://clojure.org/about/rationale&quot;&gt;clojure&lt;/a&gt;在前。可能比较遗憾的是，正统的函数式编程风格太难被传统的OO程序员所接受，因此基于传统Lisp的clojure一直曲高和寡，scala在近年来有变得更加流行的趋势，只是目前看来&lt;a href=&quot;https://dzone.com/articles/the-rise-and-fall-of-scala&quot;&gt;仍然没有跨越期望的引爆点&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;有丰富的特性还希望有速度&quot;&gt;有丰富的特性还希望有速度&lt;/h3&gt;
&lt;p&gt;传统印象中的静态函数式语言的编译速度往往会比较慢，这一点在工程实践上是个很重要的因素。&lt;/p&gt;

&lt;p&gt;Kotlin作为后来者，其开发者认为静态语言的编译速度是个至关重要的，然后Scala的编译速度远不能令人满意。对大型的项目而言，笨拙的编译速度浪费的可是大量的时间和金钱；毕竟天下武功唯快不破，更快的编译时间意味着更快的反馈周期，更多次的迭代开发。Kotlin的目标之一是期望编译速度可以像Java一样快，&lt;a href=&quot;https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d&quot;&gt;benchmark分析&lt;/a&gt;也表明了二者的速度是差别不大的。&lt;/p&gt;

&lt;h2 id=&quot;基本特性&quot;&gt;基本特性&lt;/h2&gt;
&lt;p&gt;函数式语言的基本元素就是function，这一点kotlin倒是没有玩太多花头。用&lt;code class=&quot;highlighter-rouge&quot;&gt;fun&lt;/code&gt;关键字来声明函数，函数是第一等公民，可以支持函数作为参数，返回函数等基本特性。&lt;/p&gt;

&lt;h3 id=&quot;不可变类型支持&quot;&gt;不可变类型支持&lt;/h3&gt;
&lt;p&gt;Kotlin强制要求程序员声明某个特定的变量是否是可变类型。&lt;/p&gt;

&lt;p&gt;如果是可变类型，则需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;var &lt;/code&gt;来声明；那么后续程序中任何地方访问变量都会被IDE给highlight出来，提醒可能的副作用。因为可变类型意味着内部存储着状态，从函数式编程的角度来看，状态会&lt;strong&gt;影响函数的纯度&lt;/strong&gt;，带来副作用和复杂性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5275528-e33afde1447172d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;immutable_hints.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;函数声明&quot;&gt;函数声明&lt;/h3&gt;
&lt;p&gt;基本的函数声明是这样的&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsAFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当然这里的类型后置语法和传统的C家族语言有些不同，但是适应起来倒也不是难事儿。&lt;/p&gt;

&lt;h3 id=&quot;类型推导&quot;&gt;类型推导&lt;/h3&gt;
&lt;p&gt;Kotlin也支持强大的类型推导，从而在很多情况下，可以省略不必言的类型指定，简化代码；譬如函数的返回类型可以被自动推断的时候，其类型声明可以被省略。&lt;/p&gt;

&lt;h3 id=&quot;特殊的返回类型-unit&quot;&gt;特殊的返回类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;是一个特殊的类型，用于指定某个函数返回的值可以被省略，类似于Java8的&lt;code class=&quot;highlighter-rouge&quot;&gt;Void&lt;/code&gt;类型。如果一个函数没有返回值，那么可以指定其返回&lt;code class=&quot;highlighter-rouge&quot;&gt;Unit&lt;/code&gt;或者直接省略其返回&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something with arg
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// no return needed
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// same as above
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do something
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;中缀表达式&quot;&gt;中缀表达式&lt;/h3&gt;
&lt;p&gt;中缀表达式写法更替进人的思维习惯，在定义某些操作符的时候是非常有用的。此用法往往用于扩展已有类型的操作，定义的时候需要满足以下条件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;属于某个类的成员函数，或者是定义某个类的扩展函数(后边再回头来看)，因为这里我们&lt;strong&gt;必须知道左侧的操作对象&lt;/strong&gt;是谁&lt;/li&gt;
  &lt;li&gt;必须只有一个函数参数（操作符后边的对象）&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;infix&lt;/code&gt;关键字来标记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;譬如&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;infix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;/// implementation of shl operation
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// call site
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;命名参数和默认值&quot;&gt;命名参数和默认值&lt;/h3&gt;
&lt;p&gt;这点和Python很像在多个参数的复杂函数的使用上有很大帮助，能极大提高可读性减少维护成本。调用方可以在调用点指定需要传入的参数的名字；也可以省略掉不需要指定的参数。&lt;/p&gt;

&lt;p&gt;譬如有如下的&lt;code class=&quot;highlighter-rouge&quot;&gt;reformat&lt;/code&gt;函数用于格式化&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;normalizeCase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;upperCaseFirstLetter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;divideByCamelHumps&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用点可以简单写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSeparator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// equals to
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reformat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个功能在传统的C++/Java里边没有提供，但是IDEA提供了只能提示可以弥补Java的不足；而Kotlin则将其内置在语言中了；本身没多少复杂性在里边。&lt;/p&gt;

&lt;h2 id=&quot;高阶函数和语法糖&quot;&gt;高阶函数和语法糖&lt;/h2&gt;

&lt;h3 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h3&gt;
&lt;p&gt;函数的参数可以是一个函数，这个在Kotlin的库里已经有大量的例子，譬如基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt;的filter函数携带一个谓词函数，其针对给定的参数返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt; Boolean&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FilteringSequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;单参数函数的表达式形式&quot;&gt;单参数函数的表达式形式&lt;/h3&gt;
&lt;p&gt;当函数只有一行实现的时候，可以省略其函数体，直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;来书写，就像复制给一个变量一样&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add2Numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lambda和匿名函数&quot;&gt;Lambda和匿名函数&lt;/h3&gt;
&lt;p&gt;匿名函数用大括号括起来，上面的例子也可以写作&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;add2Numbers2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;函数调用的形式省略&quot;&gt;函数调用的形式省略&lt;/h3&gt;
&lt;p&gt;当函数仅仅有一个参数的时候，其参数名字默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;保留关键字可以不用显示指定。&lt;/p&gt;

&lt;p&gt;当函数的最后一个参数是一个函数的时候，其函数体可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;块的方式来书写，获得更好的可读性。&lt;/p&gt;

&lt;p&gt;譬如如下的例子用于打印指定数目个偶数&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;printEvens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;一个具体一点的例子&quot;&gt;一个具体一点的例子&lt;/h3&gt;

&lt;p&gt;假设要实现如下功能的函数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;遍历某个目录树&lt;/li&gt;
  &lt;li&gt;找出所有符合条件的文件夹&lt;/li&gt;
  &lt;li&gt;取其文件绝对路径&lt;/li&gt;
  &lt;li&gt;归并为一个字符串列表返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以通过如下几个函数完成&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里每个函数的含义都是比较清楚易懂的。如果利用上述的省略规则，那么可以更简略的写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;extractAllDomainDoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walkTopDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isDomainDocDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;separator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;doc&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;类型扩展函数&quot;&gt;类型扩展函数&lt;/h2&gt;
&lt;p&gt;Kotlin 支持对已有的类型添加扩展，值需要在任何想要的地方添加想要的功能，则原有的类型即可像被增强了一样具有新的功能，该机制提供了OO之外新的灵活的扩展方式。&lt;/p&gt;

&lt;p&gt;譬如默认的Kotlin的&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;类没有提供并发的&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;操作，可以通过扩展机制很容易的写出来一个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;来并发循环的版本&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parallel for each, see also https://stackoverflow.com/questions/34697828/parallel-operations-on-kotlin-collections
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRuntime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;availableProcessors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// default size is just an inlined version of kotlin.collections.collectionSizeOrDefault
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;destination&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DAYS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里在函数体中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;自动会绑定于被扩展的对象。&lt;/p&gt;

&lt;p&gt;如果我们想实现一个自动将一大堆plantuml文件转换为png格式并copy到指定目录，因为默认的plantuml的API是单线程的，我们可以基于上述的parallelForEach实现来并发调度UML的生成过程，对应的代码可以写为&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;markDownFileLists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parallelForEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SourceFileReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;generatedImages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstOrNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copyFileToDirWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pngFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absolutePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCopyTarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${System.currentTimeMillis()} - Created png for $it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kotlin" /><category term="programming" /><category term="fp" /><summary type="html">Kotlin语言是大名鼎鼎的JetBrains公司（就是可以甩Eclipse数条大街的IntelliJ IDEA背后的公司）出品的现代的编程语言，之前已经在IDEA中蹦达出来很多次了；只是最近随着Google在其2017年的I/O大会上将其列为Android平台官方支持的语言而窜上了热点。</summary></entry><entry><title type="html">Software Design in Agile Development Context</title><link href="https://skyscribe.github.io/post/2016/12/24/software-design-in-agile-development-context/" rel="alternate" type="text/html" title="Software Design in Agile Development Context" /><published>2016-12-24T19:32:00+08:00</published><updated>2016-12-24T19:32:00+08:00</updated><id>https://skyscribe.github.io/post/2016/12/24/software-design-in-agile-development-context</id><content type="html" xml:base="https://skyscribe.github.io/post/2016/12/24/software-design-in-agile-development-context/">&lt;p&gt;在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;软件设计的刚需被敏捷了吗&quot;&gt;软件设计的刚需被敏捷了吗？&lt;/h2&gt;

&lt;p&gt;工作流程的变更以及开发节奏的加快并不能绕开一个很核心的问题：&lt;strong&gt;写出容易维护方便扩展的代码的复杂程度本质上没有改变&lt;/strong&gt;；软件的维护周期越长，迭代的版本越多，这个基本问题就越突出。要想顺利解决这一问题，只能&lt;strong&gt;依赖于系统具有相对良好的设计&lt;/strong&gt;，使得添加新的功能不会轻易破坏原有的结构，出现问题的时候，不需要大范围地对系统做出变更。&lt;/p&gt;

&lt;p&gt;传统的瀑布式方法希望通过借鉴成熟的建筑行业的做法，采用预先大规模的架构设计，对系统做好明确的分割；继而进行不同层次的设计，直到所有可以预见到的需求都得以满足，然后才开始进行的代码的编写和构建。这种方法生产出来的软件交付工期很长，适应性很差，除了少数特殊行业之外基本已经被市场所淘汰。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://agilemanifesto.org/&quot;&gt;敏捷宣言&lt;/a&gt; 提出了一些基本的原则来指导我们怎样用相对更”&lt;strong&gt;敏捷&lt;/strong&gt;“的方式开发和交付我们的软件；通过多个不同的迭代，增量式的构建和持续交付系统来降低风险。然而软件本身的复杂性导致我们不能将客户的需求一对一的翻译成代码，像搭积木一样构建出来一个可以轻易维护的系统。因为新加入的需求很可能导致原有的代码结构无法适应新的需求；某些为了尽快完成需求而做出的&lt;strong&gt;关键的假设可能必须被打破&lt;/strong&gt;导致添加新的需求会破环大量已有的功能。如何做出恰如其分的软件设计，既能满足现有的短期需求，又能平衡潜在的变更。&lt;/p&gt;

&lt;p&gt;各种不同的敏捷实践方法论对如何管理用户的需求，如何增强不同角色的沟通，如何实施日常的开发和测试活动，如何验证需求保证已经交付的承诺不被变更所破坏，如何规划和平衡资源和进度等复杂问题都给出了丰富的可选实践供项目管理人员裁剪；对于如何做软件设计以及做多少软件设计并没有很详尽的描述。就连基本的是否需要软件设计，以及需要多少软件设计，怎样算作过度设计都语焉不详。&lt;/p&gt;

&lt;h2 id=&quot;真的需要软件设计吗&quot;&gt;真的需要软件设计吗？&lt;/h2&gt;

&lt;p&gt;大部分情况下，对于这个基本的问题我想答案应该是肯定的，除非你是在做一个很小的个人项目。如果需要牵扯到多个人一块合作并且最终的产品需要维护比较长时间，那么起码&lt;strong&gt;某种程度的软件设计&lt;/strong&gt;应该是不可或缺的。毕竟&lt;strong&gt;软件开发活动本身也是围绕着人展开&lt;/strong&gt;的，既然需要多个不同知识背景，不同技能，不同角色的人一起来协作交付功能复杂多变的软件，那么必然需要一些设计保证&lt;strong&gt;参与其中的人有一致的理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;敏捷运动的早期一个常见的误解就是，敏捷软件开发不需要软件设计，不需要软件架构，只需要采用极限编程，将人们聚集一个公共空间里，直接动手写代码就行了；复杂的设计文档都是浪费，都是可以避免掉的，代码就是最好的设计文档。这样的过程可能适合于几个能力超强的程序员聚在一起做的临时小项目，放到更广泛的商业环境则难以持续下去。人员的流动，特殊需求的变更，性能问题的修补会使一个一开始看起来极其简单的几个源代码文件组成的小项目演进成&lt;strong&gt;难以维护的“庞然大物”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果系统没有明确的分工和边界，没有相对清晰的职责分工和交互限制，软件的结构很容易陷入“大泥球”结构而不可维护，试想如果代码里的每一个包或者类都有可能和另外其它的任意一个类有交互关系，即使是一个绝对代码行数很小的项目也会变得无法继续添加新的功能。&lt;/p&gt;

&lt;h2 id=&quot;哪些东西应该包含在软件设计中&quot;&gt;哪些东西应该包含在软件设计中？&lt;/h2&gt;

&lt;p&gt;所谓的设计其实可以理解为关于如何组织软件各个部分（特性和行为分割）的一些决策，以及做出相应决策的一些原因。&lt;/p&gt;

&lt;p&gt;敏捷场景下，重构的重要性以及早已经深入人心，因而容易经&lt;strong&gt;由重构来去掉“坏味”的部分就不宜放在设计&lt;/strong&gt;中。因为一般为了重用的目的都会将设计决策写下来供后续使用；如此一来必然产生一些维护成本；而维护设计文档的开销一般比代码要大很多。因此容易通过重构而优化的部分，放在专门的软件设计中显得有些得不偿失了。毕竟敏捷软件开发的基本思路就是&lt;strong&gt;消除浪费&lt;/strong&gt;，使得&lt;strong&gt;投入产出比最大&lt;/strong&gt;化。&lt;/p&gt;

&lt;p&gt;某些跟具体实现技术相关而和核心业务需求关系比较远的决策，大部分也&lt;strong&gt;不适宜包含在软件设计&lt;/strong&gt;中。譬如期望某部分关键数据需要做持久化以保证系统异常重启的时候依然可以恢复。对于业务需求而言，这块数据需要持久化是重要的，但是如何做持久化，又可能是易变的，譬如今天是考虑用文件来做持久化就可以了，将来可能发现不够必须用关系数据库，或者甚至关系数据库可能也不是一个合适的选择，得要用键值对数据库。&lt;strong&gt;识别到可能变化的部分，并将不变的部分抽象出来，放入设计中&lt;/strong&gt;可能就足够了。这样技能照顾到当前的需求，又能满足将来扩展的需要。至于具体是怎样实现的，看代码就足够了。&lt;/p&gt;

&lt;p&gt;需求的&lt;strong&gt;概念抽象化，和软件的静态模型可以作为设计的中心&lt;/strong&gt;之一，必须详细考虑并归档维护。之所以要对需求进行抽象化处理，是因为用户的期望可能是模糊不清的，甚至是“朝令夕改”的。敏捷方法强调持续交付就是为了使用户早期得到反馈，&lt;strong&gt;及时修正他们的需求&lt;/strong&gt;，更好的管理客户的期望，避免开发出不符合客户真正预期的产品，浪费开发资源不说也浪费了客户的投资。软件的静态模型是关于大的软件职责的拆分和交互边界，这一部分不仅是当前进一步开发的基本依据，日后万一需要重构也是很重要的参考，值得花力气仔细讨论达成一致，减少日后维护成本。&lt;/p&gt;

&lt;p&gt;软件的部署和核心模块的交互在有这方面的变更的时候（新加入模块或者服务等）也需要仔细考虑并作为软件设计的关键活动。模块的边界是粗粒度的系统耦合的地方，一些关键的交互流程也适宜详细讨论并放在软件设计文档中。&lt;/p&gt;

&lt;p&gt;系统核心的模块/类以及之间的交互，如果有发生变更，也需要第一时间考虑清楚并放置在设计过程中产生合适的产出，便于沟通和交流。如果模块的粒度足够大（譬如估计有很多的代码），那么哪些部分是对外交互的接口也应该提早考虑清楚，并提取出来以便后续写代码以及代码评审的时候对照，确保设计被正确遵守。&lt;/p&gt;

&lt;h2 id=&quot;什么时候应该停止继续设计&quot;&gt;什么时候应该停止继续设计？&lt;/h2&gt;

&lt;p&gt;敏捷语义下，任何的浪费都是可耻的，代价巨大的设计工作自然也不例外。知道何时还需要仔细讨论搞清楚，何时应该停止变得尤其困难，甚至需要一些接近于艺术化的方法，&lt;strong&gt;需要经过大量的实践经验累积和反思&lt;/strong&gt;才能做到不偏不倚。&lt;/p&gt;

&lt;p&gt;如果发现所讨论的问题可能代码实现很容易就能完成，如果考虑不完备，那么修改代码的代价非常小，那么就可以立即停止了；因为设计的目的是为了更好的写代码，更好的维护既有的代码。因此只有重构代码的代价远远大于预先仔细设计付出的代价是，才应该花费力气去做这些烧脑的工作。发现代码实现已经很容易没什么问题的时候，就放手去写代码或者重构代码吧。这种情况往往发生在我们想去“设计”一些内部实现细节，而这些细节对模块的边界以及待修改模块和核心部分耦合很小的情况。&lt;/p&gt;

&lt;p&gt;如果是在构建一个新的模块，而这个模块和已有的系统有形形色色的复杂联系（耦合），那么如果这个模块和已有的系统的各个部分的交互已经比较清楚，而且其内部实现估计工作量也很小的时候，那么就可以放心将剩下的工作交给聪明的程序员去继续了。将一些&lt;strong&gt;细微的工作也放入设计中，只会使设计文档变得庞大而又难以维护&lt;/strong&gt;。毕竟可工作的代码比完美的文档更重要，虽然后者也很有价值。&lt;/p&gt;

&lt;p&gt;如果对于是否应该继续设计有分歧，可以和其它准备实现的程序员坐在一起讨论（其实任何时候都应该如此，如果团队规模比较小而且时间允许），看将要写代码的程序员是否觉得足够清楚，返工的风险是否足够得小。如果对于一些核心的模块或者类的职责还有不同的认识，或者程序员不知道某些改动是应该新创建一个子包，还是应该在已有的摸个包中修改来实现，那么&lt;strong&gt;很可能有些关键的部分没有设计&lt;/strong&gt;清楚。&lt;/p&gt;

&lt;p&gt;决定何时应该适可而止也和你的程序员团队的&lt;strong&gt;实际水平和能力&lt;/strong&gt;密切相关。一群天才程序员可能需要极少的设计来达成基本的共识就可以产出高质量易维护的代码，而水平平庸的程序员团队则需要更多设计上的预先讨论沟通以达成基本共识，减少返工。&lt;/p&gt;

&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;

&lt;p&gt;软件工程的一个关键要素就是工具。软件设计自然也离不开合适的工具，尤其是软件设计又是对需求进行抽象的结晶；选择合适的工具可以增进协作和沟通，使得设计输出是有实际指导作用的而不仅仅是纯粹的文档工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;轻量级的文档工具&lt;/strong&gt;往往使维护和修改变得更加容易，因为设计输出本身也是一个迭代的过程；便于多人评审和协作显得尤其重要。目前主流的方式基本都是基于Markdown和Plantuml的；前者可以用来存放文本，后者则可以用文本的格式来描述UML图。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="design" /><category term="agile" /><category term="methodologies" /><summary type="html">在目前大部分的软件开发组织中，敏捷开发已经成为毋庸置疑的标配。随着数位技术大神和布道师的宣扬和数量庞大的敏捷教练的身体力行式推广，商业环境和客户需求变更速度的日益加快，采用端到端交付周期更短的敏捷开发过程基本已经成为项目成功的必要条件。</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - 4</title><link href="https://skyscribe.github.io/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - 4" /><published>2013-08-24T19:32:00+08:00</published><updated>2013-08-24T19:32:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/24/agile-software-development-the-cooperative-game-reading-4/">&lt;p&gt;本文是第四部分，主要讨论方法论和方法设计的一些基本规则，已经如何清晰地&lt;strong&gt;定制和应用&lt;/strong&gt;这些规则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/14/agile-software-development-the-cooperative-game-reading-2/index.html&quot;&gt;第二部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/18/agile-software-development-the-cooperative-game-reading-3/index.html&quot;&gt;第三部分&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;构建发布软件的生态系统&quot;&gt;构建发布软件的生态系统&lt;/h2&gt;

&lt;p&gt;方法论的目的在于使用所有可行的手段来保证我们可以发布预期的软件，并且这样的方法是可以&lt;strong&gt;确定持续&lt;/strong&gt;进行的。方法学本身即使社交行为的创建过程。方法本身是一个关于职位描述，过程，团队中每个人需要遵守的传统的集合。&lt;/p&gt;

&lt;p&gt;每一个组织都有自己的方法论，这些方法就是他们怎样做商业的方式。一种方法论可以说是你的组织同意采取的一种传统；这些过程可能在大部分公司并没有很正式的打印出来或者写下来。这种一致同意的传统需要我们不时得&lt;strong&gt;重新审视&lt;/strong&gt;，&lt;strong&gt;持续的&lt;/strong&gt;构建。&lt;/p&gt;

&lt;h2 id=&quot;方法论概念&quot;&gt;方法论概念&lt;/h2&gt;

&lt;p&gt;方法论是关于一些方法的固化和规则定义，其对过程的约束是它不同于方法本身的地方 - 你可以在不同的时候采用不同的方法；然而在一系列开发过程中，方法论代表着一直认可的基本规则和约定。&lt;/p&gt;

&lt;p&gt;集合一群聪明人又想获得成功，我们就必须做好协调/合作和协调，离开这些手段，最聪明的人组合的团队也会变得杂乱无章，从而很难取得成功。&lt;/p&gt;

&lt;h3 id=&quot;结构性术语&quot;&gt;结构性术语&lt;/h3&gt;

&lt;p&gt;方法学有如下几个结构性要素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;角色：明确的角色分工至关重要，什么样的角色需要什么样的&lt;strong&gt;职责和技能&lt;/strong&gt;等&lt;/li&gt;
  &lt;li&gt;技能：角色需要的技能和专长&lt;/li&gt;
  &lt;li&gt;团队：不同的情况之下工作于一起的一种集体角色&lt;/li&gt;
  &lt;li&gt;技术：赖以完成具体工作的技术技能，关于怎样完成某种特定工作的一些知识&lt;/li&gt;
  &lt;li&gt;活动：人们怎样完成某些特定工作的过程，譬如计划，编码，测试等&lt;/li&gt;
  &lt;li&gt;过程：各种各样的活动如何连接在一起&lt;/li&gt;
  &lt;li&gt;工作产品： 可以是中间过程的产出，如CRC卡或者故事卡片等&lt;/li&gt;
  &lt;li&gt;里程碑：一些关键的时间节点，往往是关于整体进度的一个节点&lt;/li&gt;
  &lt;li&gt;标准：关于一些工具/类库/方法的一些传统/约束等&lt;/li&gt;
  &lt;li&gt;质量：关于活动和工作产物的质量属性&lt;/li&gt;
  &lt;li&gt;团队价值：什么样的价值被大家普遍认可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的方法论在上述的要素上有很多各不相同之处。&lt;/p&gt;

&lt;p&gt;依据上述的结构性要素，常见的方法类可以划分为以下类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Normative方法，强调采用的步骤或者解决方案是完全遵守已有的工作记录。&lt;/li&gt;
  &lt;li&gt;Rational方法，基于工具和方法来构建&lt;/li&gt;
  &lt;li&gt;Participative方法，基于利益相关方和客户参与的方面&lt;/li&gt;
  &lt;li&gt;Heuristic方法，基于已经学习得到的经验，启发式进行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很多情况下，随着人们经验的基积累，方法论可能沿着Heuristics的方法慢慢固化下来，慢慢演进到Normative方法；譬如在计算机编程领域，算法设计方面就达到了标准化的地步；而关于将人们放在开放的办公区还是私有的办公室的方面却没有。&lt;/p&gt;

&lt;p&gt;大部分的软件开发货活动还处于&lt;strong&gt;Heuristic方法就足够适用&lt;/strong&gt;的阶段。&lt;/p&gt;

&lt;h3 id=&quot;范围&quot;&gt;范围&lt;/h3&gt;

&lt;p&gt;一种方法论的范围涵盖了关于它要关注的角色范围和相关的一些活动。早期的面向对象方法论被认为是设计师作为核心的角色，活动主要是讨论技术工具和描述对应标准图形的活动；然而这样的描述&lt;em&gt;不够宽泛&lt;/em&gt;的同时，又显得&lt;strong&gt;限制太多&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;方法论的范围可以被概括为如下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生命周期的覆盖，什么时间开始，什么时候结束&lt;/li&gt;
  &lt;li&gt;角色覆盖，什么样的角色参与什么样的活动&lt;/li&gt;
  &lt;li&gt;活动覆盖，什么样的活动在什么样的情况下开展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从这样的角度看，早起的面向对象方法仅仅局限于讨论一个很狭窄的领域，只有设计师参与，仅仅关系到项目设计阶段，从而导致经验丰富的面相对象设计师认为他们不适合参与项目的整个生命周期。从这些因素来考虑，有助于我们更好的理解怎样的方法论在怎样的场景下是更合适的。&lt;/p&gt;

&lt;h3 id=&quot;概念性要素&quot;&gt;概念性要素&lt;/h3&gt;

&lt;p&gt;为了更好的设计和定制方法论，我们需得考虑如下一些要素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方法论本身的规模大小，有多少标准，活动，质量度量物，技术描述等&lt;/li&gt;
  &lt;li&gt;正规性，多大的精度控制和什么程度的过程控制是需要的，是否需要更严格的控制和错误容忍率&lt;/li&gt;
  &lt;li&gt;方法论的重度，控制元素的个数，流程/活动的数目&lt;/li&gt;
  &lt;li&gt;问题域大小，需要多少问题去解决，&lt;strong&gt;内部复杂性&lt;/strong&gt;如何&lt;/li&gt;
  &lt;li&gt;项目本身的大小，&lt;strong&gt;多少个人&lt;/strong&gt;需要协调&lt;/li&gt;
  &lt;li&gt;系统重要性，如果发生了错误，造成的损害如何，是仅仅&lt;strong&gt;损失钱财还是造成人命有关的灾难&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;精确度如何，譬如设计的粒度如何，高层设计到什么样的程度为好&lt;/li&gt;
  &lt;li&gt;准确度，怎样更接近真是精确度，如何算好&lt;/li&gt;
  &lt;li&gt;相关性，什么样的讨论是不相关的&lt;/li&gt;
  &lt;li&gt;错误容忍度&lt;/li&gt;
  &lt;li&gt;可见行 - 外部怎么知道某种方法论是否被很好遵循，是否需要审计等&lt;/li&gt;
  &lt;li&gt;扩展性&lt;/li&gt;
  &lt;li&gt;稳定性 - 多大程度上它可能发生变化&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;发布一种方法论&quot;&gt;发布一种方法论&lt;/h3&gt;

&lt;p&gt;发布方法论需要发布两种组件，一时可视的&lt;strong&gt;形象化视图&lt;/strong&gt;，一是&lt;strong&gt;文本&lt;/strong&gt;本身。形象化的视图可能无法显示实践/标准和其它一些对组织很重要的协作方式描述。这些信息很难作出一个形象化的视图来呈现，这时候我们必须用文本来列出来。&lt;/p&gt;

&lt;p&gt;发布出来的方法论文本需要描述技术/活动/会议/质量度量/工作角色的指责标准这样的东西。方法论的文本可能变得异常庞大，即使一个很&lt;em&gt;细微&lt;/em&gt;的方法论，譬如只有4种角色，每种角色只有4种产出，每个产出只有4个里程碑，最终也会产生出&lt;strong&gt;68=4+16+48&lt;/strong&gt;个互锁的子部分需要描述清楚。即使是以轻量级著称的XP方法论，最初只有200页那么多，现在已经达到了1000页才可以描述清楚。&lt;/p&gt;

&lt;p&gt;但是很多时候，公司组织并不会将这些东西打印出来，因为&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;理解这些比文档本身重要 - Jim Highsmith&lt;/li&gt;
  &lt;li&gt;组织的需求总是在变化的，固定下来的文本很容易过时也没有实用性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组织需要不断的演进既有的方法论，变更不合适的部分，在组织内部的&lt;strong&gt;不同团队之间传递好的习惯和实践&lt;/strong&gt;。有很多中方法来减少这些方法论文本的厚度:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提供工作产出物的范本&lt;/li&gt;
  &lt;li&gt;移除技术操作指南，让人们用更自然的方式协作&lt;/li&gt;
  &lt;li&gt;根据角色来组织方法论文本，某种产出物按照不同的角色给出简单的描述&lt;/li&gt;
  &lt;li&gt;做些关于流程的小实践，通过小的练习实践这些方法，然后再用于具体的工作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;方法论设计原则&quot;&gt;方法论设计原则&lt;/h2&gt;

&lt;h3 id=&quot;常见的设计错误&quot;&gt;常见的设计错误&lt;/h3&gt;

&lt;h3 id=&quot;成功的方法论项目&quot;&gt;成功的方法论项目&lt;/h3&gt;

&lt;h3 id=&quot;作者敏感度&quot;&gt;作者敏感度&lt;/h3&gt;

&lt;h3 id=&quot;七大准则&quot;&gt;七大准则&lt;/h3&gt;

&lt;h2 id=&quot;审视xp&quot;&gt;审视XP&lt;/h2&gt;

&lt;h2 id=&quot;究竟为何需要方法论&quot;&gt;究竟为何需要方法论&lt;/h2&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第四部分，主要讨论方法论和方法设计的一些基本规则，已经如何清晰地定制和应用这些规则。</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - 3</title><link href="https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - 3" /><published>2013-08-14T20:32:00+08:00</published><updated>2013-08-14T20:32:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-3/">&lt;p&gt;本文是第三部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2013/08/14/agile-software-development-the-cooperative-game-reading-2/index.html&quot;&gt;第二部分&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;信息交换和流动&quot;&gt;信息交换和流动&lt;/h2&gt;

&lt;p&gt;如果我们将软件开发活动看作是协作游戏，那么如果Kim知道一些Pat需要的信息，则项目的进度就取决于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pat需要花多少时间了解到Kim知道他想要的信息&lt;/li&gt;
  &lt;li&gt;Pat和Kim需要耗费多少时间和其它成本来完成对于信息的交流和转移&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;各种情况的开销&quot;&gt;各种情况的开销&lt;/h3&gt;

&lt;p&gt;有六种不同的情况可以考量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Kim和Pat在同一台计算机前做结对编程，这样的交互成本几乎为零。&lt;/li&gt;
  &lt;li&gt;Kim和Pat在相邻的位置上；Pat可以通过观察Kim知道他可能在找某些东西而他恰好知道 - 有一些发现问题的成本&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在两个背对的位置，只有Kim主动提出问题，否则Pat不可能知道他想要某些信息&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在一个有一堵墙隔开的相邻位置，Kim必须站起来，看看Pat是否在位置上，然后才能交互信息&lt;/li&gt;
  &lt;li&gt;Kim和Pat坐在不同的隔间，甚至不同的楼层，kim必须走过去看看，这时候Pat可能不在位置上！&lt;/li&gt;
  &lt;li&gt;Kim和Pat在不同的办公区或者不同的地方，他们的沟通和交互就很少能有效和及时&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果用需要花费的时间和精力为参考单位（ergo-seconds），那么上述不同情况的开销是递增的。项目成本的上升是和人们需要花费多少时间来理解彼此的想法是&lt;strong&gt;成正比&lt;/strong&gt;的。&lt;/p&gt;

&lt;h3 id=&quot;osmotic-communication&quot;&gt;Osmotic Communication&lt;/h3&gt;

&lt;p&gt;写代码/阅读/学习的同事，我们随时提取周围环境中发生的谈话，利用背景噪音的模式，选取我们关心的内容随时参与讨论，对于不关心的则过滤出去。这种方式的沟通极大的降低了信息流动的成本。办公环境的部署过于分散可能有不提问题造成的潜在时间开销，信息传输的开销和人们无法在谈话中随时给出意见的额外开销。根据此理论，赞助物理分散的分布式团队需要三思而行。然而简单将所有人扔在一起也未必像相像的那样可以很好的解决问题。&lt;/p&gt;

&lt;p&gt;人们在传递什么样的信息？团队个人的习惯偏好如何？不同种类的信息是否会相互干扰？很常见的做法是，将负责实现的程序员安排在大楼的一侧，而将负责需求分析和商业策略领域专家安排在另一侧；因为他们彼此讨论的话题往往形成很强的噪音。然而这种方式也有明显的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;两者之间沟通的成本变高&lt;/li&gt;
  &lt;li&gt;两个团体可能形成自己小的社区并进而对对方进行指责和抱怨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cockburn的偏好是将一个商业专家安排在几个程序员的中间；如果做不到，那么通过其它的方式加强他们之间的沟通和理解，譬如定期的会议，审查等。Feature team的做法是鼓励跨只能的团队，用Feature的方式将各个领域的人聚集在一个团队，减少信息沟通的成本，加快信息的流动。&lt;/p&gt;

&lt;p&gt;个人偏好也是个需要考虑的问题，譬如有的程序员就是喜欢自己安静的空间，不希望有很多的背景噪音干扰。还有些人对哪些人在自己的周围有强烈的偏好 - 如果某个高级的程序员由此选择离开，那么成本之高就变得无法接受。因此调整位置的时候，需要尽量考虑到个人的偏好。&lt;/p&gt;

&lt;h3 id=&quot;信息辐射器&quot;&gt;信息辐射器&lt;/h3&gt;

&lt;p&gt;信息辐射器可以显示任何一个路过的人都可以看到的关于项目的信息；这样他们就不会专门跑过来问某些上面已经有的信息。这样做的好处有两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;辐射器上的信息总是随着时间的变化在实时更新&lt;/li&gt;
  &lt;li&gt;人们花费很少的精力就可以注意到这些信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;白板墙可以作为很好的信息辐射器，而公共的Wiki或者Web页面就不是；因为人们不用什么力气就可以随时看到墙上的东西，而web页面需要人们动鼠标打开那个网址。&lt;/p&gt;

&lt;p&gt;人们可以用辐射器显示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下个迭代的任务分解情况&lt;/li&gt;
  &lt;li&gt;每天的任务完成进度情况 - burndown chart等&lt;/li&gt;
  &lt;li&gt;自动化测试通过情况和通过率&lt;/li&gt;
  &lt;li&gt;回顾会议的输出&lt;/li&gt;
  &lt;li&gt;验收测试通过情况&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;热空气理论应用&quot;&gt;热空气理论应用&lt;/h3&gt;

&lt;p&gt;很多公司都意识到在咖啡机旁边放一些白板或者宣传栏的益处。人们可以在停下来聊天的时候注意到这些公开的信息。但是还有一个重要的地方不能漏掉的是，我们要尽量确保这些东西在视线之内，或者可以被清晰的听到。人们在讨论某些东西的时候，可以在身边随手可得的白板上写下自己的设计思路和想法，快速的和对方沟通。&lt;/p&gt;

&lt;p&gt;任何一个项目团队都应该力求&lt;strong&gt;减少发现和传递信息的整体开销&lt;/strong&gt;。这意味着随时发现并加速信息的流动和交换，利用Osmotic Communication的好处，注意潜在的问题和限制，最终减少成员之间信息交换的成本，搬开座位安置不合理造成的障碍。&lt;/p&gt;

&lt;h2 id=&quot;跨越沟通交流的沟壑&quot;&gt;跨越沟通交流的沟壑&lt;/h2&gt;

&lt;p&gt;为了提高沟通的效率，我们需要提高信息的发送方和接受方在可能存在沟通障碍的时候能够尽最大的可能跳过这些障碍的可能性。双方应该能以最快速方便的方式提供反馈，并尽可能地&lt;strong&gt;消除&lt;/strong&gt;可能存在的希望表达的&lt;strong&gt;意识偏差&lt;/strong&gt;。人们在沟通的时候，很可能使用语言之外的其它方式来表述意图(可能是积极的但也可能是消极的负面反馈)，如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;距离上的疏远或者靠近&lt;/li&gt;
  &lt;li&gt;空间感觉和反应(视频聊天就在这方面缺失了空间信息)&lt;/li&gt;
  &lt;li&gt;人身上的体味对方是否习惯或者反感&lt;/li&gt;
  &lt;li&gt;肢体上的接触&lt;/li&gt;
  &lt;li&gt;声音语调的变化&lt;/li&gt;
  &lt;li&gt;肢体语言&lt;/li&gt;
  &lt;li&gt;提问回答的热情程度&lt;/li&gt;
  &lt;li&gt;是否有其它方面的干扰&lt;/li&gt;
  &lt;li&gt;相互之间的信任和愿意从对方学习的情绪&lt;/li&gt;
  &lt;li&gt;是否使用共享的信息辐射器来共享常见的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上边这些因素和机制利用得当能够极大的提高沟通的效率。反之，移除其中一些，人们就不得不用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;电话 - 无法从物理上解除对方&lt;/li&gt;
  &lt;li&gt;电子邮件 - 没有声音&lt;/li&gt;
  &lt;li&gt;单向的沟通&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果这些机制都没有被很好的利用，就会出现&lt;em&gt;文档作为沟通的主要方式&lt;/em&gt;。因而好的项目领头人会推荐如下这些实践：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将所有人丢在一个会议室里边&lt;/li&gt;
  &lt;li&gt;保持每个团队的短小精干&lt;/li&gt;
  &lt;li&gt;多用白板表述意图，而不是负责的绘图软件&lt;/li&gt;
  &lt;li&gt;办公区的白板和咖啡角随处易得&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然这些warmmer communication方式仅仅使用于传递想法和真正沟通的时候。传统的cooler communication方式仍然在其它一些场合发挥着重要作用。如果一个高级设计人员在会议中始终占据着发言权和白板，那么系统自组织性的丧失就会很快让沟通变得更加的困难。邮件的允许人们发送之前仔细审视的特点更容易让人们澄清他们真正表述的观点 - 如果这些观点需要慎重的思考的话。&lt;/p&gt;

&lt;h2 id=&quot;团队即社区&quot;&gt;团队即社区&lt;/h2&gt;

&lt;p&gt;一个团队即时一个社区，每时每刻都有很多信息在流动；但是每个团队个体成员可能有不同的兴趣和目标，有自己的专长和侧重。在一个高效的团队中，成员通过&lt;strong&gt;pull&lt;/strong&gt;的方式提取自己感兴趣的信息，反馈给其它成员。人们根据&lt;strong&gt;整个团队的方向&lt;/strong&gt;来协调这些信息的讨论和流动；因此整个团队需要保持一致的方向。&lt;/p&gt;

&lt;h3 id=&quot;小幅度改进&quot;&gt;小幅度改进&lt;/h3&gt;

&lt;p&gt;只需要让每个人改变一个小小的方面 - 这些方面很可能对他个人而言是无足轻重的，最终也可以带来很大的整体效应；因为每个人都向着共同的目标改进一小点，所以每个人对变化的感受都是很细微的，但是因为人们对其它密切相关的同事贡献出他自己的想法，而不是各干各的，最终整个团队的效率会得到巨大的提升。&lt;/p&gt;

&lt;p&gt;为了达到真个团队大方向上的一致，开发人员和项目利益相关人需要讨论和定制每个成员都需要认可的整体决策，这也同时要求很多决定必须是&lt;strong&gt;团队整体的承诺&lt;/strong&gt;而不是经理们的个人意愿。在项目发展的过程中，优先级可能发生巨大的变化或者调整，这个时候，所有人必须被重新集中起来沟通这些变化，确保所有人都知道并且同意这个变化。&lt;/p&gt;

&lt;h3 id=&quot;冲突和纪律&quot;&gt;冲突和纪律&lt;/h3&gt;

&lt;p&gt;团队保持紧密一致不意味着不能有冲突发生。一个团队中几乎没有冲突发生也是不正常的，因为这很可能意味着大家可能更愿意保持沉默不再说出自己的真正想法。&lt;strong&gt;当人们向团队中的其他人掩盖一些信息的时候，潜在的开支就默默地急剧上升&lt;/strong&gt;。人们需要在正常的冲突中讨论出最优的方案使得各方一致满意；这样的结果恰恰是更有利于最终问题的解决。&lt;/p&gt;

&lt;p&gt;良好的社区纪律需要人们用对他人有益（当然间接对自己有益）的方式来共事。它需要成员&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;按时参加会议&lt;/li&gt;
  &lt;li&gt;回答别人提出的问题，如果知道答案的话&lt;/li&gt;
  &lt;li&gt;不烦于提出注意到的状况&lt;/li&gt;
  &lt;li&gt;遵从整体的编码规范/传统&lt;/li&gt;
  &lt;li&gt;使用一致的代码库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些要求对一些编码规范不满的程序员通过协商的方式定制出共同认可的编程风格 - 虽然个人可能不认可当前的规范，但是通过协商得到&lt;em&gt;稍微看得过去的&lt;/em&gt;规范也比完全没有强。当然，这些纪律需要尽可能在正常的工作时间内实施，而不是通过&lt;strong&gt;加班&lt;/strong&gt;来延长工作时间。&lt;/p&gt;

&lt;h3 id=&quot;团队建设&quot;&gt;团队建设&lt;/h3&gt;

&lt;p&gt;好的团队建设最好的方式是通过一些小小的成功来实施，不管是多小或者多大的成功。混乱的大规模团队建设活动在很多情况下可能仅仅是浪费钱财。真正的团队建设可以通过&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使团队正在凝聚在一起 - 譬如让物理上分散的团队能尽量经常见面，通过共同的工作取得一些进展，然后不时将这些人放在一些社交活动中。&lt;/li&gt;
  &lt;li&gt;产生成绩 - 这样可以产生和传递&lt;strong&gt;正能量&lt;/strong&gt;，消除恐惧和不信任感。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;团队文化背景差异和协作&quot;&gt;团队文化背景差异和协作&lt;/h3&gt;

&lt;p&gt;团队的沟通和交互需要更多的采取&lt;strong&gt;协作而非合作&lt;/strong&gt;的形式。协作意味着人们通过频繁的交互和沟通达成一致意见，而合作则意味着通过分工/各自独立工作/集成的方式来达成目标。不同的文化背景可能对这些方面有不同的假设前提，不过敏捷方法论的做法是尽可能得通过协商达成一致。&lt;/p&gt;

&lt;p&gt;具有多个领域特长的专家（譬如精于项目管理和设计倾听的程序员）可以在不同的对象之间充当翻译，以便提高不同的专业人员之间的沟通效率。每一个人都需要更多的联系实践和倾听的技巧：&lt;strong&gt;不管对方的看法多么的疯狂和颠覆，先那样听，然后再决定是否要反对&lt;/strong&gt;，因为那些疯狂的论断可能在另外一个价值体系里边确实司空见惯的常识。&lt;/p&gt;

&lt;h2 id=&quot;视团队为生态系统&quot;&gt;视团队为生态系统&lt;/h2&gt;

&lt;p&gt;一个软件项目的建立同时也创建了一个新的生态系统，这个系统由特质各异/文化背景相左的个体组成。观察这个生同系统的要素，我们可以得到&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;办公室的墙壁成为隔离的壁垒，公共的空间提供交互场所&lt;/li&gt;
  &lt;li&gt;特性各异的个体好比不同的物种&lt;/li&gt;
  &lt;li&gt;每一个具有不同特性的个体的工作方式极大得影响着整个生态系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个项目团队都是独一无二的，原则上并没有太具体的原则和实践可以误差别地施加于你的团队。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有团队中的人才可以决定什么样的方式在那个特定的环境中工作的更好 - 调整环境来服务你的团队&lt;/li&gt;
  &lt;li&gt;如果团队中一些人有很好的方法学知识，他就能很好的回顾和反思他观察的并逐步改进 - 发现每个人的长处，找到一个最好的方式以便发挥各自的优势&lt;/li&gt;
  &lt;li&gt;视每个团队的方法实践为一种&lt;strong&gt;新的建设&lt;/strong&gt;，没有一种现有的办法可以不经修改完全适用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键的团队自身需要通过不断的反思来自适应，逐步改进工作的方法，并逐渐找到更优的方式。&lt;/p&gt;

&lt;h2 id=&quot;ken-auer的程序员办公室&quot;&gt;Ken Auer的程序员办公室&lt;/h2&gt;

&lt;p&gt;这是一种典型的值得参考的办公环境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个大的用于编程的房间，中间是结对编码区域，四个长桌子围成长方形，人环座四周，长的一侧的桌子允许两对人工作，短的一侧允许一对，这样可以容纳最多12个人结对&lt;/li&gt;
  &lt;li&gt;编程办公室的四周靠墙壁的地方放置用于私人空间的编程工作 - 人们可以再这里创建私有的空间来做一些不受打扰的思考工作&lt;/li&gt;
  &lt;li&gt;编程办公室的南边是接待室和销售人员办公室，设备和浴室也在这一块儿空间；接待室在中间相隔，实现动静分离&lt;/li&gt;
  &lt;li&gt;编程办公室的西边是厨房和与之相隔的更远一点的会议室&lt;/li&gt;
  &lt;li&gt;西南是图书馆和客户办公室，图书馆在中间做一个动静分隔的作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;待续。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第三部分。</summary></entry><entry><title type="html">Agile software development - the cooperative game - 笔记 - part2</title><link href="https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2/" rel="alternate" type="text/html" title="Agile software development - the cooperative game - 笔记 - part2" /><published>2013-08-14T20:32:00+08:00</published><updated>2013-08-14T20:32:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/14/agile-software-development-the-cooperative-game-reading-2/">&lt;p&gt;本文是第二部分(&lt;a href=&quot;/blog/2013/08/11/agile-software-development-the-cooperative-game-reading-1/index.html&quot;&gt;第一部分&lt;/a&gt;)。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;作为个体的人&quot;&gt;作为个体的人&lt;/h2&gt;

&lt;p&gt;人们常常选择性的忽略了软件开发和实际过程是由一个一个的&lt;strong&gt;个体的人&lt;/strong&gt;来完成的；然而人都有弱点，容易犯错，有固定的失败模式/成功模式，以及通用的行为模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;人们的行为通常是难以预测的&lt;/li&gt;
  &lt;li&gt;人性本身有些固有的失败模式&lt;/li&gt;
  &lt;li&gt;总有一些方式比另外一些方式更容易让人们共同工作，即使对同样一群人&lt;/li&gt;
  &lt;li&gt;有很多模式引起失败，那么什么样的方式才能达成成功?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;人的行为模式&quot;&gt;人的行为模式&lt;/h3&gt;

&lt;p&gt;人的行为总是非线性的并且比一般的物理实体复杂的多；给予双倍的奖励，或者双倍的惩罚，甚至于双倍的时间，都不能确定的提高一个人的思考速度/思考质量/编程设计输出。一个每周工作40个小时的人可能在下周工作60个小时就可以得到双倍的进展，但是接下来一周再工作60个小时，可能不仅不能维持之前双倍的效率，可能反而不及最初正常的效率，因为人们会产生疲惫。&lt;/p&gt;

&lt;p&gt;人的行为会突然发生偶然的变化，某某可能突然对测试工作发生兴趣；一个偶然的小事儿可能导致一个高级工程师的离开等；某个工程师可能在一种情况下显得特别容易沟通而换了一种环境则会变得难以沟通。人们协作的方式也可能有巨大的差异，不同的文化背景可能青睐于不同的沟通方式；直接或者保守在不同的文化氛围中显得完全不同。真因为这些不可避免的差异，所以才有各种各样的技术方法被发明出来，然后，&lt;strong&gt;没有一种方法是绝对有效&lt;/strong&gt;的。这个结论是明显的，然后人们往往容易忽略之，而盲目的鼓吹某种方法是&lt;strong&gt;正确&lt;/strong&gt;的方式并且期望所有人按照这种方式来工作。&lt;/p&gt;

&lt;p&gt;人的行为在很多方面表现出巨大的不同，并不意味着一些通用的方法就没有意义；还是有些东西在很大的范围内行之有效的。基于此，我们就可以在承认人与人之间巨大差异的基础上来建立大家认可的方法，但是并不能由此期望人们的具体行为会趋同或者可以严格预测。&lt;/p&gt;

&lt;p&gt;有效的过程方法的意义在于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;允许人们更容易地表述他们的想法&lt;/li&gt;
  &lt;li&gt;可以完成一个人无法独立完成的工作&lt;/li&gt;
  &lt;li&gt;将复杂而又繁琐的工作自动化&lt;/li&gt;
  &lt;li&gt;使得人们的相互沟通更容易&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;失败模式&quot;&gt;失败模式&lt;/h3&gt;

&lt;p&gt;有如下五种比较普遍的失败模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;人们总是会犯错&lt;/strong&gt; - 简单但又常常被人们忽略；敏捷和迭代开发的巨大进步意义就在于承认人总是会出错，但是通过一连串小的错误来及早暴露风险；持续不断的解决问题而不是固守详细周密的计划 - 没有错误的计划似乎只存在于真空之中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;倾向于保守谨慎&lt;/strong&gt; 在最终结果一致的情况下，同样的问题通过不同的方式呈现出来，人们的反应却有可能大不相同。当我没可能获得比较高的潜在收益的时候，人们总是倾向于去冒险，然后在可能失去某些东西的时候，人们则会倾向于选择更保守的方式。一个有很多瀑布模式成功经验的manager（其实这些成功的经验有多大程度上算作成功就很难考量）在一个初级的工程师提出尝试迭代开发的模式的时候可能持激烈的反对态度；他可能更愿意采用传统的策略，能产生“确定“的输出而不是”可能产生更大收益“但是又”看起来奇怪“的方式&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;习惯的不一致性&lt;/strong&gt; 如果人们总能保持一致，那么就不会有减肥/锻炼的问题。问题是&lt;strong&gt;我们从来不缺少方法实践，缺少的恰恰是实践这些方法&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;倾向于发明新的东西而不是研究已有的方案&lt;/strong&gt; 大概跟人们接受的教育有关 - 鼓励原创的论文/独立完成的作业等等；而不是团队工作。很多时候人们需要更好的重用已有的成果而不是自己从头发明一切&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自律和适当容忍的妥协&lt;/strong&gt;  强调高度的自律往往是一厢情愿，然后过度的妥协又容易导致越来越多的混乱。项目经理可能对严格要求团队遵循某个方法实践所带来的副作用感到惊讶。譬如XP实践强调结对编程和Coach，然后很多Team在实践的过程中却将重构的工作丢下不理，等待更高级的工程师去做&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;某些方式总是比其它的更好&quot;&gt;某些方式总是比其它的更好&lt;/h3&gt;

&lt;p&gt;尽管人与人之间的差异是巨大的，然而总有一些方法是更有效的。人们倾向于做的更好，如果他们&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从具体的例子开始&lt;/li&gt;
  &lt;li&gt;从容易处理的东西开始着手&lt;/li&gt;
  &lt;li&gt;从已有的东西入手寻找替代/优化的方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些方法也更容易让人们取得积极的进展：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过观察和学习的同时做工作&lt;/li&gt;
  &lt;li&gt;支持精力集中的思考并同时支持积极的沟通 - 设置安静时间和公共沟通区域来加强沟通&lt;/li&gt;
  &lt;li&gt;根据人们的长处进行任务分配&lt;/li&gt;
  &lt;li&gt;选择最好的人才&lt;/li&gt;
  &lt;li&gt;激励方式的选择 - 开发人员的工作激情/成就感/贡献荣誉感觉&lt;/li&gt;
  &lt;li&gt;清晰有效的反馈 - 越及时效果越好&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;寻找成功模式&quot;&gt;寻找成功模式&lt;/h3&gt;

&lt;p&gt;作者长期面试成功项目团队的经验中，如下的申明频繁的出现： &lt;strong&gt;一小部分人在关键的时间介入，作出了一切需要做的工作&lt;/strong&gt;。看起来是很随意的描述，然而更仔细的审视发现，如下的一些成功因素慢慢浮现出来:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;擅长于四处观望式的扫视 - 设计文档未必需要每一个细节都和实现保持一致，只要大致结构的一致即可。做维护工作的开发者就可以通过快速的浏览找到需要的部分，剩下的就是具体怎么做了，细节的准确意义并没有想的那么大了。文档只需要&lt;strong&gt;保持足够的精确&lt;/strong&gt;即可，能完成主要的工作，使得人们不用费很大功夫就可以找到对应的细节即可。Tech Lead仅仅需要大致看一下问题大概在什么地方并知道其它工程师去做即可，而不是处理每一个细节&lt;/li&gt;
  &lt;li&gt;人们持续不断的学习 - 敏捷过程提出的持续改进就是这么一个思想，回顾当前迭代中那些值得改进的，持续的需西和发现不足，人们就能不断的进步。&lt;/li&gt;
  &lt;li&gt;可以改变的韧性 - 通过团队的集体氛围来慢慢提高个体的韧性，使之适应并改变 - 当然并不是每个个人都可适应这个过程，然后他就会离开&lt;/li&gt;
  &lt;li&gt;主动承担和贡献&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;融合这些成功的因素&quot;&gt;融合这些成功的因素&lt;/h4&gt;

&lt;p&gt;是否有融合这些成功因素的方法存在？&lt;strong&gt;自组织团队&lt;/strong&gt;的想法给出了一种思路，但是实现的过程自然是充满崎岖的。需要培养这样的氛围，每个人都需要能够第一时间发现系统中的错误，不管这个人的职位和角色是什么；&lt;strong&gt;他将错误传递到能够正确纠正错误的人的成本&lt;/strong&gt;往往决定了&lt;strong&gt;整个项目的成本&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;平衡各种策略&quot;&gt;平衡各种策略&lt;/h2&gt;

&lt;p&gt;很多时候看起来很好的策略并不意味着在大部分情况都是好的 - 譬如让一个Team的成员坐在一起。&lt;a href=&quot;http://pmdoi.org&quot;&gt;PMDOI&lt;/a&gt;认为，我们可以通过具体情况具体分析的策略/工具和方法来真正提高效率和可靠性。一个真正好的策略需要平衡各种足够好的基本策略，将其打包调整其中的某些不合时宜的做法。想想人们常说的，坐在一起的团队和面对面的沟通总是能达到最好的效果；但是为了达到&lt;strong&gt;真正高效的沟通&lt;/strong&gt;(因为这才是&lt;strong&gt;最高优先级的事情&lt;/strong&gt;),我们还需考虑到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;人们有时候需要安静的思考和集中注意力的工作&lt;/li&gt;
  &lt;li&gt;有时候需要进行一些安静的对话来交换一些深思熟虑的意见&lt;/li&gt;
  &lt;li&gt;有时候需要放松的心态学习一些新的语言/工具等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Osmotic Communication要求人们做的足够的近以便周围人的谈话都很容易被听清楚，这样有什么问题就可以马上作出反应；信息传递的成本几乎为零。这样一些复杂的问题可能会被周围的专家以最快的速度解决。然后Cone of Silence策略则提出了一种相反的做法：一个或者多个团队成员坐得距离其它人远远的从而可以排除沟通干扰。但是这种策略也有典型的适用场合，譬如Tech Leader本来应该用于安排解决艰难负责的问题，然而由于周围的人不断得分散其注意力，导致复杂的问题没有被解决，进度不断被延误，进而导致情况更加恶化。Cockburn认为，相互沟通的两个人的距离超过一辆公交车的长度时，沟通的效果就会急剧下降。&lt;/p&gt;

&lt;p&gt;策略的平衡意味着，安排座位的时候需要考虑某些负面的影响 - 有些时候需要将人们适度分隔开来而不是聚越来越多的人在一个大的空间。当周围的噪音和干扰越来越大的时候，人们容易觉得压抑和头疼，很多重要的工作都无法正常的完成。每一种策略都有一定的限制；明智的决策什么时候&lt;strong&gt;Osmotic Communication&lt;/strong&gt;是有效的，什么时候它因为人太多而失去意义是个重要的事情。&lt;/p&gt;

&lt;p&gt;待续。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">本文是第二部分(第一部分)。</summary></entry><entry><title type="html">Agile software development - The cooperative game - 笔记 - part1</title><link href="https://skyscribe.github.io/post/2013/08/11/agile-software-development-the-cooperative-game-reading-1/" rel="alternate" type="text/html" title="Agile software development - The cooperative game - 笔记 - part1" /><published>2013-08-11T09:52:00+08:00</published><updated>2013-08-11T09:52:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/11/agile-software-development-the-cooperative-game-reading-1</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/11/agile-software-development-the-cooperative-game-reading-1/">&lt;p&gt;这本书的中文译名是一个平淡无奇的«敏捷软件开发»，这个名字是如此的平庸以至于放在书架上不会有几个人注意到它真正的价值，除非你仔细的阅读了书面封底的作者介绍和英文原版所获得的荣耀 - 17届Jolt大奖获奖作品；而Cockburn大师本身又属于一个人能连续两次获得Jolt的技术作家之一；但是能够在连续两年中获得两次Jolt大奖的，估计又少之又少了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;脉络&quot;&gt;脉络&lt;/h2&gt;

&lt;p&gt;这本书讲述的部分很多已经超越了软件开发本身，并且也并没有特别偏颇的只讲述Agile一种方法，而是从多个角度综合衡量多种方法论的优缺点和使用场景。总体而言，这又是一本务实的书，而不是简单的对agile方法进行鼓吹和传教。&lt;/p&gt;

&lt;p&gt;全书的结构可以看作三个部分（虽然作者认为是2个部分）:&lt;/p&gt;

&lt;h3 id=&quot;理论&quot;&gt;理论&lt;/h3&gt;

&lt;p&gt;前边一半的篇幅用于介绍各色理论 - 沟通的基础和协作，个人的影响，交互通信的方式和特点，团队以及方法学。讨厌理论的人可能会跳过这一大部分，然后我个人的看法是，这恰恰是作者最精华的所在。理论的探讨也不是简单的罗列和论证，而是引用其它人的研究成果，并结合了作者自己做管理咨询工作的经验和分析总结。每一个章节，都分为一大一小两个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前者详细的分析和论证主题，并根据实践经验加以总结和分析&lt;/li&gt;
  &lt;li&gt;第二部分大多冠以&lt;strong&gt;evolution&lt;/strong&gt;的后缀，在前者部分基础上加以升华或者扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实践和方法学&quot;&gt;实践和方法学&lt;/h3&gt;

&lt;p&gt;第二个部分主要侧重于实践，即各种各样的方法学和实践方式，主要侧重怎样做的问题和思考这些方法学可以给个人带来怎么样的启发。描述了集中方法论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XP&lt;/li&gt;
  &lt;li&gt;Light and agile&lt;/li&gt;
  &lt;li&gt;Self adapting&lt;/li&gt;
  &lt;li&gt;Crystal family&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方法和常见的Scrum/XP/Clean Room方法论有些不同；其实现有的方法分支都以这些公共的理论为基础，互相学习/发展和渗透。&lt;/p&gt;

&lt;h3 id=&quot;附录&quot;&gt;附录&lt;/h3&gt;

&lt;p&gt;一般书籍的附录不会太长，仅仅添加一些和主旨无太大关系的说明或者索引。这本书则不属于这一类；初一看会发现书籍的附录占据了四分之一的篇幅，并且分成留个章节，只有最后一个章节是关于索引和书籍引用的常规内容。其它的部分，也遵从了前边两个大块的结构，对正文没有详细说的部分做了更深入的扩展，或引用大篇幅已经脱销的书籍文字，或者直接给出一些偏一轮的paper的大部分乃至全文来辅助全书的主线。个人感觉这部分其实可以作为一个独立的部分。&lt;/p&gt;

&lt;p&gt;有趣的是，敏捷宣言的部分和敏捷联盟的成立背景也在这里做了详细的介绍 - 由此我才明白为何外界对敏捷有那么深刻的误解：这只是一个松散的联盟，参与发起的先驱们其实有着很不同的观点和方法论。这个过程的产出才是大家常见到的敏捷宣言，过程本身又呼应了作者的观点 - 这是一个关于&lt;strong&gt;协作&lt;/strong&gt;的游戏。&lt;/p&gt;

&lt;h2 id=&quot;理论-1&quot;&gt;理论&lt;/h2&gt;

&lt;h3 id=&quot;沟通和倾听的三个境界&quot;&gt;沟通和倾听的三个境界&lt;/h3&gt;

&lt;p&gt;作者认为沟通是极其苦难的事情，甚至有些时候是那一达到的，所以才有各种各样的方法论来减少协作的难度。这个过程是有不同的阶段的，作者引用了Shua-Ha-Ri的学习理论来阐述这三个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shu 是基础部分，需要维持基本的原则和方法，学习成熟的方法和实践，确保这些实践不被破坏；这个是基础阶段，需要有mentor或者coach指明一条正确的道路，引导大家走下去，不要偏离到错误的路上去。&lt;/li&gt;
  &lt;li&gt;Ha 是脱离第一个阶段，适度偏离死板的教条，获得一定的自由去深入的反思和理解其中不合乎实际情况的部分。这个部分的前提是，一些基础的原则和实践被真正吸收和消化，否则就容易随意的否定和偏移，这是一个提高的阶段&lt;/li&gt;
  &lt;li&gt;Ri 是最高的升华阶段，这个水平之上要求能超越已有的所有舒服，用实践者的方法从实际情况出发，找到最适合的方式。这一阶段任何书籍和方法仅仅是参考，需要的是原创的思想和过程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理想的沟通在很多时候甚至是不可能的事情，尤其是如下的情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;人们很容易误会口头表达的意思&lt;/li&gt;
  &lt;li&gt;有歧义的术语或者名词常常产生误解&lt;/li&gt;
  &lt;li&gt;喋喋不休的人可能给出的指令是让人不想仔细听下去或者真正听进去&lt;/li&gt;
  &lt;li&gt;领域知识的差异导致信息准确性的降低&lt;/li&gt;
  &lt;li&gt;不同的知识背景导致某些预设的关于常识的背景可能根本就不存在&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体到实际工作中来，就会有&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;设计文档阐述的意图很难准确和无偏差&lt;/li&gt;
  &lt;li&gt;经验丰富的开发者很可能用简洁的语言描述设计想法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有鉴于此，我们可以在沟通的过程中，尽量创造&lt;strong&gt;共同的经验和背景知识&lt;/strong&gt;作为讨论的前提，并在作出具体的Action之前多确认不必要的误解。而这一切都需要更好的协作和交互。&lt;/p&gt;

&lt;h3 id=&quot;软件和创造沟通游戏&quot;&gt;软件和创造/沟通游戏&lt;/h3&gt;

&lt;p&gt;游戏可以按照是否有目标和是否终止分为如下三个类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有限结束的，没有目标导向的，如弹钢琴，跳舞等&lt;/li&gt;
  &lt;li&gt;有限的，但是有确定的目标，譬如网球比赛，软件开发&lt;/li&gt;
  &lt;li&gt;无限永远不终止的，如职业生涯管理，商业组织生存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自然这里关于有限无限的定义，是基于一个一个具体的活动而言的，譬如职业生涯的发展，相对于一次的工作更替来说是无限继续下去的，但是对于人的生命而言又是相对有限的，当然这个是不同的范围界定了。&lt;/p&gt;

&lt;p&gt;Cockburn认为最容易和软件开发活动做对比的莫过于攀岩运动，因为他们有如下的共同之处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注重协作和目标导向：攀岩需要登顶，还需要分工合作，软件开发也同样有清晰的商业目标（开源软件不在此列），并且强调分工协作（个人项目自然不算）&lt;/li&gt;
  &lt;li&gt;负载均衡和分工：根据不同的需要和负载来协作分配资源和重心&lt;/li&gt;
  &lt;li&gt;团队：需要用团队的方式来完成&lt;/li&gt;
  &lt;li&gt;智力水平的要求：有些人永远不能完成攀岩，有些人永远没有智力和能力做软件开发工作&lt;/li&gt;
  &lt;li&gt;技巧密集型：需要经验和技巧的积累才能更好的完成目标&lt;/li&gt;
  &lt;li&gt;培训：各种知识和技巧需要事前的培训才可&lt;/li&gt;
  &lt;li&gt;工具：需要用工具来提高效率，并且工具扮演了一个重要的角色&lt;/li&gt;
  &lt;li&gt;资源受限：没有无限制的资源供分配，必须协调和均衡&lt;/li&gt;
  &lt;li&gt;计划：必须事先指定某种粒度的计划，进行资源的分配&lt;/li&gt;
  &lt;li&gt;不确定性/挑战：总有无法预料的情况发生，天气可能突变，突然而来的技术问题等&lt;/li&gt;
  &lt;li&gt;乐趣：过程本身是有趣的，编程过程本身是有趣味的（至少很多程序员是因此从事这个职业）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;尽管有很多关于软件开发和传统工程学科的比较，然而Cockburn并不认为这样的比较是恰当的，因为工程师仅仅按照设计好的计划来操作就是，后期如果除了小问题，要么推倒重来，要么小修小补；然后几十年的软件工程时间却表明，仿照这种方式来操作带来了效率的问题和维护性的噩梦。软件开发的计划很难做到和变化的环境想符，而维护的成本也高昂到甚至直接取消项目。&lt;/p&gt;

&lt;p&gt;作为软件开发工程师，他们需要的是达到目标，理解问题然后找到一种方法解决面临的问题，并用合适的工具和语言实现该解决方案，并解决可能的变更和维护需要。从这个角度出发，软件开发活动是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;资源有限的&lt;/li&gt;
  &lt;li&gt;协作性的&lt;/li&gt;
  &lt;li&gt;注重创造和沟通的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时，软件开发活动同时要求在沟通的过程中，将发布可用的软件作为首要的目标的同时，积累一些经验可用用到下一个软件中去。软件开发团队在没有满足第一个目标之前必须优先尽可能保证当前的软件可以发布；然后做到第一个之后，对于第二个目标，必须同时考虑到资源的限制性，做到尽可能好就够 - 奢求文档永远和代码同步就是一个没有意义的目标。&lt;strong&gt;足够好&lt;/strong&gt;就是了。交互和协作才是最重要的，因为文档总为是死的，沟通则是总在变化的。&lt;/p&gt;

&lt;h4 id=&quot;重构软件开发过程&quot;&gt;重构软件开发过程&lt;/h4&gt;

&lt;p&gt;软件开发过程是一个通过协商来达到协作的过程，该过程通过个人的技术尝试和由各个贡献者组成的团队的协作达成专业技术上的决策。从这个意义上来说，注重交互和协作的软件开发过程和传统意义上的软件工程有很大的区别。ECN（Engineering Collaboration via Negotiation)就是通过群体的协作达成的技术决策来完成软件开发的活动。这一活动强调，最好的流程是通过共同构建的过程达成，在这个过程中，每个人都动态的参与并影响最终的决策。因为人的想法和观点总是在动态的变化，因此这一过程必然要求协作和协商的过程也是动态进行和持续不断的。&lt;/p&gt;

&lt;p&gt;同时这一过程也意味着工程上的协商决策(collaborative deal-making)和共同创新(collective innovation)。协作的结果是所有参与各方的互相竞争的偏好所达成的一整的意见。这个过程必然强调双赢的产出和新的创新，这些创新都不可能由单枪匹马的冒险所达到，而是通过协商而后的一致意见转化得来。&lt;/p&gt;

&lt;p&gt;待续。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">这本书的中文译名是一个平淡无奇的«敏捷软件开发»，这个名字是如此的平庸以至于放在书架上不会有几个人注意到它真正的价值，除非你仔细的阅读了书面封底的作者介绍和英文原版所获得的荣耀 - 17届Jolt大奖获奖作品；而Cockburn大师本身又属于一个人能连续两次获得Jolt的技术作家之一；但是能够在连续两年中获得两次Jolt大奖的，估计又少之又少了。</summary></entry><entry><title type="html">The productive Programmer - 笔记</title><link href="https://skyscribe.github.io/post/2013/08/06/the-productive-programmer/" rel="alternate" type="text/html" title="The productive Programmer - 笔记" /><published>2013-08-06T20:24:00+08:00</published><updated>2013-08-06T20:24:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/06/the-productive-programmer</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/06/the-productive-programmer/">&lt;p&gt;这是一本关于程序员生产效率的书，作者来自于Thought Works - 很多人一听到这个公司的名字就会在头脑中联系到敏捷/布道师这样的角色，并且可能在心里暗暗的寻思，又是一个光说不练的家伙在传播他们的理论了。但是仔细读来，才会发现这本书其实和敏捷并没有太大关联，讲述的也是一些实实在在的建议和实践。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;不要敏捷只要消除浪费&quot;&gt;不要敏捷，只要消除浪费&lt;/h2&gt;

&lt;p&gt;这句话摘自译者的序言中，简单明了的概括了这本书主要解决的问题 - 消除开发中的浪费行为，提高生产效率。作为一个程序员，你需要从什么地方来提高自己的生产率，消除浪费，并不是每个人都仔细想过这个问题；所以优秀的程序员才可以比平庸的程序员效率差异极大。当然提高效率的想法很简单，但是真正去做到实处，却是很难的，因为这需要不放过&lt;strong&gt;没有细微的地方&lt;/strong&gt;，发现浪费和降低生产率的做法，然后设法一点一滴提高。关注于每一个细节，对细节进行持续优化，通过对细节的改善来最终提高生产效率，这是个人工作方法上的敏捷，最终会取得个人工作效率上的持续提升。&lt;/p&gt;

&lt;p&gt;这本书对我而言最右价值的部分是关于Windows上的效率提升建议，讲述了很多实用的工具和方法。至于Linux上的，那些关于命令行和脚本的章节，早就受惠已久了所以自然没感觉到大的思路更新。&lt;/p&gt;

&lt;h2 id=&quot;启动面板和加载器&quot;&gt;启动面板和加载器&lt;/h2&gt;

&lt;p&gt;Linux的Unity是这方面很好的例子，让你可以脱离鼠标仅仅通过几个快捷键转瞬之间打开常用的引用，定制什么的也比较简单。Windows就没这么好用了，或者说大部分人都没有仔细去查阅如何来用键盘来实现类似的高效率。作者推荐了如下一些方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开始菜单之中创建一个启动面板，将常用的程序放进去，重命名快捷方式，使得每个程序的首字母一样，然后通过&lt;strong&gt;Windows+x&lt;/strong&gt;来启动，这里的字符就是重命名之后的程序名字的首字母&lt;/li&gt;
  &lt;li&gt;Windows的Power tools工具集，包括Tweak UI，可以用图形方式修改注册表&lt;/li&gt;
  &lt;li&gt;快速启动栏的程序，可以通过&lt;strong&gt;Windows+1&lt;/strong&gt;的方式启动程序，不过最多可以启动10个&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;地址栏加速&quot;&gt;地址栏加速&lt;/h3&gt;

&lt;p&gt;地址栏可以在当前路径的后边，输入一部份然后利用&lt;strong&gt;Tab&lt;/strong&gt;来补全剩余的；这个在当前目录里边有很多文件的时候尤其有用，可以减少很多鼠标点击和肉眼扫描。&lt;/p&gt;

&lt;h3 id=&quot;命令行提示符&quot;&gt;命令行提示符&lt;/h3&gt;

&lt;p&gt;可以在当前目录打开命令行，只需要安装&lt;strong&gt;Command Prompt Explorer Bar&lt;/strong&gt;这个开源工具，就可以用&lt;strong&gt;Ctrl-M&lt;/strong&gt;打开一个附着于资源管理器底部的命令提示符。当上边的资源管理器目录发生变化之后，底下的命令提示符目录也随之发生变化。&lt;/p&gt;

&lt;p&gt;Windows PowerToys的系列工具之一可以再右键菜单上加入“当前目录打开命令提示符”的子菜单，这样就可以简单的在当前目录打开一个命令窗口。&lt;/p&gt;

&lt;h3 id=&quot;键盘宏工具&quot;&gt;键盘宏工具&lt;/h3&gt;

&lt;p&gt;用宏来录制常用的键盘操作组合是个很好的做法，可以看看Windows流行的&lt;strong&gt;AutoHotKey&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;专注&quot;&gt;专注&lt;/h2&gt;

&lt;p&gt;下边的策略可以有效的排除干扰，专注于当前的工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;隔离策略，关闭不必要的提醒/邮件/手机等&lt;/li&gt;
  &lt;li&gt;关闭操作系统的气泡提示&lt;/li&gt;
  &lt;li&gt;为团队规定一段安静时间，除非特殊情况，任何人不要干扰&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;windows的有根视图&quot;&gt;Windows的有根视图&lt;/h3&gt;

&lt;p&gt;就是一种以某个子目录为文件结构根目录的做法；从中可以看到这个子目录的内容，但是不需要关心其它目录的内容。可以用如下的方式打开有根视图:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;explorer /e,/root,c:&lt;span class=&quot;se&quot;&gt;\w&lt;/span&gt;ork&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;it
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式只在打开的资源浏览器里边有效。另外一种办法是，在WIN7中为常用的目录创建Library。&lt;/p&gt;

&lt;h3 id=&quot;使用虚拟桌面切分窗口&quot;&gt;使用虚拟桌面切分窗口&lt;/h3&gt;

&lt;p&gt;可以使用Windows PowerToys里边的Virtual Desktop Manager打开多个桌面。每个桌面会有自己的快速启动栏，热键；并且可以同时打开所有桌面。这个是从Unix那边借鉴过来的特性，也没太多可说。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">这是一本关于程序员生产效率的书，作者来自于Thought Works - 很多人一听到这个公司的名字就会在头脑中联系到敏捷/布道师这样的角色，并且可能在心里暗暗的寻思，又是一个光说不练的家伙在传播他们的理论了。但是仔细读来，才会发现这本书其实和敏捷并没有太大关联，讲述的也是一些实实在在的建议和实践。</summary></entry><entry><title type="html">Pragmatic Programmer再读</title><link href="https://skyscribe.github.io/post/2013/08/05/pragmatic-programmerzai-du/" rel="alternate" type="text/html" title="Pragmatic Programmer再读" /><published>2013-08-05T21:18:00+08:00</published><updated>2013-08-05T21:18:00+08:00</updated><id>https://skyscribe.github.io/post/2013/08/05/pragmatic-programmerzai-du</id><content type="html" xml:base="https://skyscribe.github.io/post/2013/08/05/pragmatic-programmerzai-du/">&lt;p&gt;这是一本讲述程序员开发哲学和思想的书，虽然出版了十余年仍然没有太多过时的东西，因为讲述的内容是一些永远不会过时的东西（至少从计算机程序设计职业化-即所谓的软件工程开启的时间算便是如此）。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;再读机缘&quot;&gt;再读机缘&lt;/h2&gt;

&lt;p&gt;初次接触到这本大作是在2008年初；当时刚刚开阔自己封闭的眼界，读到很多人的推荐都将此书列为必读的经典，于是兴冲冲的去图书馆借了过来读。草草读完心中大为触动，什么是优秀的程序员，为什么顶尖的程序员和初级程序员的生产效率相差数倍乃至更多，这本书给出了深刻的答案；虽然没有具体的技术，但是一个条目一个条目的建议和提示，辅以思考分析，当时便暗下决心要照着其中的条例去做，做到自己的极致。加上当时另外一本奇书 «Unix 编程艺术» 也进入了我的视野，使我彻底陷入了Unix的程序世界；两本书中的相似的哲学观点深刻的整塑着我的编程价值观。&lt;/p&gt;

&lt;p&gt;一晃然又是五年过去了；当时的菜鸟已经慢慢成长为一个老油条；这期间总是努力迫使自己向着其中的条目去努力和进步；但是感觉上却没有太多新的东西让自己觉得太震撼了,至少是具体到编程技术上的，也许是我自己已经将这本书的原则实践的很不错了？&lt;/p&gt;

&lt;p&gt;刚好前几天又到图书馆借书，没有找到满意的图书，却于不经意见看到了 «编程原本»和这本书，于是便背了回来，权当一次重新检视自己的标杆吧。&lt;/p&gt;

&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;

&lt;p&gt;重新翻了一遍，当初的震撼感几乎消失殆尽了，因为书里边讲述的很多信条已经在我的大脑中成为编程习惯的一部分了，只是某些方面还没有尽力将其发挥的更远 - 也许这就是开始基础不高的时候进步总是很容易的，一旦达到一定的高度再想更进一步就难上加难了。&lt;/p&gt;

&lt;p&gt;这里再挑几点最深的感悟：&lt;/p&gt;

&lt;h3 id=&quot;dry-原则&quot;&gt;DRY 原则&lt;/h3&gt;

&lt;p&gt;这个原则是如此的深入人心，以至于很多设计模式和讲述重构的书都会反反复复的阐释，并且提出各自的实践。不重复自己，意味着如果某些事情中有很多重复，并且是人工维护的，就很容易出错并慢慢变得越来越难以维护。久而久之代码就会慢慢失去活力，腐败并产生Smelly,可以说这一原则是其它所有重要的原则的基础。尽量避免重复，就自然的避免拷贝/粘帖，逼迫自己用无重复的方式去改进实现，优雅的设计自然就慢慢演变出来。没有一个优秀的设计是充满重复的。如果有，那么也是计算机来重复执行，譬如写一个生成器一样的东西。&lt;/p&gt;

&lt;h3 id=&quot;自动化手工操作&quot;&gt;自动化手工操作&lt;/h3&gt;

&lt;p&gt;这个其实是更深层次的DRY应用 - 如果发现总是重复的跑一些命令或者操作一些步骤，那么就尽量的将其自动化。自己写脚本也好，寻找更有些的工具也好，一旦将其自动化，这些繁琐的东西就不会再浪费你太多的精力，这样你就可以花更少的时间来做更多的工作；将浪费的时间用来做重要的事情，自然效率大大增加。寻找自动化工具的努力什么时候都不会太浪费。手工的操作速度再快，绝大部分情况也赶不上计算机那么准确和快速。&lt;/p&gt;

&lt;h3 id=&quot;命令行工具&quot;&gt;命令行工具&lt;/h3&gt;

&lt;p&gt;Bash的威力是巨大的，当然只有比较深度的Linux用户才能理解的更透彻。各种丰富的小工具和基于管道的组合可以产生巨大的威力，即使面临更先进的python/ruby这些新潮语言的挑战，很多时候原始的grep/awk/sed组合也有超强的优势 - 尤其当效率是个重要因素的时候。根源嘛，这些程序可是用纯C写的，而且诞生于资源紧张的年代，每一片代码都经过经心的调整以保证最佳效率。我们现在已经不这么写应用程序了，但是这些已有的强大的小工具，用好还是可以令人效率急速飙升的。&lt;/p&gt;

&lt;h3 id=&quot;学习多种编程语言&quot;&gt;学习多种编程语言&lt;/h3&gt;

&lt;p&gt;编程语言是程序员思考的工具，遗憾的是每种编程语言都有很多的边界。这些边界也在潜意识中阻碍了程序员的视野，使得很多时候难以发现最合适的方案和最优雅的做法。打破这一障碍的方法就是经常学习新的编程语言，尤其是思路不同的程序语言，对你的世界观影响更大。每个优秀的程序员，个人认为至少应该掌握几种编程范式的语言中的一种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;过程式&lt;/li&gt;
  &lt;li&gt;面向对象&lt;/li&gt;
  &lt;li&gt;声明式&lt;/li&gt;
  &lt;li&gt;函数式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然更新的语言往往集成了更多的语言特性；而且在运用前边的原则的时候，有时候为了拿到顺手的工具就不可避免要学习新的编程语言。有实际需求驱动的语言学习往往能取得更好的效果，比如之前我为了做个效率更高的日志分析统计工具，专门花了一段时间学习gawk的手册，写了几百行代码之后，这些经验就在我的脑子中累计屏在日后发挥了很多的作用。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><summary type="html">这是一本讲述程序员开发哲学和思想的书，虽然出版了十余年仍然没有太多过时的东西，因为讲述的内容是一些永远不会过时的东西（至少从计算机程序设计职业化-即所谓的软件工程开启的时间算便是如此）。</summary></entry></feed>