<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://skyscribe.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://skyscribe.github.io/" rel="alternate" type="text/html" /><updated>2019-12-09T11:03:34+08:00</updated><id>https://skyscribe.github.io/feed.xml</id><title type="html">驭风万里无垠</title><subtitle>汇小流以成江海，积跬步以至千里</subtitle><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><entry><title type="html">Rust语言的异步编程模型和协程支持</title><link href="https://skyscribe.github.io/post/2019/12/07/rust-asynchronous-model-and-features/" rel="alternate" type="text/html" title="Rust语言的异步编程模型和协程支持" /><published>2019-12-07T00:00:00+08:00</published><updated>2019-12-07T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/12/07/rust-asynchronous-model-and-features</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/12/07/rust-asynchronous-model-and-features/">&lt;p&gt;通用的注重性能的现代编程语言都在慢慢地加入对异步编程和协程模型的支持，作为一门强调性能和零成本抽象的语言，Rust自然也不甘落人之后。&lt;/p&gt;

&lt;p&gt;可能是因为Rust语言社区出于对自身特殊的&lt;strong&gt;生存周期管理机制&lt;/strong&gt;多带来的&lt;strong&gt;其它语言所有没有的额外的编译器实现复杂性&lt;/strong&gt;，以及开放语言生态系统中的功能开发优先级（它迄今为止还在快速演进中）考虑，在去年年底发布的2018版本中，协程的支持并[没有完工]
(//post/2019/01/19/rust-2018-edition-overview/)
而是仅仅留下了一个预留关键字，有点“强制占位”的味道。&lt;/p&gt;

&lt;p&gt;换个角度看，也可以认为Rust社区对&lt;strong&gt;尽快支持基于async/await风格的协程&lt;/strong&gt;还是非常重视的。
果不其然，经过快一年的打磨，这些复杂的特性随着最新&lt;strong&gt;稳定版本的发布&lt;/strong&gt;而正式进入了一般程序员的视野（之前的支持放在Nightly发布频道里面给早期吃螃蟹的用户尝鲜）。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;协程和它之前的历史背景&quot;&gt;协程和它之前的历史背景&lt;/h2&gt;
&lt;p&gt;协程并不是一个怎么新鲜的编程概念，起码在上个世纪９０年代或者更早的编程语言大发展的时候已经出现在某些语言中；只是因为当时最主流的C++和Java（还没有今天这么流行）的语言并不在语言层面提供对协程的支持而不被主流程序员所熟知。&lt;/p&gt;

&lt;h3 id=&quot;多线程编程的挑战&quot;&gt;多线程编程的挑战&lt;/h3&gt;
&lt;p&gt;那个时代主流的模型还是基于操作系统提供的线程的概念来实现并发编程；典型的如Apache服务器引入的一个连接一个线程的概念：每次有一个新的用户连接请求进来，服务器就会为其创建一个线程；这样可以做到多个线程之间互相不干扰。&lt;/p&gt;

&lt;p&gt;这样的处理机制非常简单优雅，可惜在连接数目渐渐增多的时候，可扩展性很差，因为&lt;strong&gt;操作系统本身并不擅长处理大量的线程&lt;/strong&gt;：任何一个线程的创建都需要设计到栈空间的分配、线程私有资源的创建和维护；同时大量的线程在操作系统层面被调度的时候，也很难保证调度策略的公平和有效。&lt;/p&gt;

&lt;p&gt;曾经一度引发热烈讨论的C10K问题就是针对这一模型的不足：超过一定数量的连接之后，操作系统甚至将&lt;strong&gt;大量的CPU处理资源浪费在线程之间的切换和控制&lt;/strong&gt;，而不能很好地处理用户层的实际应用需求。
标准的POSIX socket调用的多路处理函数&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;在传入的socket句柄数量超过一定数量之后也会&lt;strong&gt;耗费大量的CPU运算资源于内核态&lt;/strong&gt;，而用户层程序则束手无策。&lt;/p&gt;

&lt;p&gt;显然将用户层面的并发问题直接抛给操作系统并不是一个非常明智的选择；随着应用领域的需求对并发性的要求愈加严苛，这些问题需要找到更好的解决方案。&lt;/p&gt;

&lt;h4 id=&quot;操作系统层面的探索&quot;&gt;操作系统层面的探索&lt;/h4&gt;
&lt;p&gt;以Unix和Linux为主流的非Windows系统自身是从解决并发连接的角度来考虑的，它们通过在内核层面的IO多路复用角度触发，通过引入epoll/kqueue等技术来允许一个单一的用户线程的IO调用可以管理海量的网络连接而完美地解决了传统的&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;调用层面的问题。当然Windows自己也提供了类似的IOCP的概念实现类似的高性能IO多路复用方案。&lt;/p&gt;

&lt;p&gt;这方面的探索解决了一个线程处理海量网络IO的系统资源过耗问题，但是这些改进对&lt;strong&gt;和网络无关的本地的耗费CPU的任务的并发&lt;/strong&gt;挑战并没有多少帮助。
同时这些IO方面的处理暗含了用户必须书写异步代码的挑战：对于可能阻塞的IO调用，用户必须通过回调函数的方式将原来简单、直接的顺序代码改写为支离破碎的异步代码。
只需要看看boost.asio库的实例代码，就会明白这样的编程方式如何可耻地损伤了代码的可读性，显然代码的可维护性也很糟糕。&lt;/p&gt;

&lt;h5 id=&quot;优化内核线程处理的尝试&quot;&gt;优化内核线程处理的尝试&lt;/h5&gt;
&lt;p&gt;这方面的尝试应该以Solaris的线程模型最为典型：对应的pthread接口低下的实现虽然也映射到了操作系统的内核线程，但是这些用户层面的线程和操作系统线程的&lt;strong&gt;对应关系不是1:1而是M:N&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;只是这个配置的&lt;strong&gt;灵活度并不是太高&lt;/strong&gt;，其性能表现还是令人刮目相看的，用户可以轻松地创建上万个线程而内核还可以很高效的使用CPU资源来调度用户的处理。&lt;/p&gt;

&lt;p&gt;当然因为一些非技术上的原因，Solaris的这些创举并&lt;strong&gt;没有在它自身意外的领域发扬光大&lt;/strong&gt;，而是随着Sun公司的垮台和被收购，Solaris系统最终停止开发而烟消云散了。
主流的Linux系统和其它Unix变种依然在采用一一对应的线程模型。&lt;/p&gt;

&lt;h4 id=&quot;用户态线程&quot;&gt;用户态”线程”&lt;/h4&gt;
&lt;p&gt;另外一个有趣的探索方向是用户态线程的概念，或者成为Green Thread，它的基本思路是将&lt;strong&gt;逻辑线程的管理逻辑都放在操作系统的用户态来管理，而操作系统层面对这些机制一无所知&lt;/strong&gt;。
运行在用户态的线程管理程序（往往是比较底层的基础库或者组件）自己负责这些线程状态的管理和调度。&lt;/p&gt;

&lt;p&gt;这方面比较典型的例子是早期的Python所支持的线程模型，和来自爱立信的Erlang语言底层平台OTP；甚至于有一段实际Java语言的线程库也采用过Green Thread（尽管现在已经不再使用）。
Python的Green Thread实现一度由于它自身历史承袭的GIL锁的性能噩梦而终被弃之高阁了。&lt;/p&gt;

&lt;h3 id=&quot;异步编程的心智负担&quot;&gt;异步编程的心智负担&lt;/h3&gt;
&lt;p&gt;随着上面所说的各种尝试逐渐式微，主流的编程语言不得不回到多线程编程的路上继续探索，这一次随着进入新世纪依赖多核CPU的日渐流行，各种编程语言都&lt;strong&gt;不得不寻求其它办法来简化程序员的心智负担&lt;/strong&gt;，因为编写没有问题的多线程、异步程序实在不是一个轻松的差事。&lt;/p&gt;

&lt;p&gt;一方面不管是程序员还是底层的编译器乃至CPU硬件都更加适应一步接一步走下去的顺序执行的逻辑，已有的底层编译器可以对顺序执行程序做深入的分析和优化，处理器可以对指令流水线做高效的预测和预判执行；另一方面程序员却不得不面对顺序代码的效率不高的现实：不管是读取磁盘上的文件，还是从网络上下载内容，碰到这些情况的时候，要想高效地利用CPU，在不创建更多底层线程的情况下，程序员不得不将&lt;strong&gt;顺序执行的代码切割为多个部分&lt;/strong&gt;，然后在阻塞的地方加入一个回调：当阻塞的外部条件满足的时候，由操作系统回调回来执行后面的部分。&lt;/p&gt;

&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;
&lt;p&gt;协程的引入其实就是为了缓解这一艰巨的挑战：它通过&lt;strong&gt;引入一个逻辑上抽象的概念来简化编程&lt;/strong&gt;模型。某种程度上说，可以将一个协程看作是一段可以以非阻塞的方式高效执行的代码；
而多个协程之间可以通过特定关键字或者语句的方式进行组合，以便程序员可以直接写出&lt;strong&gt;看起来是同步执行而实际上底层却是被异步调度执行&lt;/strong&gt;的代码。&lt;/p&gt;

&lt;h4 id=&quot;future&quot;&gt;Future&lt;/h4&gt;
&lt;p&gt;不同的编程语言和环境对于协程的具体实现可以是大相径庭的，只是大多编程语言多通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Future/Promise&lt;/code&gt;这样的机制来实现。
一个Future代表一个现在&lt;strong&gt;可能还没有结果&lt;/strong&gt;（或者在等待IO完毕或者还没有被调度到CPU上去实际执行），但是&lt;strong&gt;将来会返回某个结果&lt;/strong&gt;的抽象过程。将来会返回的结果抽象为&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;，即承诺一定会返回的某个东西。这两个概念如果存在，一定是成对存在的。&lt;/p&gt;

&lt;h4 id=&quot;executor&quot;&gt;Executor&lt;/h4&gt;
&lt;p&gt;异步的Future最后必然要被底层的调度程序来驱动和执行，这个负责执行用户定义的抽象的Future的实体成为Executor，它底层的执行体可以是按需创建的线程池，也可以是共享固定大小的线程池甚至于单个线程等。
最好的Executor抽象应该是从JDK5开始流行开来的，目前已经成为一个跨编程语言的抽象。&lt;/p&gt;

&lt;h4 id=&quot;asyncawait&quot;&gt;async/await&lt;/h4&gt;
&lt;p&gt;对协程的组合和等待则通过&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;这样的关键字来标识。&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;用于标记某个可以返回Future的语句或者调用，&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;用来异步的等待某个Future的执行结果，即&lt;strong&gt;await的逻辑看起来同步的，但是其实依赖于底层协程的调度结果，即实际执行完毕之后才能得到&lt;/strong&gt;结果。
如果有后续的逻辑处理依赖于await的结果，那么它们将被自动调度为顺序执行。&lt;/p&gt;

&lt;h2 id=&quot;rust的future&quot;&gt;Rust的&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Future本身是一个抽象的概念，对应的Rust语言里面的动态抽象机制是Trait，因此毫不意外地看到，Rust语言定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;就是一个Trait。&lt;/p&gt;

&lt;p&gt;逻辑上来说，Rust的&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;可以简单的被认为是定义为如下的形式&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Warning: this is not the offical definition&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该Trait的核心是定义了一个&lt;strong&gt;输出的类型&lt;/strong&gt;，即实际执行结束之后的结果返回类型，以及一个相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt;函数。
顾名思义这是一个底层的协程Executor提供的”轮询”执行结果的函数，返回的结果是操作是否完毕，它是一个枚举类型&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rust自身的&lt;strong&gt;类型安全机制很好地封装&lt;/strong&gt;了其它语言中不得不需要的Promise:这里我们不需要专门的Promise类型，仅仅根据枚举值来做模式匹配即可。&lt;/p&gt;

&lt;p&gt;用户程序可以主动调用这个轮询函数，驱动底层的Executor来执行一次调用，然后检查实际结果；
只是绝大部分情况下，这并不是最佳的使用方式：因为这一的执行方式和协程底层封装的思路想违背了。大部分情况下，&lt;strong&gt;用户需要的是关注多个协程之间的互相组合&lt;/strong&gt;，确定它们之间的逻辑依赖关系即可，Executor的驱动甚至可以是自动封装驱动的。&lt;/p&gt;

&lt;h3 id=&quot;wake函数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wake&lt;/code&gt;函数&lt;/h3&gt;
&lt;p&gt;如果没有这个函数，Executor在需要多次驱动用户提供的Future来持续运行的时候，将没有办法知道如何继续下去。
这个函数的作用&lt;strong&gt;就是一个唤醒回调&lt;/strong&gt;，在Future被实际执行的时候，如果一次没有执行完毕，那么下次被调用的时候，可以从上次中断的地方继续执行下去。&lt;/p&gt;

&lt;h3 id=&quot;socket的例子&quot;&gt;Socket的例子&lt;/h3&gt;
&lt;p&gt;假设我们有一个从Socket读取数据的Future，它在有数据的时候，直接返回读取到的数据，没有数据的时候，则留待下次调度的时候继续执行；它可以被实现为&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SocketRead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SocketRead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.has_data_to_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.read_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set_readable_callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;实现join的例子&quot;&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Join&lt;/code&gt;的例子&lt;/h3&gt;
&lt;p&gt;这种实现方式允许我们自由地组合多个Future而&lt;strong&gt;不需要额外的中间内存分配&lt;/strong&gt;，从而兼得抽象的好处而不损失一毫性能，比如我们需要组合两个Future而让它们可以并发执行的时候，可以用如下的实现：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.a&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.b&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.a&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.b&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个轮询的过程非常简单直接，分别轮询传入的两个Future，并且在两个都完成的时候，返回结果。否则返回Pending以便后续的调度继续执行。&lt;/p&gt;

&lt;h3 id=&quot;实现andthen&quot;&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;AndThen&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;另外一种场景的协程操作是实现穿行逻辑，即第一个future结束后才执行第二个。类似于上面的定义，我们先定义这种顺序组合的Future如下：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AndThenFut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的实现则为&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AndThenFut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;FutureA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;FutureB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.first&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.first&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.second&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里我们简化了处理逻辑，仅当第一个FutureA完毕的时候，才会轮询第二个Future，如果第一个Future没有完毕，则继续等待下一次的查询调度。&lt;/p&gt;

&lt;h3 id=&quot;真正的future定义&quot;&gt;真正的&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;定义&lt;/h3&gt;
&lt;p&gt;上述的逻辑定义其实是一种简化模型，而真正的标准库中的Future定义其实如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最显著的不同在于函数的两个参数类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;类型被定义为&lt;code class=&quot;highlighter-rouge&quot;&gt;Pin&lt;/code&gt;的分装，这个封装简单的来说，就是允许我们&lt;strong&gt;创建不可移动的Future类型&lt;/strong&gt;；所谓的不可移动对象，是指对象里面可以出现某个字段的指针指向对象的其它字段的情况；这对于实现&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;是至关重要的。&lt;/li&gt;
  &lt;li&gt;第二个参数用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Context&lt;/code&gt;对象替换了简单的&lt;code class=&quot;highlighter-rouge&quot;&gt;wake&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们之所以需要一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Context&lt;/code&gt;对象，是因为我们需要在其中存储哪一个Future对象被轮询执行了；这在复杂的多线程程序中是不可或缺的。&lt;/p&gt;

&lt;h4 id=&quot;context对象和waker类型&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Context&lt;/code&gt;对象和&lt;code class=&quot;highlighter-rouge&quot;&gt;Waker&lt;/code&gt;类型&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Context&lt;/code&gt;的定义如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhantomData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它里面仅仅是封装了一个额外的&lt;code class=&quot;highlighter-rouge&quot;&gt;Waker&lt;/code&gt;对象，以便用户定义的Future和底层的Executor进行通信，通知对方&lt;strong&gt;自身已经准备好了&lt;/strong&gt;下一步对应的结果就可以返回给外部，其本身提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;操作，并且可以可以在多线程环境中移动和共享，因为它标记自己实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Sync&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Send&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RawWaker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unpin&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Send&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sync&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中嵌套的内部实现里面封装了一个满足具体的Executor要求的、可以&lt;strong&gt;包含任意上下文数据&lt;/strong&gt;的指针&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;，它的注释很好地阐述了数据的用途：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;derive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PartialEq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RawWaker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// A data pointer, which can be used to store arbitrary data as required&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// by the executor. This could be e.g. a type-erased pointer to an `Arc`&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// that is associated with the task.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// The value of this field gets passed to all functions that are part of&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// the vtable as the first parameter.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/// Virtual function pointer table that customizes the behavior of this waker.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vtable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RawWakerVTable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Waker&lt;/code&gt;自身提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;wake()&lt;/code&gt;函数，和上面简化的例子类似&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.waker.vtable.wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.waker.data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;crate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一个定时器实现的例子&quot;&gt;一个定时器实现的例子&lt;/h4&gt;
&lt;p&gt;假设我们需要实现一个经过给定时间段后过期的名为&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerFuture&lt;/code&gt;的future对象，我们需要一个上下文数据标识timer是否已经完成，并且出于简化起见，当Timer被创建的时候，我们启动一个线程来在创建的线程中将其激活，因此我们需要一个跨线程共享的上下文。&lt;/p&gt;

&lt;h5 id=&quot;类型定义&quot;&gt;类型定义&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Arc&lt;/code&gt;类型是用来封装上下文状态的最简单的封装类&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerFuture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SharedState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SharedState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;completed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;new函数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数&lt;/h5&gt;
&lt;p&gt;接下来是它的实现和&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerFuture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SharedState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;completed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为需要创建一个线程来异步地标记Timer到期完毕，我们需要将该共享状态拷贝并移动到lambda对应的线程中去：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state_clone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nn&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state_clone&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.completed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当时间到期后，我们除了标记该共享状态的标志外，还需要在Future的使用方没有完成的情况下，&lt;strong&gt;主动唤醒&lt;/strong&gt;底层的调度，此时就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;wake()&lt;/code&gt;函数了&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.waker&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.wake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;TimerFuture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;future实现&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;实现&lt;/h5&gt;
&lt;p&gt;该TimerFuture的trait实现其实就是对共享状态查询的封装；如果已经完毕，就返回Ready,否则就返回Pending。&lt;/p&gt;

&lt;p&gt;这里有个非常细微的问题需要注意：因为waker对象可能随着Executor在&lt;strong&gt;线程之间的移动而被拷贝为其它的值&lt;/strong&gt;，为了避免对象自身保存的&lt;code class=&quot;highlighter-rouge&quot;&gt;waker&lt;/code&gt;对象指向了非法的上下文，我们需要在返回pending之前重新拷贝一次自身保存的&lt;code class=&quot;highlighter-rouge&quot;&gt;waker&lt;/code&gt;!&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimerFuture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.shared_state&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.completed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;shared_state&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.waker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rust的await和async&quot;&gt;Rust的&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这次加入1.36稳定版的功能体验在语言层面的两个关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;async&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;用于声明一个代码块为返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;，通过在某个普通的函数声明前面加上&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;，Rust可以自动完成返回类型到&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;类型的封装和转换，如下面的代码&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//some heavy operation&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;的返回值会是一个Future.&lt;/p&gt;

&lt;p&gt;Rust本身的Executor库也提供了阻塞执行的方法，允许我们在当前的调用线程里面阻塞执行直到封装的异步执行块允许完毕，即如下的代码&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;block_on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// proceeds until wrapped something is executed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;await&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;语句可以作用在Future上，用于非阻塞方式的同步逻辑，即异步地等待作用的Future对象的完成，然后读取返回的结果，考虑如下的三个异步的Future执行块，前两个有先后依赖而第三个可以同时进行：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;learn_song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Song&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//dom something&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Song&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sing_song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//sing the song&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//dance&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以用如下的逻辑来表述上面的并发执行行为&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;learn_and_sing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;song&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;learn_song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;sing_song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;learn_and_sing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;futures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;标准库中的future和futures-crate&quot;&gt;标准库中的Future和&lt;code class=&quot;highlighter-rouge&quot;&gt;futures&lt;/code&gt; crate&lt;/h3&gt;
&lt;p&gt;目前有两个Future库同时存在，一个是标准库中的&lt;code class=&quot;highlighter-rouge&quot;&gt;std::future::Future&lt;/code&gt;，另外一个则是&lt;code class=&quot;highlighter-rouge&quot;&gt;futures&lt;/code&gt;中定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;futures::future::Future&lt;/code&gt;。这一重复定义多少让人感到困惑不解：其实这主要是由于&lt;strong&gt;Future特性正在被开发中还不算足够完善&lt;/strong&gt;的缘故。&lt;/p&gt;

&lt;p&gt;早期的实现是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;future-rs&lt;/code&gt;扩展库的方式提供的，最近的版本才将它加到了标准库中；甚至于实现也是移过去的；可以认为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::future::Future&lt;/code&gt;实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;future-rs&lt;/code&gt;里面的一个最小集。后续的功能演进也可能仍然采用类似的策略&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标准库中的Future进来保持最小的接口&lt;/li&gt;
  &lt;li&gt;更复杂的组合功能将会用类似&lt;code class=&quot;highlighter-rouge&quot;&gt;future&lt;/code&gt;库的方式来提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;futureext&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FutureExt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;之上的一个扩展的Trait，可以实现很多方便的转换，包括&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;将包含的输出值经过一个函数处理变换为另外一种输出&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;实现两个Feature的链式操作，并且将前一个的输出传递为第二个闭包函数的输入，例如
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;move&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;assert_eq!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;left_future&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;right_future&lt;/code&gt;实现根据不同的条件返回不同部分的EitherFuture功能，如
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.left_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.right_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;into_stream&lt;/code&gt;将future转换为包含单个元素的stream，这个stream的输出是future本身，支持方便的stream操作，如
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatten&lt;/code&gt;用于实现一次解封操作，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;f.then(|x| x)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inspect&lt;/code&gt;实现一个future传递之前的额外查看和处理，最简单的例子是打印计算的结果，如
    &lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.inspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;will resolve as {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//nf = 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="rust" /><category term="engineering" /><category term="performance" /><category term="multi-threading" /><category term="async" /><category term="future" /><summary type="html">通用的注重性能的现代编程语言都在慢慢地加入对异步编程和协程模型的支持，作为一门强调性能和零成本抽象的语言，Rust自然也不甘落人之后。 可能是因为Rust语言社区出于对自身特殊的生存周期管理机制多带来的其它语言所有没有的额外的编译器实现复杂性，以及开放语言生态系统中的功能开发优先级（它迄今为止还在快速演进中）考虑，在去年年底发布的2018版本中，协程的支持并[没有完工] (//post/2019/01/19/rust-2018-edition-overview/) 而是仅仅留下了一个预留关键字，有点“强制占位”的味道。 换个角度看，也可以认为Rust社区对尽快支持基于async/await风格的协程还是非常重视的。 果不其然，经过快一年的打磨，这些复杂的特性随着最新稳定版本的发布而正式进入了一般程序员的视野（之前的支持放在Nightly发布频道里面给早期吃螃蟹的用户尝鲜）。 协程和它之前的历史背景 协程并不是一个怎么新鲜的编程概念，起码在上个世纪９０年代或者更早的编程语言大发展的时候已经出现在某些语言中；只是因为当时最主流的C++和Java（还没有今天这么流行）的语言并不在语言层面提供对协程的支持而不被主流程序员所熟知。 多线程编程的挑战 那个时代主流的模型还是基于操作系统提供的线程的概念来实现并发编程；典型的如Apache服务器引入的一个连接一个线程的概念：每次有一个新的用户连接请求进来，服务器就会为其创建一个线程；这样可以做到多个线程之间互相不干扰。 这样的处理机制非常简单优雅，可惜在连接数目渐渐增多的时候，可扩展性很差，因为操作系统本身并不擅长处理大量的线程：任何一个线程的创建都需要设计到栈空间的分配、线程私有资源的创建和维护；同时大量的线程在操作系统层面被调度的时候，也很难保证调度策略的公平和有效。 曾经一度引发热烈讨论的C10K问题就是针对这一模型的不足：超过一定数量的连接之后，操作系统甚至将大量的CPU处理资源浪费在线程之间的切换和控制，而不能很好地处理用户层的实际应用需求。 标准的POSIX socket调用的多路处理函数select在传入的socket句柄数量超过一定数量之后也会耗费大量的CPU运算资源于内核态，而用户层程序则束手无策。 显然将用户层面的并发问题直接抛给操作系统并不是一个非常明智的选择；随着应用领域的需求对并发性的要求愈加严苛，这些问题需要找到更好的解决方案。 操作系统层面的探索 以Unix和Linux为主流的非Windows系统自身是从解决并发连接的角度来考虑的，它们通过在内核层面的IO多路复用角度触发，通过引入epoll/kqueue等技术来允许一个单一的用户线程的IO调用可以管理海量的网络连接而完美地解决了传统的select调用层面的问题。当然Windows自己也提供了类似的IOCP的概念实现类似的高性能IO多路复用方案。 这方面的探索解决了一个线程处理海量网络IO的系统资源过耗问题，但是这些改进对和网络无关的本地的耗费CPU的任务的并发挑战并没有多少帮助。 同时这些IO方面的处理暗含了用户必须书写异步代码的挑战：对于可能阻塞的IO调用，用户必须通过回调函数的方式将原来简单、直接的顺序代码改写为支离破碎的异步代码。 只需要看看boost.asio库的实例代码，就会明白这样的编程方式如何可耻地损伤了代码的可读性，显然代码的可维护性也很糟糕。 优化内核线程处理的尝试 这方面的尝试应该以Solaris的线程模型最为典型：对应的pthread接口低下的实现虽然也映射到了操作系统的内核线程，但是这些用户层面的线程和操作系统线程的对应关系不是1:1而是M:N的。 只是这个配置的灵活度并不是太高，其性能表现还是令人刮目相看的，用户可以轻松地创建上万个线程而内核还可以很高效的使用CPU资源来调度用户的处理。 当然因为一些非技术上的原因，Solaris的这些创举并没有在它自身意外的领域发扬光大，而是随着Sun公司的垮台和被收购，Solaris系统最终停止开发而烟消云散了。 主流的Linux系统和其它Unix变种依然在采用一一对应的线程模型。 用户态”线程” 另外一个有趣的探索方向是用户态线程的概念，或者成为Green Thread，它的基本思路是将逻辑线程的管理逻辑都放在操作系统的用户态来管理，而操作系统层面对这些机制一无所知。 运行在用户态的线程管理程序（往往是比较底层的基础库或者组件）自己负责这些线程状态的管理和调度。 这方面比较典型的例子是早期的Python所支持的线程模型，和来自爱立信的Erlang语言底层平台OTP；甚至于有一段实际Java语言的线程库也采用过Green Thread（尽管现在已经不再使用）。 Python的Green Thread实现一度由于它自身历史承袭的GIL锁的性能噩梦而终被弃之高阁了。 异步编程的心智负担 随着上面所说的各种尝试逐渐式微，主流的编程语言不得不回到多线程编程的路上继续探索，这一次随着进入新世纪依赖多核CPU的日渐流行，各种编程语言都不得不寻求其它办法来简化程序员的心智负担，因为编写没有问题的多线程、异步程序实在不是一个轻松的差事。 一方面不管是程序员还是底层的编译器乃至CPU硬件都更加适应一步接一步走下去的顺序执行的逻辑，已有的底层编译器可以对顺序执行程序做深入的分析和优化，处理器可以对指令流水线做高效的预测和预判执行；另一方面程序员却不得不面对顺序代码的效率不高的现实：不管是读取磁盘上的文件，还是从网络上下载内容，碰到这些情况的时候，要想高效地利用CPU，在不创建更多底层线程的情况下，程序员不得不将顺序执行的代码切割为多个部分，然后在阻塞的地方加入一个回调：当阻塞的外部条件满足的时候，由操作系统回调回来执行后面的部分。 协程 协程的引入其实就是为了缓解这一艰巨的挑战：它通过引入一个逻辑上抽象的概念来简化编程模型。某种程度上说，可以将一个协程看作是一段可以以非阻塞的方式高效执行的代码； 而多个协程之间可以通过特定关键字或者语句的方式进行组合，以便程序员可以直接写出看起来是同步执行而实际上底层却是被异步调度执行的代码。 Future 不同的编程语言和环境对于协程的具体实现可以是大相径庭的，只是大多编程语言多通过Future/Promise这样的机制来实现。 一个Future代表一个现在可能还没有结果（或者在等待IO完毕或者还没有被调度到CPU上去实际执行），但是将来会返回某个结果的抽象过程。将来会返回的结果抽象为Promise，即承诺一定会返回的某个东西。这两个概念如果存在，一定是成对存在的。 Executor 异步的Future最后必然要被底层的调度程序来驱动和执行，这个负责执行用户定义的抽象的Future的实体成为Executor，它底层的执行体可以是按需创建的线程池，也可以是共享固定大小的线程池甚至于单个线程等。 最好的Executor抽象应该是从JDK5开始流行开来的，目前已经成为一个跨编程语言的抽象。 async/await 对协程的组合和等待则通过async/await这样的关键字来标识。async用于标记某个可以返回Future的语句或者调用，await用来异步的等待某个Future的执行结果，即await的逻辑看起来同步的，但是其实依赖于底层协程的调度结果，即实际执行完毕之后才能得到结果。 如果有后续的逻辑处理依赖于await的结果，那么它们将被自动调度为顺序执行。 Rust的Future Future本身是一个抽象的概念，对应的Rust语言里面的动态抽象机制是Trait，因此毫不意外地看到，Rust语言定义的Future就是一个Trait。 逻辑上来说，Rust的Future可以简单的被认为是定义为如下的形式 // Warning: this is not the offical definition trait Future { type Output; fn poll(&amp;amp;mut self, wake: fn()) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;; } 该Trait的核心是定义了一个输出的类型，即实际执行结束之后的结果返回类型，以及一个相关的poll函数。 顾名思义这是一个底层的协程Executor提供的”轮询”执行结果的函数，返回的结果是操作是否完毕，它是一个枚举类型 enum Poll&amp;lt;T&amp;gt; { Ready&amp;lt;T&amp;gt;, Pending, } Rust自身的类型安全机制很好地封装了其它语言中不得不需要的Promise:这里我们不需要专门的Promise类型，仅仅根据枚举值来做模式匹配即可。 用户程序可以主动调用这个轮询函数，驱动底层的Executor来执行一次调用，然后检查实际结果； 只是绝大部分情况下，这并不是最佳的使用方式：因为这一的执行方式和协程底层封装的思路想违背了。大部分情况下，用户需要的是关注多个协程之间的互相组合，确定它们之间的逻辑依赖关系即可，Executor的驱动甚至可以是自动封装驱动的。 wake函数 如果没有这个函数，Executor在需要多次驱动用户提供的Future来持续运行的时候，将没有办法知道如何继续下去。 这个函数的作用就是一个唤醒回调，在Future被实际执行的时候，如果一次没有执行完毕，那么下次被调用的时候，可以从上次中断的地方继续执行下去。 Socket的例子 假设我们有一个从Socket读取数据的Future，它在有数据的时候，直接返回读取到的数据，没有数据的时候，则留待下次调度的时候继续执行；它可以被实现为 pub struct SocketRead&amp;lt;'a&amp;gt; { socket: &amp;amp;'a Socket, } impl Future for SocketRead &amp;lt;'_&amp;gt; { type Output = Vec&amp;lt;u8&amp;gt;; fn poll(&amp;amp;mut self, wake: fn()) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { if self.socket.has_data_to_read() { Poll::Ready(self.socket.read_buf()) } else { self.socket.set_readable_callback(wake) Poll::Pending } } } 实现Join的例子 这种实现方式允许我们自由地组合多个Future而不需要额外的中间内存分配，从而兼得抽象的好处而不损失一毫性能，比如我们需要组合两个Future而让它们可以并发执行的时候，可以用如下的实现： pub struct Join&amp;lt;FutureA, FutureB&amp;gt; { a: Option&amp;lt;FutureA&amp;gt;, b: Option&amp;lt;FutureB&amp;gt;, } impl &amp;lt;FutureA, FutureB&amp;gt; Future for Join&amp;lt;FutureA, FutureB&amp;gt; where FutureA: Future&amp;lt;Output=()&amp;gt;, FutureB: Future&amp;lt;Output=()&amp;gt;, { type Output = (); fn poll(&amp;amp;mut self, wake: fn()) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { if let Some(a) = &amp;amp;mut self.a { if let Poll::Ready(()) = a.poll(wake) { self.a.take() } } if let Some(b) = &amp;amp;mut self.b { if let Poll::Ready(()) = b.poll(wake) { self.b.take() } } if self.a.is_none() &amp;amp;&amp;amp; self.b.is_none() { Poll::Ready(()) } else { Poll::Pending } } } 这个轮询的过程非常简单直接，分别轮询传入的两个Future，并且在两个都完成的时候，返回结果。否则返回Pending以便后续的调度继续执行。 实现AndThen 另外一种场景的协程操作是实现穿行逻辑，即第一个future结束后才执行第二个。类似于上面的定义，我们先定义这种顺序组合的Future如下： pub struct AndThenFut&amp;lt;FutureA, FutureB&amp;gt; { first: Option&amp;lt;FutureA&amp;gt;, second: FutureB, } 它的实现则为 impl &amp;lt;FutureA, FutureB&amp;gt; Future for AndThenFut&amp;lt;FutureA, FutureB&amp;gt; where FutureA: Future&amp;lt;Output=()&amp;gt;, FutureB: Future&amp;lt;Output=()&amp;gt;, { type Output = (); fn poll(&amp;amp;mut self, wake: fn()) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { if let Some(first) = &amp;amp;mut self.first { match first.poll(wake) { Poll:Ready(()) =&amp;gt; self.first.take(), Poll::Pending =&amp;gt; return Poll::Pending, } } self.second.poll(wake) } } 这里我们简化了处理逻辑，仅当第一个FutureA完毕的时候，才会轮询第二个Future，如果第一个Future没有完毕，则继续等待下一次的查询调度。 真正的Future定义 上述的逻辑定义其实是一种简化模型，而真正的标准库中的Future定义其实如下 trait Future { type Output; fn poll(self: Pin&amp;lt;&amp;amp;mut self&amp;gt;, ctx: &amp;amp;mut Context&amp;lt;'_&amp;gt;) -&amp;gt; Poll::(Self::Output); } 最显著的不同在于函数的两个参数类型 self类型被定义为Pin的分装，这个封装简单的来说，就是允许我们创建不可移动的Future类型；所谓的不可移动对象，是指对象里面可以出现某个字段的指针指向对象的其它字段的情况；这对于实现async/await是至关重要的。 第二个参数用一个Context对象替换了简单的wake函数 我们之所以需要一个Context对象，是因为我们需要在其中存储哪一个Future对象被轮询执行了；这在复杂的多线程程序中是不可或缺的。 Context对象和Waker类型 Context的定义如下 pub struct Context&amp;lt;'a&amp;gt; { waker: &amp;amp;'a Waker, _marker: PhantomData&amp;lt;fn(&amp;amp;'a ()) -&amp;gt; &amp;amp;'a ()&amp;gt;, } 它里面仅仅是封装了一个额外的Waker对象，以便用户定义的Future和底层的Executor进行通信，通知对方自身已经准备好了下一步对应的结果就可以返回给外部，其本身提供了clone操作，并且可以可以在多线程环境中移动和共享，因为它标记自己实现了Sync和Send pub struct Waker { waker: RawWaker, } impl Unpin for Waker {} unsafe impl Send for Waker {} unsafe impl Sync for Waker {} 其中嵌套的内部实现里面封装了一个满足具体的Executor要求的、可以包含任意上下文数据的指针data，它的注释很好地阐述了数据的用途： #[derive(PartialEq, Debug)] pub struct RawWaker { /// A data pointer, which can be used to store arbitrary data as required /// by the executor. This could be e.g. a type-erased pointer to an `Arc` /// that is associated with the task. /// The value of this field gets passed to all functions that are part of /// the vtable as the first parameter. data: *const (), /// Virtual function pointer table that customizes the behavior of this waker. vtable: &amp;amp;'static RawWakerVTable, } Waker自身提供了wake()函数，和上面简化的例子类似 #[inline] pub fn wake(self) { let wake = self.waker.vtable.wake; let data = self.waker.data; crate::mem::forget(self); unsafe { (wake)(data) }; } 一个定时器实现的例子 假设我们需要实现一个经过给定时间段后过期的名为TimerFuture的future对象，我们需要一个上下文数据标识timer是否已经完成，并且出于简化起见，当Timer被创建的时候，我们启动一个线程来在创建的线程中将其激活，因此我们需要一个跨线程共享的上下文。 类型定义 Arc类型是用来封装上下文状态的最简单的封装类 pub struct TimerFuture { shared_state: Arc&amp;lt;Mutex&amp;lt;SharedState&amp;gt;&amp;gt;, } struct SharedState { completed: bool, waker: Option&amp;lt;Waker&amp;gt;, } new函数 接下来是它的实现和new函数 impl TimerFuture { pub fn new(duration: Duration) -&amp;gt; Self { let shared_state = Arc::new(Mutex::new(SharedState { completed: false, waker: None, })); 因为需要创建一个线程来异步地标记Timer到期完毕，我们需要将该共享状态拷贝并移动到lambda对应的线程中去： let shared_state_clone = shared_state.clone(); thread::spawn(move || { thread::sleep(duration); let mut shared_state = shared_state_clone.lock().unwrap(); shared_state.completed = true; 当时间到期后，我们除了标记该共享状态的标志外，还需要在Future的使用方没有完成的情况下，主动唤醒底层的调度，此时就可以使用wake()函数了 if let Some(waker) = shared_state.waker.take() { waker.wake(); } }); TimerFuture { shared_state } } } Future实现 该TimerFuture的trait实现其实就是对共享状态查询的封装；如果已经完毕，就返回Ready,否则就返回Pending。 这里有个非常细微的问题需要注意：因为waker对象可能随着Executor在线程之间的移动而被拷贝为其它的值，为了避免对象自身保存的waker对象指向了非法的上下文，我们需要在返回pending之前重新拷贝一次自身保存的waker! impl Future for TimerFuture { type Output = (); fn poll(self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;, ctx: &amp;amp;mut Context&amp;lt;'_&amp;gt;) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; { let mut shared_state = self.shared_state.lock().unwrap(); if shared_state.completed { Poll::Ready(()) } else { shared_state.waker = Some(ctx.waker().clone()); Poll::Pending } } } Rust的await和async 这次加入1.36稳定版的功能体验在语言层面的两个关键字async和await。 async async用于声明一个代码块为返回一个Future，通过在某个普通的函数声明前面加上async，Rust可以自动完成返回类型到Future类型的封装和转换，如下面的代码 async fn do_something() { //some heavy operation } 的返回值会是一个Future. Rust本身的Executor库也提供了阻塞执行的方法，允许我们在当前的调用线程里面阻塞执行直到封装的异步执行块允许完毕，即如下的代码 let fut = do_something(); block_on(fut); // proceeds until wrapped something is executed await await语句可以作用在Future上，用于非阻塞方式的同步逻辑，即异步地等待作用的Future对象的完成，然后读取返回的结果，考虑如下的三个异步的Future执行块，前两个有先后依赖而第三个可以同时进行： async fn learn_song() -&amp;gt; Song { //dom something Song } async fn sing_song(song: Song) { //sing the song } async fn dance() { //dance } 可以用如下的逻辑来表述上面的并发执行行为 async learn_and_sing() { let song = learn_song().await; sing_song(song).await; } let f1 = learn_and_sing().await; let f2 = dance(); futures::join(f1, f2); 标准库中的Future和futures crate 目前有两个Future库同时存在，一个是标准库中的std::future::Future，另外一个则是futures中定义的futures::future::Future。这一重复定义多少让人感到困惑不解：其实这主要是由于Future特性正在被开发中还不算足够完善的缘故。 早期的实现是通过future-rs扩展库的方式提供的，最近的版本才将它加到了标准库中；甚至于实现也是移过去的；可以认为std::future::Future实现了future-rs里面的一个最小集。后续的功能演进也可能仍然采用类似的策略 标准库中的Future进来保持最小的接口 更复杂的组合功能将会用类似future库的方式来提供 FutureExt 这是基于Future之上的一个扩展的Trait，可以实现很多方便的转换，包括 map将包含的输出值经过一个函数处理变换为另外一种输出 then实现两个Feature的链式操作，并且将前一个的输出传递为第二个闭包函数的输入，例如 let f1 = async {1}; let f2 = f1.then(|x| sync move { x + 3}); assert_eq!(f2.await, 4); left_future/right_future实现根据不同的条件返回不同部分的EitherFuture功能，如 let x = 6; let f = if x &amp;lt; 10 { async {true}.left_future() } else { async {false}.right_future() } into_stream将future转换为包含单个元素的stream，这个stream的输出是future本身，支持方便的stream操作，如 let f = async {17}; let collected:Vec&amp;lt;_&amp;gt; = f.into_stream().collect().await; flatten用于实现一次解封操作，等价于 f.then(|x| x) inspect实现一个future传递之前的额外查看和处理，最简单的例子是打印计算的结果，如 let f = async {1}; let nf = f.inspect(|&amp;amp;x| println!(&quot;will resolve as {}&quot;, x)); //nf = 1</summary></entry><entry><title type="html">Rust文本处理的性能及优化</title><link href="https://skyscribe.github.io/post/2019/11/29/rust-text-processing-performance/" rel="alternate" type="text/html" title="Rust文本处理的性能及优化" /><published>2019-11-29T00:00:00+08:00</published><updated>2019-11-29T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/11/29/rust-text-processing-performance</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/11/29/rust-text-processing-performance/">&lt;p&gt;作为一门秉承&lt;strong&gt;零成本抽象&lt;/strong&gt;这一极具挑战的目标为语言设计核心的静态变成语言，用Rust语言来编写一些文本处理程序可以不需要可以优化就能达到很高的性能。
但是如果我们对已经写就的文本处理程序的性能不甚满意，觉得不够快或者想将它推向性能更高的境地，即&lt;strong&gt;需要进一步优化&lt;/strong&gt;，可能还不得不额外下一些功夫才能做到。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;大概一年前，出于实际工作内容的需要，我写过一个简单的针对产品问题报告系统上的数据到处记录的分析程序；最初的目标是在解决问题的同时顺便提高自己对Rust语言的理解；
毕竟对于学习一门难度比较高的技术而言，读多少文档和书都不如拿&lt;strong&gt;一些实践中需要解决实际的问题来练手&lt;/strong&gt;效率更高。&lt;/p&gt;

&lt;p&gt;这个问题的核心技术是典型的CSV文本文件格式解析，CSV格式本来就是一种由严格语法定义的文本格式，因而毋宁说这里的&lt;strong&gt;核心编程问题域就是文本处理&lt;/strong&gt;。
只不过因为内部流程的复杂性和牵扯到这一流程之中的人员数量的庞大，导出数据中的文本字段内还有各种各样没有经过良好格式化的数据，需要从解析好的CSV格式中做二次分解和提炼。&lt;/p&gt;

&lt;h3 id=&quot;二次解析复杂性&quot;&gt;二次解析复杂性&lt;/h3&gt;
&lt;p&gt;因此在既有的csv库的处理之上，问题本身还需要&lt;strong&gt;大量的二次解析&lt;/strong&gt;处理，甚至包括在一个&lt;strong&gt;长度可能超过数万个字符&lt;/strong&gt;的单一字段内，分解出内部较为复杂的结构集合，以便做后续的统计、归并和显示。实现这一功能本身不是特别困难，
熟悉了Rust的语法之后，适用它自身内置的&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Vec&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;等基础核心数据结构之后，配合它自身优雅的函数式编程设施和模式匹配，可以很快熟练写出想要的各种变换逻辑。&lt;/p&gt;

&lt;p&gt;具体到文本解析，则不能不提到正则表达式处理，毕竟手写的字符串搜索和子串引用&lt;code class=&quot;highlighter-rouge&quot;&gt;slice&lt;/code&gt;机制虽然好用，却往往可能会沦为&lt;strong&gt;不成熟优化&lt;/strong&gt;，因为复杂文本的处理最好还是交给专业的正则表达式库更合理。&lt;/p&gt;

&lt;h3 id=&quot;数据量增大之下的性能考验&quot;&gt;数据量增大之下的性能考验&lt;/h3&gt;
&lt;p&gt;一开始版本的程序仅仅是处理几千条记录，此时的输入文件虽然超过80MB，里面的记录有数千条，总体而言不到两秒钟的运行效率还算是差强人意，实际使用的时候，基本鼠标单击一下稍微停顿即可以完成。
随着报表数据越来越多（做出基本的功能之后，总想让它发挥更大的效力），对输入数据的要求就更高，慢慢地它需要能高效地处理300MB以上的报表输入，于此同时内部二次解析的复杂度也随着新需求的加入而变得更加复杂。&lt;/p&gt;

&lt;p&gt;此时处理时间已经接近了10秒，这么长的运行时间对于一个迷你的小工具而言太长了一点，以至于实际用鼠标单击它的时候&lt;strong&gt;能够感受到明显的停顿&lt;/strong&gt;，优化的需求迫在眉睫。&lt;/p&gt;

&lt;h2 id=&quot;优化分析&quot;&gt;优化分析&lt;/h2&gt;
&lt;p&gt;基于程序本身所使用到的基本技术，可以有下面几个优化方向&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运算缓存&lt;/li&gt;
  &lt;li&gt;多线程并行化处理&lt;/li&gt;
  &lt;li&gt;第三方库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;火焰图&quot;&gt;火焰图&lt;/h3&gt;
&lt;p&gt;当然没有benchmark数据的性能优化都是很危险的，由于Rust的底层采用的是LLVM的编译工具链，因此生成火焰图的方法也非常简单直接。只需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;Cargo.toml&lt;/code&gt;中加入如下的选项确保生成的二级制文件中包含符号表&lt;/p&gt;
&lt;div class=&quot;language-toml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;[profile.release]&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了解析Rust自身的符号，我们可以&lt;strong&gt;借助rust-unmangle工具&lt;/strong&gt;在C++符号被解析之后，二次调用它进行转换即可。在Rust的项目目录下，只要执行如下的命令即可生成火焰图文件：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;perf record --call-graph dwarf,16384 -e cpu-clock -F 997 target/release/analyzer 
perf script | stackcollapse-perf.pl | stackcollapse-recursive.pl | c++filt | rust-unmangle | flamegraph.pl &amp;gt; flame.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是生成的&lt;strong&gt;SVG矢量图文件&lt;/strong&gt;是可以点击缩放的，但是需要用合适的工具打开而不能使用默认的图片查看器。
图形里面的每一个图形的柱体是可以点击层层深入进去的；如果没有合适的工具，使用FireFox浏览器也是一个不错的选择。&lt;/p&gt;

&lt;h2 id=&quot;运算缓存&quot;&gt;运算缓存&lt;/h2&gt;

&lt;p&gt;这种优化其实是算法级别的优化，关键是找到有很多重复、或者循环的运算，将其缓存起来&lt;strong&gt;减少重复计算或者不必要的循环&lt;/strong&gt;。
这类的手法&lt;strong&gt;实施起来没有多少难度&lt;/strong&gt;，和别的编程语言中的做法也是类似的，可惜的是很多时候能做的也不是很多。&lt;/p&gt;

&lt;p&gt;更多缓存和封装的做法其实相对&lt;strong&gt;不那么符合函数式编程的思想一些&lt;/strong&gt;，有时候不得不将很漂亮优雅的函数式pipeline用法拆开，或者将中间的缓存结果放入新的参数传入函数，从而使得代码的可读性变得更差一些。&lt;/p&gt;

&lt;h2 id=&quot;第三方库&quot;&gt;第三方库&lt;/h2&gt;
&lt;p&gt;这里主要的第三方库有两个，一个是解析字符串正则表达式的&lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt;库。&lt;/p&gt;

&lt;h3 id=&quot;regex解析&quot;&gt;Regex解析&lt;/h3&gt;
&lt;p&gt;本身使用的时候&lt;strong&gt;已经有意选择了性能最高&lt;/strong&gt;的一个可用的正则库，因此换用其它正则表达式库的思路就不太可行了。&lt;/p&gt;

&lt;p&gt;还有一个思路是尽量去简化正则表达式的复杂性，比如&lt;strong&gt;减少不必要的正则表达式分组&lt;/strong&gt;操作，减少正则匹配算法中的回溯操作。可惜这一方法在第一次写就的时候已经优化过了，没有多少剩余的空间可以做文章了。&lt;/p&gt;

&lt;p&gt;唯一剩下的思路就是看是否自己使用的方法不对，或者库本身是否提供了一些&lt;strong&gt;底层API或者高级技巧&lt;/strong&gt;等。
稍微翻阅一下Regex的文档，发现该库的作者提供了两个优化性能的思路&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;减少拷贝&lt;/strong&gt;，使用解析时候的生存周期里的字符串引用，而不是采用显式的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象来保存解析的字段&lt;/li&gt;
  &lt;li&gt;减少不必要的&lt;strong&gt;按解析次数执行的内存分配&lt;/strong&gt;，而采用复用匹配组捕获的数据结构的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;减少拷贝&quot;&gt;减少拷贝&lt;/h4&gt;
&lt;p&gt;其实CSV文本格式的规范已经决定了在读入文本字段的时候，不得不对从磁盘读取出来的文本内容做拷贝，而不能用直接引用。因为对于复杂的CSV格式而言，分隔符之间可能会出现转义字段，符合规范的解析器&lt;strong&gt;不得不将转移的字符提取出来&lt;/strong&gt;做连接，返回给用户修改之后的字符串。这是第一道从操作系统的IO缓冲区到用户接口数据结构的拷贝。&lt;/p&gt;

&lt;p&gt;CSV库所建议的不必要的拷贝，其实是发生在上述的解析之后的临时内存区域经由&lt;code class=&quot;highlighter-rouge&quot;&gt;serde&lt;/code&gt;这一抽象的接口(&lt;code class=&quot;highlighter-rouge&quot;&gt;trait&lt;/code&gt;)&lt;strong&gt;反序列化到用户自定义的数据结构&lt;/strong&gt;的时候的拷贝。显然去掉这一层拷贝可以节约大量操作系统用于内存分配的时间；这一开销在很多情况下是惊人的，甚至是很多高性能的C、C++程序的秘密武器。&lt;/p&gt;

&lt;p&gt;可惜这种方法对我的工具并没有很好的借鉴意义，其深层次的原因是我的程序需要将解析出来的数据结构临时保存起来，等所有的数据都解析完之后，做排序和二次处理；而文档建议的优化方法要求&lt;strong&gt;引用的内存上的相关处理必须要在解析下一条记录的时候被释放&lt;/strong&gt;。
如果regex库内部提供可以使用生存周期更长的内存的方法，那么这种方法也不失为一个很好的优化；可惜它没有这样的机制。
此时如果强行引用解析器提供的内存，Rust贴心的编译器检查利器&lt;code class=&quot;highlighter-rouge&quot;&gt;Borrow Checker&lt;/code&gt;就会拦截非法的内存引用。&lt;/p&gt;

&lt;h4 id=&quot;使用高级api&quot;&gt;使用高级API&lt;/h4&gt;
&lt;p&gt;优化的第一步是理清默认API的底层大概做了什么事情。
由于最复杂的解析需要从&lt;strong&gt;一个字段中搜索几十甚至上百个&lt;/strong&gt;子记录，因而关注的重心就是&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_iter&lt;/code&gt;方法（严格的性能分析其实需要按照&lt;strong&gt;perf和flamegraph的工具&lt;/strong&gt;来判断和检验，这里直觉和实际的火焰图分析是重合的）。&lt;/p&gt;

&lt;h5 id=&quot;captures_iter的内存开销&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_iter&lt;/code&gt;的内存开销&lt;/h5&gt;

&lt;p&gt;正则表达式运算库的内部往往是通过DFA状态机来实现的，默认的库API很好地隐藏了内部的解析细节，用户只需要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_iter&lt;/code&gt;方法就可以得到一个&lt;strong&gt;实现了迭代器类型&lt;/strong&gt;的结构，很方便地和其它的函数式pipeline连接起来。
实际接收代码则会根据其返回的封装过的&lt;code class=&quot;highlighter-rouge&quot;&gt;CapturesMatch&lt;/code&gt;结构来读取内部的分组的匹配信息。&lt;/p&gt;

&lt;p&gt;其结构的实现如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;captures_iter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptureMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;CaptureMatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.searcher_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;返回的结构其实是使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Captures&lt;/code&gt;结构&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptureMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;re_trait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CaptureMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecNoSyncStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptureMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Captures&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Captures&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Captures&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;named_groups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.capture_name_idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_iter()&lt;/code&gt;方法会每次新构造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Catpures&lt;/code&gt;结构体出来，这里产生的对象其实是一个&lt;strong&gt;临时的对象&lt;/strong&gt;，因为每次解析完毕之后，用户代码仅仅是取出内部匹配的分组，就不再使用了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Captures&lt;/code&gt;的实际封装数据如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Captures&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re_trait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;named_groups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Arc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;高效的captures_read方法&quot;&gt;高效的&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_read&lt;/code&gt;方法&lt;/h5&gt;
&lt;p&gt;按照文档的建议，这里使用&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_read&lt;/code&gt;方法可以实现&lt;strong&gt;复用返回匹配结果的缓冲区&lt;/strong&gt;的目的，减少不必要的临时对象分配。
它的实现如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;captures_read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Match&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.captures_read_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然解决问题的关键在于这个&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocations&lt;/code&gt;结构，其实在上面的默认API的实现里面已经出现了。&lt;/p&gt;

&lt;p&gt;不出意外它果然是一个保存匹配位置的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Vec&lt;/code&gt;,这才是内部&lt;strong&gt;无法将临时对象分配在栈上的关键原因&lt;/strong&gt;，而动态堆内存的分配代价又比较高，这个事实对C/C++程序员而言完全不陌生。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocations&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;re_trait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了复用这个对象，我们需要在外侧循环调用的地方，自行定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;mutable&lt;/code&gt;的对象，然后在每次调用之前，传入即可。
考虑到我们想达到最佳的性能，在单线程的处理中，同一个正则表达式，我们仅仅需要一个对象即可，而不需要每次去分配。&lt;/p&gt;

&lt;h2 id=&quot;多线程并行化处理&quot;&gt;多线程并行化处理&lt;/h2&gt;
&lt;p&gt;默认情况下，这类简单的文本处理程序都是采用单线程的思路来写就的，改造为多线程就会多多少少面临一些挑战，尤其是需要共享变量读写的情况居多的时候，&lt;strong&gt;多线程的挑战比单线程要多得多&lt;/strong&gt;，因为程序的执行状态会变得更见难以用走读代码的方式来分析。&lt;/p&gt;

&lt;p&gt;借助于火焰图分析工具，可以看出该处理程序的大部分CPU时间耗费在基于正则表达式的二次结构化解析上。这些&lt;strong&gt;操作本身互相之间的关联比较小&lt;/strong&gt;，是显然可以被并行化的，多线程应该可以大大加速处理过程。
这方面使用经典的&lt;code class=&quot;highlighter-rouge&quot;&gt;map/reduce&lt;/code&gt;思路，只需要将实际解析的部分放入类似线程池一样的调度器中执行即可。&lt;/p&gt;

&lt;p&gt;由于Rust本身提供了强大的用于&lt;strong&gt;确保线程安全的静态代码检查&lt;/strong&gt;；绝大部分情况下，只要保证代码可以编译通过，运行期出错的可能性基本就很小了。&lt;/p&gt;

&lt;h3 id=&quot;使用rayon库&quot;&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rayon&lt;/code&gt;库&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rayon&lt;/code&gt;库提供了方便易用的&lt;code class=&quot;highlighter-rouge&quot;&gt;par_iter&lt;/code&gt;，允许我们将代码稍微改动之后，将自动获取并发执行的好处，比如原来的代码&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParsedRecords&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// parsed raw records from csv&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raw_records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse_from_csv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raw_records&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ParsedRecords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//further transformation on parsed results&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;iter()&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;par_iter()&lt;/code&gt;的调用，并将最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;方法替换为&lt;code class=&quot;highlighter-rouge&quot;&gt;rayon&lt;/code&gt;自己实现的&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;raw_records&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.par_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nn&quot;&gt;ParsedRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;.collect_into_vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由于事先已经用火焰图确认过这个二次解析构造耗费最大部分的CPU时间，这次替换和改造可以看到立竿见影的性能提升：&lt;strong&gt;运行时间瞬间减小到原来的30%~50%&lt;/strong&gt;，几乎有两三倍的性能提升!&lt;/p&gt;

&lt;h3 id=&quot;并行版本的regex问题&quot;&gt;并行版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt;问题&lt;/h3&gt;
&lt;p&gt;并行版本能工作的前提是&lt;strong&gt;没有数据的多线程访问问题&lt;/strong&gt;，当然如果有问题，编译器会自动拦截阻止编译通过。
大部分的解析工作没有什么障碍，因为Rust默认的移动语义和显示mutable设计使得这些潜在的问题马上&lt;strong&gt;自动显现&lt;/strong&gt;出来，只要按照错误提示修改&lt;strong&gt;然后在编译器的胁迫下乖乖就范&lt;/strong&gt;即可。&lt;/p&gt;

&lt;p&gt;唯一麻烦的问题就是上述的正则表达式；使用该库的同时，我们不得不面对如下两个麻烦的问题。&lt;/p&gt;

&lt;h3 id=&quot;regex对象的capturelocation共享&quot;&gt;Regex对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocation&lt;/code&gt;共享&lt;/h3&gt;
&lt;p&gt;库的官方文档提供了很好的例子，建议我们用&lt;code class=&quot;highlighter-rouge&quot;&gt;lazy_static!&lt;/code&gt;宏来避免多次编译正则表达式，实现更好的性能；可惜如果我们想使用上述提到的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocation&lt;/code&gt;对象，我们需要一个mutable的对象。&lt;/p&gt;

&lt;p&gt;这里的限制应该是目前&lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt;库自己施加的使用限制，我们无法自由地构造一个可以复用的&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocation&lt;/code&gt;对象出来，而必须由一个编译好的Regex对象来获取；由于Mutable的需要，我们不得不将Regex本身从&lt;code class=&quot;highlighter-rouge&quot;&gt;lazy_static!&lt;/code&gt;宏中提取出来，单独保存。
好在这个&lt;strong&gt;Regex对象本身还是可以保持只读&lt;/strong&gt;，多个线程引用一个只读的变量状态毫无问题。&lt;/p&gt;

&lt;p&gt;不妙的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;par_iter&lt;/code&gt;显式地将我们卷入多线程环境（我们想要更好的性能），编译器不允许在多个线程中共享mutable正则表达式，当然那样做也是错误的。
好在多线程编程的工具箱中，我们还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;这样的数据结构，只要保证每个线程使用自己的mutable对象就好了，问题自然而然得到解决。&lt;/p&gt;

&lt;p&gt;####　封装多个正则表达式
可以用一个简单的enum来表述各种正则表达式类型，然后提供给外部调用&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexCategory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FieldSep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StateChangeEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时我们需要给外部提供一个看起来像全局但是多线程安全的接口&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexReposiotry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;field_sep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state_change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state_change_ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexReposiotry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegexCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;FieldSep&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.field_sep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.state_change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;StateChangeEx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.state_change_ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;thread-local变量的创建和维护&quot;&gt;Thread Local变量的创建和维护&lt;/h4&gt;
&lt;p&gt;为了构造Thread Local的变量，我们不得不借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_local!&lt;/code&gt;宏来构造，因此可以用一些临时的值先填充之&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;lazy_static!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DUMMY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) xxxx ([a-zA-Z ]+) to ([a-zA-Z ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;thread_local!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOC_FIELDSEP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DUMMY&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.capture_locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOC_STAGECHAGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DUMMY&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.capture_locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOC_STAGECHAGE_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RefCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DUMMY&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.capture_locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//.... more&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;静态的指针值指向的并不是我们真正用于解析的正则表达式的匹配缓冲。
实际的正则表达式构造的时候，我们再重新替换真正的正则表达式对应的变量，并且拷贝之。&lt;/p&gt;

&lt;p&gt;构造的实现如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_regexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexReposiotry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RegexCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RegexReposiotry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;field_sep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_regex_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(, )?(201[789]-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}) &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FieldSep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state_change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_regex_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;(.*) The state of the problem changed from ([a-zA-Z ]+) [tT]o ([a-zA-Z ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state_change_ex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_regex_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(.*) State changed from ([a-zA-Z ]+) to ([a-zA-Z ]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateChangeEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里为简化起见，将正则表达式静态地写入在构造实现中，但是其实也可以经由创建者自己指定的方法传入。
实际的结构初始化由下面的内部函数来实现：&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create_regex_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;FieldSep&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOC_FIELDSEP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StateChange&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOC_STAGECHAGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StateChangeEx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOC_STAGECHAGE_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.borrow_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.capture_locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;RegexInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中的中间初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;location&lt;/code&gt;变量的部分，我们采用&lt;code class=&quot;highlighter-rouge&quot;&gt;RefCell&lt;/code&gt;本身提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;方法，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;*f.borrow_mut()&lt;/code&gt;来修改内部的捕获位置缓冲区为真正的正则表达式对象对应的缓冲区向量。&lt;/p&gt;

&lt;h4 id=&quot;多线程解析&quot;&gt;多线程解析&lt;/h4&gt;
&lt;p&gt;实际解析的代码则可以经由上述的正则封装，实现如下&lt;/p&gt;
&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parsing_using_regex_and_key_string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;regexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegexReposiotry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegexCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExtraInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CaptureLocations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExtraInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexes&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get_regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExtraInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;'a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;regex_info&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.location&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;marker_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RefMut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.borrow_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex_info&lt;/span&gt;
                    &lt;span class=&quot;py&quot;&gt;.regex&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.captures_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的关键在于中间的&lt;code class=&quot;highlighter-rouge&quot;&gt;regex_info.location.with(|loc| {})&lt;/code&gt;调用实际发生的时候，不同的线程会得到不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CaptureLocation&lt;/code&gt;内容；其内容在实际被写入的时候，会&lt;strong&gt;基于线程的不同而写入不同的内存&lt;/strong&gt;位置。&lt;/p&gt;

&lt;p&gt;唯一有些不太符合直接的地方在于mutable变量的获取的地方，不得不借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;RefMut&lt;/code&gt;结构将其传递如&lt;code class=&quot;highlighter-rouge&quot;&gt;captures_read&lt;/code&gt;中，而不能直接采用实际的类型。或许将来的Rust语言版本会改进这一难以理解的做法。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="rust" /><category term="engineering" /><category term="performance" /><category term="multi-threading" /><summary type="html">作为一门秉承零成本抽象这一极具挑战的目标为语言设计核心的静态变成语言，用Rust语言来编写一些文本处理程序可以不需要可以优化就能达到很高的性能。 但是如果我们对已经写就的文本处理程序的性能不甚满意，觉得不够快或者想将它推向性能更高的境地，即需要进一步优化，可能还不得不额外下一些功夫才能做到。</summary></entry><entry><title type="html">现代C++的内存模型和高性能的多线程编程</title><link href="https://skyscribe.github.io/post/2019/11/04/cpp-memory-model-and-order/" rel="alternate" type="text/html" title="现代C++的内存模型和高性能的多线程编程" /><published>2019-11-04T00:00:00+08:00</published><updated>2019-11-04T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/11/04/cpp-memory-model-and-order</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/11/04/cpp-memory-model-and-order/">&lt;p&gt;内存模型是现代C++语言标准里面的一个经常不太为人重视的特性；这种忽视大概是由于大部分的程序员关注的还是核心语言特性或者库设施这样的一些比较实用的“硬特性”。
相对而言，内存模型这样的底层的概念和机制看起来更像是给面向程序库编程的底层程序员用的。&lt;/p&gt;

&lt;p&gt;然而如果我们想追求极致的应用程序性能，又想追求&lt;strong&gt;可移植性、高性能&lt;/strong&gt;这样一些极具挑战的目标，我们不得不借助于一些极端的编程技法，寻求尽量高效地实用标准库提供的设施，
这时候我们就没法绕过C++11开始所引入的内存模型和内存访问顺序的基本语义了。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么需要内存模型&quot;&gt;为什么需要内存模型&lt;/h2&gt;
&lt;p&gt;有一个最简单的问题可能很多人没有意识到：为什么我们需要一个标准定义的内存模型？没有不可以吗？现代C++标准出来之前，一切都不是工作的很好吗？&lt;/p&gt;

&lt;p&gt;其实最简单的答案来自于&lt;strong&gt;多线程编程的需求驱动&lt;/strong&gt;和&lt;strong&gt;跨平台可移植性&lt;/strong&gt;的需求。&lt;/p&gt;

&lt;h3 id=&quot;单线程环境的程序环境&quot;&gt;单线程环境的程序环境&lt;/h3&gt;
&lt;p&gt;因为如果按照传统的UNIX编程哲学所倡导的那样：一个程序就实用一个线程，然后用进程间通信的IPC的方式来交换数据，我们根本就不需要任何的内存模型限制，因为程序的执行逻辑和代码所呈现的时许总是一一对应的。
承担程序代码到机器码翻译角色的编译器有其自身的义务要保证我们写出来的代码在经历各种复杂微妙的汇编级别的代码优化之后依然可以保证正确的语义：唯一的前提是程序员书写的代码必须得符合语言标准的定义。&lt;/p&gt;

&lt;p&gt;不能符合标准定义的程序会产生未定义的行为，即编译器可以按照它自己的实现来产生性能最好的代码，即使该行为不是程序员期望的。
这种情况下，程序员也怪不得别人了，谁让你不好好写程序呢？&lt;/p&gt;

&lt;h3 id=&quot;多线程环境的问题&quot;&gt;多线程环境的问题&lt;/h3&gt;
&lt;p&gt;在多线程的环境下，情况就会变得复杂起来了，因为旧有的&lt;strong&gt;语言标准选择自动忽略&lt;/strong&gt;了多线程语义的约束。
也就是说从编译器的角度来说，它不知道你写就的代码里面用的是多线程处理逻辑，它依然按照原来的单线程的处理方式去优化汇编代码在执行。&lt;/p&gt;

&lt;p&gt;从编译器的角度来说，只要有利于产生更加高效执行的二进制代码，它可以利用&lt;strong&gt;语句重排序的方法&lt;/strong&gt;来生成“更快”的代码，然而这种排序却完全不考虑可能的线程之间的同步错误，因为从它的角度来看，根本就&lt;strong&gt;看不到也无法理解&lt;/strong&gt;上层的某些代码块可能需要在多个线程里面调度执行。&lt;/p&gt;

&lt;p&gt;当然这也并不意味之我们就不能写线程安全的代码了，只不过&lt;strong&gt;负责约束程序代码之间的同步和禁止代码排序的处理被转嫁到了应用程序层&lt;/strong&gt;，程序员需要自己负责实现繁琐的同步和保护处理。
此时可以实用的技术手段就比较繁琐，可能需要实用线程库封装的特殊的API来实现内存访问保护。&lt;/p&gt;

&lt;h3 id=&quot;跨平台问题&quot;&gt;跨平台问题&lt;/h3&gt;
&lt;p&gt;由于旧的语言标准没有提供线程、Mutex等程序库，可移植性也无从谈起，即便是&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread&lt;/code&gt;库早就成了事实上的标准的跨平台线程库，从和平台无关的“语言律师”的角度来看，这一现状远非完美。&lt;/p&gt;

&lt;p&gt;C++11通过标准库的方式提供了关于多线程编程的各种工具类和函数的支持，进而实现一个跨平台的抽象的内存模型就是题中之义了，否则这些标准库的行为自身也会变得表现不一了。&lt;/p&gt;

&lt;h2 id=&quot;内存模型约束了什么东西&quot;&gt;内存模型约束了什么东西&lt;/h2&gt;
&lt;p&gt;内存模型其实从本质上来说，是首先定义了一个&lt;strong&gt;可以运行C++多线程程序的抽象机器&lt;/strong&gt;，该机器必须是一种概念上的具有多线程处理能力的机器，但是又需要超脱出所有可能的具体的物理实现。&lt;/p&gt;

&lt;h3 id=&quot;抽象机器概念&quot;&gt;抽象机器概念&lt;/h3&gt;
&lt;p&gt;因为不同的CPU和机器架构可能又完全不同的机器指令集，所以&lt;strong&gt;编译器本身的代码必然不是跨平台&lt;/strong&gt;的，而该抽象物理机所定义的语义模型其实是针对编译器而言的。
从这个角度看，不同的CPU架构和物理指令集其实可以看作是该抽象物理机的一种具体实现，实现这种翻译的正是编译器程序自身。&lt;/p&gt;

&lt;p&gt;通过抽象机器概念的定义和C++语言提供的标准库，需要完成&lt;strong&gt;多线程编程任务的程序员的工作就得到了极大的简化&lt;/strong&gt;：他们不再需要关心某些平台特有的API或者CPU架构的行为，只需要按照该抽象机器定义的概念模型来编写代码，不管采用哪种编译器来编译代码，
最终程序呈现的多线程表现行为总是确定的。&lt;/p&gt;

&lt;h3 id=&quot;抽象机器和内存模型&quot;&gt;抽象机器和内存模型&lt;/h3&gt;
&lt;p&gt;因为现代的CPU架构都遵循冯诺依曼架构，而多线程处理的实体是工作在一个操作系统上的多个物理CPU（或者线程），它们在执行过程中往往不得不借助于同一个物理内存来交换数据，所以多线程编程的难题就可以简单归结到&lt;strong&gt;内存访问模型的行为&lt;/strong&gt;上来了。&lt;/p&gt;

&lt;h3 id=&quot;从一个简单的例子说起&quot;&gt;从一个简单的例子说起&lt;/h3&gt;
&lt;p&gt;C++的抽象机器模型是面向多线程设计概念的，考虑一个简单的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//in thread1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//in thread2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里两个线程的代码的输出在旧的C++语言中表现得行为是不确定的，因为如果代码在不同的函数栈中被执行，那么编译器完全可以重排代码，导致第二个线程中输出的值呈现不确定性，因为它完全取决于第一个线程执行到了哪一步。&lt;/p&gt;

&lt;p&gt;可惜同样的代码在新的C++中也是未定义的，因为程序员没有给编译器足够的提示应该怎么处理同步问题。&lt;/p&gt;

&lt;h4 id=&quot;用atomic操作的c11版本&quot;&gt;用atomic操作的C++11版本&lt;/h4&gt;
&lt;p&gt;稍微将上面的例子改写一些，我们得到如下的版本&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个程序的行为就只可能是以下三种情况的一种&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果第一个线程在第一个打印之前先做完，那么就输出&lt;code class=&quot;highlighter-rouge&quot;&gt;18 17&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果第一个线程在第二个线程打印完才开始执行，那么会输出&lt;code class=&quot;highlighter-rouge&quot;&gt;0 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果两个线程交叉着执行，会打印&lt;code class=&quot;highlighter-rouge&quot;&gt;0 17&lt;/code&gt;
但是其它的情况都不会发生，因为默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic&lt;/code&gt;定义的读取和写入操作的行为约束为&lt;strong&gt;线性一致&lt;/strong&gt;，即在同一个线程中，对多个原子量的操作需要按照代码书写顺序的方式来执行，编译器不得重排改变它们的相对顺序。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;原子操作和内存顺序&quot;&gt;原子操作和内存顺序&lt;/h2&gt;
&lt;p&gt;上面例子中的关于原子量的操作行为其实就是C++的内存模型中最复杂的部分，因为原子量是&lt;strong&gt;实现高性能无锁算法的最底层的设施&lt;/strong&gt;，并且其它高级的同步设施(互斥锁、信号量、条件变量等)都可以用原子量来实现。&lt;/p&gt;

&lt;p&gt;值得注意意的是，现代C++标准中定义的内存模型其实包含了关于字节、地址、内存位置、线程和数据静态条件、线程执行进度（progress）等内容，其它的部分相对比较简单，我们这里仅关注atomic原子量的操作。&lt;/p&gt;

&lt;h3 id=&quot;上面例子中的性能问题&quot;&gt;上面例子中的性能问题&lt;/h3&gt;
&lt;p&gt;如上所述，默认的原子量操作实现了同一个线程中关于多个原子量的读、写的&lt;strong&gt;顺序一致性&lt;/strong&gt;要求，然而这个要求有些时候又显得&lt;strong&gt;代价过于高昂而影响性能&lt;/strong&gt;，
以至于在某些条件下出于性能的考虑我们喜欢降低这个要求。&lt;/p&gt;

&lt;p&gt;如果我们翻下原子量操作的API，就会发现它其实携带了一个额外的可选参数来&lt;strong&gt;允许用户指定内存顺序&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic_load_explicit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的第二个重载版本允许用户传入一个类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order&lt;/code&gt;的枚举值，该枚举值则定义了各种各样的内存访问模型。&lt;/p&gt;

&lt;h3 id=&quot;memory_order定义&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order&lt;/code&gt;定义&lt;/h3&gt;
&lt;p&gt;现有的定义如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_acq_rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在更新的C++20(还没有发布的下一个大版本)中，允许编译器实现提供自己的定义，并且将里面的枚举值用&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt;方式定义成下面的方式&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*unspecified*/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acq_rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq_cst&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_consume&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_acq_rel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acq_rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;内存顺序的简单解释&quot;&gt;内存顺序的简单解释&lt;/h3&gt;
&lt;p&gt;这几个枚举值使用于不同的原子量操作。&lt;/p&gt;

&lt;h4 id=&quot;最放松的内存顺序&quot;&gt;最放松的内存顺序&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_relaxed&lt;/code&gt;完全不提供任何的顺序性约束保证，多线程的读写操作和跨线程的可见性完全放由编译器来选择适合自身特征的实现；唯一提供的保证就是操作本身是符合原子性的。&lt;/p&gt;

&lt;h4 id=&quot;适用于读取操作的内存顺序&quot;&gt;适用于读取操作的内存顺序&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_consume&lt;/code&gt;通常和对原子量的读取操作结合起来使用，用于约束如下的情况&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在同一个线程中的&lt;strong&gt;依赖于本次读取操作的值&lt;/strong&gt;的、其它的相关的读取和写入操作语句的顺序&lt;strong&gt;不允许被重新排列&lt;/strong&gt;到该读取操作前面&lt;/li&gt;
  &lt;li&gt;其它线程中的对同样的内存位置的变量的写入操作的释放性顺序的效果&lt;strong&gt;在本线程中可见&lt;/strong&gt;，该情况其实是和&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;相互配对使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acquire&lt;/code&gt;形成了一个更强的读取操作的屏障&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;本线程中的依赖于同样内存位置的&lt;strong&gt;原子量的读写操作&lt;/strong&gt;不允许被重排于该操作之前&lt;/li&gt;
  &lt;li&gt;其它线程中的写入释放原子量的操作在本线程中可见；该情况和&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;配对使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;适用于单写入操作的内存顺序&quot;&gt;适用于单写入操作的内存顺序&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;用于写入操作之后的原子量释放的顺序约束&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当前线程中的其它的依赖于本原子量的读取和写入操作&lt;strong&gt;不许重排在本语句之前&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;本线程中的&lt;strong&gt;其它写入操作&lt;/strong&gt;对&lt;strong&gt;其它线程中的需要获取&lt;/strong&gt;同一个原子变量对应的位置的采用&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acquire&lt;/code&gt;的读取操作可见，同时对其它线程中的传递依赖于原子量值的读取操作(&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_consumed&lt;/code&gt;)可见&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者的内存访问顺序符合&lt;code class=&quot;highlighter-rouge&quot;&gt;Release-Acquire&lt;/code&gt;顺序，而后者符合&lt;code class=&quot;highlighter-rouge&quot;&gt;Release-Consume&lt;/code&gt;顺序。&lt;/p&gt;

&lt;h4 id=&quot;适用于读取并修改操作的内存顺序&quot;&gt;适用于读取并修改操作的内存顺序&lt;/h4&gt;
&lt;p&gt;这类的操作适用于比较并交换这种特殊的原子操作；和上面的类似有如下两种组合&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acq_rel&lt;/code&gt;保证操作本身同时满足&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;；同一线程中的该语句前后的读取或者写入操作均不允许被重新排序，而其它线程中的写入并释放原子量的&lt;strong&gt;操作对应的修改在本线程的修改之前&lt;/strong&gt;可见，并且本线程中对原子量的&lt;strong&gt;修改操作本身在其它线程的读取操作中也可见&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;适用于所有操作的默认值&quot;&gt;适用于所有操作的默认值&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;是默认的操作顺序，它提供了顺序一致性顺序保证&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取操作采用该内存顺序时，等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire&lt;/code&gt;操作&lt;/li&gt;
  &lt;li&gt;写入操作采用该内存顺序是，等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;操作&lt;/li&gt;
  &lt;li&gt;读取并修改操作采用该内存顺序时，等同于叠加了&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;操作的同时，还额外保证所有的线程都能看到对&lt;strong&gt;多个原子量修改的一种全局顺序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;形式化定义和解释&quot;&gt;形式化定义和解释&lt;/h3&gt;
&lt;p&gt;跨线程的同步和内存顺序问题其实是用于界定&lt;strong&gt;赋值表达式和这些表达式的副作用&lt;/strong&gt;在多个线程并发执行的时候相互顺序表现的怎么样的问题。
正式的定义需要借助于如下的术语；这些术语比较抽象，但是却可以用来做严谨的定义和分析&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequenced-before&lt;/code&gt; 表示在单线程中，两个表达式语句的&lt;strong&gt;赋值先后关系&lt;/strong&gt;；这个本身是最老的语言标准以及定义，没有什么新鲜的。并发语境下的内存模型依赖于这样简单的定义无足为奇。&lt;/li&gt;
  &lt;li&gt;依赖顺序传递：这个定义稍微复杂一些，但是依赖于前一个的定义，定义为&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;传递依赖&quot;&gt;传递依赖&lt;/h4&gt;
&lt;p&gt;赋值表达式A满足&lt;code class=&quot;highlighter-rouge&quot;&gt;sequenced-before&lt;/code&gt;表达式B，并且在下面&lt;strong&gt;任何一个条件成立&lt;/strong&gt;的时候，称为A传递依赖到B&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;表达式A是表达式B的一个&lt;strong&gt;操作对象&lt;/strong&gt;，但是不是一个对&lt;code class=&quot;highlighter-rouge&quot;&gt;std::kill_dependency&lt;/code&gt;的调用，也不是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;?:&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;操作符的左操作数。排除掉的这些操作要么有短路操作，要么是&lt;strong&gt;旧的语言标准故意允许编译器可以选择自己方便的实现&lt;/strong&gt;，因而不能定义跨平台的时许关系&lt;/li&gt;
  &lt;li&gt;A写入了一个标量对象M，而B需要从M中读取值&lt;/li&gt;
  &lt;li&gt;A传递依赖到一个表达式X，而X又传递依赖于B，即产生了对传递依赖链的&lt;strong&gt;间接传递&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;修改顺序&quot;&gt;修改顺序&lt;/h4&gt;
&lt;p&gt;对任何一个原子量的多线程修改由于&lt;strong&gt;原子量本身的不可并发&lt;/strong&gt;，而最终形成了一个在多线程环境中，关于该原子量本身的&lt;strong&gt;全局顺序&lt;/strong&gt;。这个全局顺序其实可以认为是实际反应在内存中的所有时间线上的一个一个随着各个线程中的修改而变化的值的序列，因为多线程执行是CPU的行为，而某个执行线程要想看到其它线程写入的值，必须通过内存的修改的通知得到反馈。&lt;/p&gt;

&lt;p&gt;为了便于叙述，下面的例子都假设操作的顺序和某个原子量M的值相关。
对于原子量的所有操作都满足下述的&lt;strong&gt;一致性要求&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写入－写入一致性：如果赋值A对原子量M的修改先于修改同一个原子量M的修改的赋值B，则在修改顺序上看来是A早于B发生；这个规则显然比较清楚，因为写入必须是一一进行的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取－读取一致性：如果一个计算值的关于&lt;strong&gt;读取原子量M&lt;/strong&gt;的赋值A先于另外一个作用于M的赋值B的计算，并且A的值来自于对M的写入操作X，那么B的值要么等于&lt;strong&gt;X所写入的原子量的值&lt;/strong&gt;，要么等于一个修改顺序上&lt;strong&gt;晚于X的操作Y的作用于M的副作用&lt;/strong&gt;所产生的结果；这一**要求其实是要求读取原子量的多个操作必须符合固定的先后顺序，而不允许有穿插&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取－写入一致性：如果基于原子量M的读取操作的计算A先于作用域M的写入操作的B发生，则A的值来自于在修改顺序上&lt;strong&gt;早于B的一次写入操作&lt;/strong&gt;X的副作用；即&lt;strong&gt;先读取后写入&lt;/strong&gt;的情况下，读取的一定是早于写入之前的某次修改的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入－读取一致性：如果一个写入M的操作X的副作用早于读取M的操作B，则B的赋值结果取自于X本身，或者来自于紧跟X的内存修改的值，即先写入后读取的情况下，读取的一定是写入赋值之后的原子量的值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;释放顺序&quot;&gt;释放顺序&lt;/h4&gt;
&lt;p&gt;在一个关于原子量对象M的释放操作A执行后，在M的修改顺序上的&lt;strong&gt;最长的连续序列&lt;/strong&gt;包含&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同一个线程中关于M的修改操作&lt;/li&gt;
  &lt;li&gt;其它任意一个线程中的原子性读取－修改－写入操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该序列被成为A的&lt;strong&gt;释放序列&lt;/strong&gt;；从定义上来看，它表示同线程中可能的写入操作和跨线程中发生的读取－修改－写入操作的集合。&lt;/p&gt;

&lt;h4 id=&quot;依赖顺序上的先序dependency-order-before&quot;&gt;依赖顺序上的先序（Dependency-order before）&lt;/h4&gt;
&lt;p&gt;多线程之间，当如下任意一个条件成立的时候，赋值A为&lt;strong&gt;依赖顺序上先于&lt;/strong&gt;赋值B&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A执行了原子量M的释放操作，另外一个线程中，B执行了一个对M的&lt;code class=&quot;highlighter-rouge&quot;&gt;consume&lt;/code&gt;操作，并且B读取了A的释放顺序上的任何一部分的值&lt;/li&gt;
  &lt;li&gt;A在依赖顺序上先于X，而&lt;strong&gt;X传递依赖至B&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里的第二个定义其实是一种递归定义。&lt;/p&gt;

&lt;h4 id=&quot;跨线程的先序关系-inter-thread-happens-before&quot;&gt;跨线程的先序关系 (Inter-thread happens-before)&lt;/h4&gt;
&lt;p&gt;多线程之间，如下&lt;strong&gt;任意一个条件&lt;/strong&gt;成立的时候，成为A跨线程先于B&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A同步于B&lt;/li&gt;
  &lt;li&gt;A依赖顺序上先于B&lt;/li&gt;
  &lt;li&gt;A同步于某个赋值X，而X顺序先于B(同一个线程上的赋值顺序)&lt;/li&gt;
  &lt;li&gt;A顺序先于X，而X跨线程先于B　－　这里叠加了同线程里面的顺序关系和自身的递归定义&lt;/li&gt;
  &lt;li&gt;A跨线程先于赋值X，而X跨线程先于B - 这里前后部分都用了递归定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;最终的先序关系happens-before&quot;&gt;最终的先序关系(happens-before)&lt;/h4&gt;
&lt;p&gt;不管是否跨线程，先序关系定义为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A单线程中先于B&lt;/li&gt;
  &lt;li&gt;A跨线程先于B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现上语言标准要求先序关系不能出现环结构，编译器可以在需要的时候在内部引入同步机制。&lt;/p&gt;

&lt;h4 id=&quot;强先序关系strong-happens-before&quot;&gt;强先序关系（Strong happens-before）&lt;/h4&gt;
&lt;p&gt;如果一个赋值操作修改了某个内存位置，而另外一个线程读取或者修改了同样的内存位置，而&lt;strong&gt;至少有一个操作不是原子操作，则程序的行为就是未定义&lt;/strong&gt;的，除非是这些赋值操作本身之间存在强先序关系。&lt;/p&gt;

&lt;p&gt;C++20之前的内存模型做如下的定义&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;要么A、B在同一个线程中，且满足顺序先于B&lt;/li&gt;
  &lt;li&gt;要么A和B进行显式的同步&lt;/li&gt;
  &lt;li&gt;要么A和B中间有一个可以传递这种强先序关系的X，使得A先序于X而X先序于B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++20标准对该定义进行了进一步修正，并引入了两个概念&lt;/p&gt;

&lt;h5 id=&quot;简单先序-simply-happens-before&quot;&gt;简单先序 (Simply happens-before)&lt;/h5&gt;
&lt;p&gt;A和B之间符合如下的任何一个条件可以称之为简单先序的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A顺序先于B，这是同线程的约束&lt;/li&gt;
  &lt;li&gt;A同步于B&lt;/li&gt;
  &lt;li&gt;A简单先序于X，而X简单先序于B
该定义基本是&lt;strong&gt;上述定义的简单替换&lt;/strong&gt;，目的是为更复杂的强先序关系做铺垫。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;强先序则被定义为如下某一个条件成立&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A顺序先于B&lt;/li&gt;
  &lt;li&gt;A同步于B，并且A和B的操作都是&lt;strong&gt;顺序一致性的原子量操作&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;A顺序先于X，X简单先序于Y，而Y顺序先于B；这里的&lt;strong&gt;两个传递关系&lt;/strong&gt;在多线程情况下，是通过两个跨线程的简单线序关系来进行的&lt;/li&gt;
  &lt;li&gt;A强先序于X，而X强先序于B，这是一个关于自身的递归传递定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单来说，强先序关系保证了A的赋值&lt;strong&gt;一定在任何情况下，都会&lt;/strong&gt;早于B的赋值；它本身就排除了&lt;code class=&quot;highlighter-rouge&quot;&gt;consume&lt;/code&gt;操作。&lt;/p&gt;

&lt;h4 id=&quot;副作用可见性&quot;&gt;副作用可见性&lt;/h4&gt;
&lt;p&gt;某个作用于标量M的操作A的副作用在如下条件成立的时候，会对读取M的运算B可见&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A先序于B&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不存在其它的副作用X&lt;/strong&gt;，满足A先于X而X先于B；即中间不存在可以插入的其它副作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个副作用A对计算Ｂ来说是可见的，那么在修改顺序上对M的&lt;strong&gt;最长的&lt;/strong&gt;满足&lt;strong&gt;B不先于这些副作用&lt;/strong&gt;的集合成为可见的副作用集。
根据这个定义可见，跨线程的同步问题其实可以简单归结为&lt;strong&gt;建立确定的先序关系&lt;/strong&gt;来避免静态条件，明确说明&lt;strong&gt;哪些副作用在哪些条件下可见&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;consume操作acquire操作和release操作&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Consume&lt;/code&gt;操作、&lt;code class=&quot;highlighter-rouge&quot;&gt;Acquire&lt;/code&gt;操作和&lt;code class=&quot;highlighter-rouge&quot;&gt;Release&lt;/code&gt;操作&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Consume&lt;/code&gt;操作指的是在读取操作中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_consume&lt;/code&gt;内存顺序类型（&lt;strong&gt;或者更强&lt;/strong&gt;）的操作；比它更强的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;提供了更强的同步要求。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Acquire&lt;/code&gt;操作指的是在读操作里使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acquire&lt;/code&gt;（或者更强内存顺序的操作）;还有一个&lt;strong&gt;隐式的例子是&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;lock&lt;/code&gt;操作本身其实包含一种&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire&lt;/code&gt;操作，而同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;提供的同步性要求更强。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Release&lt;/code&gt;操作则对应于比&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;或者更强的一种写操作；而类似地，&lt;code class=&quot;highlighter-rouge&quot;&gt;mutex::unlock&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;因为同步性更强，也满足release操作要求。&lt;/p&gt;

&lt;h3 id=&quot;再看内存顺序定义&quot;&gt;再看内存顺序定义&lt;/h3&gt;
&lt;p&gt;有了上述的形式化术语定义，再来看内存顺序的枚举定义就会比较清晰一些。&lt;/p&gt;

&lt;h4 id=&quot;relaxed-ordering&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Relaxed Ordering&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_relaxed&lt;/code&gt;的原子量操作其实是不保证同步的，它们不对并发的内存访问施加任何同步性要求，仅仅保证多线程之间是用没有中间状态的方式来写入内存，即多线程的写入操作之间一定有全局顺序。&lt;/p&gt;

&lt;p&gt;比如如下的例子，假设&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;都以及被初始化为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，则如下的代码&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//in thread 1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//in thread 2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结果将可能出现&lt;code class=&quot;highlighter-rouge&quot;&gt;r1=42, r2=42&lt;/code&gt;的情况，因为这里允许第二个线程执行完毕之后，第一个线程才进来读取&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;然后写入到&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;中。这里甚至允许第二个线程中的两个语句被编译器重排序，导致r2的值后加载的情况。&lt;/p&gt;

&lt;p&gt;当然这个机制也不是像一眼看上去那么一无是处，考虑下面的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//thread1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;不可能产生两个变量都被写为42的情况，因为第一个线程中的写入操作仅仅当第一个加载操作成功之后才会发生，而第二个线程中的两个判断则是反过来，如果有这样的情况就说明编译器实现中出现了环。&lt;/p&gt;

&lt;h5 id=&quot;常见的使用relaxed_order的情况&quot;&gt;常见的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;relaxed_order&lt;/code&gt;的情况&lt;/h5&gt;
&lt;p&gt;最常见的用法是实现计数器，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt;中的引用计数本身的累加操作就仅仅要求原子性，但是不需要同步；然而需要注意的是减小计数器的行为需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire-release&lt;/code&gt;同步。&lt;/p&gt;

&lt;h4 id=&quot;release-acquire&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Release-Acquire&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这是一种成对的同步读、写关系；某个标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;的操作的之前的这些&lt;strong&gt;符合或者不符合原子性的副作用都会被&lt;/strong&gt;另外一个线程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acquire&lt;/code&gt;的操作所读取到；即一旦原子性的写入完毕，那么另外一个读取就可以获得这里写入的值。&lt;/p&gt;

&lt;p&gt;这种同步的先后关系&lt;strong&gt;仅仅对读写同一个原子量的操作&lt;/strong&gt;提供保证，不同的原子量的读写操作不受影响。&lt;/p&gt;

&lt;p&gt;在底层的CPU架构实现上，编译器将会为程序员隐藏如下的细微差别&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于强顺序保证的诸如X86、SPARC、IBM大型机这样的架构在指令级别就提供了这种同步模型的支持，因此底层上不需要额外的机器指令，仅仅是&lt;strong&gt;禁止一些编译器的指令重排序&lt;/strong&gt;即可&lt;/li&gt;
  &lt;li&gt;对于像ARM、PowerPC这样的弱序机器而言，特殊的CPU保护栅指令则需要被显式的加进来以保证同步&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最常见的使用该模型的例子就是&lt;code class=&quot;highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt;的lock/unlock操作。&lt;/p&gt;

&lt;h5 id=&quot;一个传递的例子&quot;&gt;一个传递的例子&lt;/h5&gt;
&lt;p&gt;如下的代码显示了在多个线程中传递这种顺序关系的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread2
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acq_rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread3
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一个线程中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;的方式写入了flag，保证当其它的线程看到了值为1的flag的时候，对&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;的写入已经可见。
线程二则用&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_acq_rel&lt;/code&gt;关系确保在在第一个线程写入１可见的情况下，将其替换为2；
第三个线程则需要在第二个线程完毕之后才会退出循环;
三个线程对原子量的修改是线性的，并且是完成了显式的同步。&lt;/p&gt;

&lt;h4 id=&quot;release-consuming&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Release-Consuming&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;和上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;Acquire-Release&lt;/code&gt;关系略有不同的是：当线程A的写入操作采用&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_release&lt;/code&gt;而线程B中的读取操作采用&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_consume&lt;/code&gt;的时候，线程A视角看到的&lt;strong&gt;所有的依赖顺序上先于原子量写入操作的&lt;/strong&gt;其它的内存修改操作，不管它们是否为原子量写入，这些操作的副作用都传递依赖到线程B中的load操作。&lt;/p&gt;

&lt;p&gt;换言之，一旦原子量写入操作完成，B中的使用读取的原子量的值作为操作符或者使用原子量的函数都可以看到线程A中写入内存的值。&lt;/p&gt;

&lt;p&gt;这种同步模式仅仅是在&lt;strong&gt;获取和释放同一个原子量&lt;/strong&gt;的多个线程之间建立同步关系。大部分的物理CPU架构（除了DEC Alpha机外）都无需增加额外指令就可以支持这种同步模型。&lt;/p&gt;

&lt;p&gt;典型的应用场景是当我们需要实现很少需要修改的并发安全的数据结构的时候，这些数据结构包括路由表、配置、安全策略、防火墙规则等。另外一种常见的场景是实现使用指针转发的订阅、发布模型的时候的通过代理指针的发布操作的时候。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，因为几乎没有多少生产环境的编译器支持这种&lt;code class=&quot;highlighter-rouge&quot;&gt;release-consume&lt;/code&gt;内存顺序约束，从C++17开始，这种用法又变得&lt;strong&gt;不推荐使用&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;一个实现订阅发布的例子&quot;&gt;一个实现订阅、发布的例子&lt;/h5&gt;
&lt;p&gt;加入我们用一个指针来传递内容的变更，当生产者修改原子操作的指针里面存储的内容的时候，消费者可以读取到指针的变化而重新加载修改的值&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread producer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//thread consumer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//p2 carries dependency from ptr
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;/// may or may not be true!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，因为data不满足传递依赖的顺序关系，所以data的写入操作可能会被重排序而导致读取不到期望的值。
可见&lt;code class=&quot;highlighter-rouge&quot;&gt;Release-Consume&lt;/code&gt;是一种相对较弱的同步保障机制。&lt;/p&gt;

&lt;h4 id=&quot;sequentially-consistent&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequentially-consistent&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的原子量操作不光保证了同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;release/acquire&lt;/code&gt;顺序保证，还建立了一种&lt;strong&gt;关于所有的带有该标记的原子量修改操作&lt;/strong&gt;的顺序。&lt;/p&gt;

&lt;h5 id=&quot;c20之前的形式化定义&quot;&gt;C++20之前的形式化定义&lt;/h5&gt;
&lt;p&gt;对于某个用&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;方式来加载原子量M的操作B而言，它可以观察到如下的情况&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在修改顺序上早于B的某个修改M的操作A的结果&lt;/li&gt;
  &lt;li&gt;如果存在上述的A，B可以观测到A中没有标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的M的修改，这些修改本身也不在A之前发生&lt;/li&gt;
  &lt;li&gt;如果不存在上述的A，B可以观测到没有标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的内存顺序无关的对M的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果存在一个标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;std::atomic_thread_fence&lt;/code&gt;的操作X，且X和B在同一个线程中先于B，那么B可以观测到如下的其中一个&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局修改顺序中的先于X的最后一个标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的M的修改操作&lt;/li&gt;
  &lt;li&gt;晚于M的修改顺序中的无关的对M的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一对操作原子量M的操作A和B，假设A修改原子量，而B读取原子量；如果存在两个&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;操作X和Y，满足A线性先于X，而Y线性早于B，且X在全局修改顺序上早于Y，则B可以观察到&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A操作的副作用&lt;/li&gt;
  &lt;li&gt;或者A中对M的修改之后的一个不相关的对M的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一对修改原子量M的操作A和B，称对M的修改顺序上B晚于A，如果&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;存在一个&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;的X，使得A线性早于X，而X在全局修改序上早于B&lt;/li&gt;
  &lt;li&gt;或者存在一个满足同样要求的&lt;code class=&quot;highlighter-rouge&quot;&gt;atmoic_thread_fence&lt;/code&gt;Y，使得Y线性早于B，而A在全局修改序上早于X&lt;/li&gt;
  &lt;li&gt;或者存在两个&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_thread_fence&lt;/code&gt;的X和Y，满足A线性早于X，Y线性早于B，且X在全局修改序上早于Y&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的定义意味着&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;只要我们看到没有标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;memory_order_seq_cst&lt;/code&gt;的原子操作的时候，顺序一致性保证就会丧失&lt;/li&gt;
  &lt;li&gt;顺序一致性的栅fence仅仅是建立了栅之间的全局顺序，而不是原子操作之间的全局顺序&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;c20定义&quot;&gt;C++20定义&lt;/h5&gt;
&lt;p&gt;C++20的定义更为细微，它采用了内在一致性的模型来定义，更加负责，这里暂不深入琢磨。&lt;/p&gt;

&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential Ordering&lt;/code&gt;对于多生产者、多消费者模型的系统中是必须的，因为多个生产者在做修改操作的时候，所有的消费者必须&lt;strong&gt;以同样的顺序看到&lt;/strong&gt;对应的修改。&lt;/p&gt;

&lt;p&gt;然而由于该内存顺序要求在多个CPU核上在指令级别&lt;strong&gt;施加完全的内存栅&lt;/strong&gt;，因此它带来的性能损失在某些情况下不能忽略。&lt;/p&gt;

&lt;p&gt;使用这种顺序的一个强同步的例子如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x_then_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;y_then_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里有两个生产者、两个消费者，因为消费者的行为依赖于生产者的顺序而执行操作，因此我们需要借助完全的顺序一致内存顺序来施加这样的保障。&lt;/p&gt;

&lt;h2 id=&quot;和volatile的关系&quot;&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;的关系&lt;/h2&gt;
&lt;p&gt;其实和Java语言中的有些类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;仅仅保证在单线程中通过标记为volatile的变量的操作产生的副作用不允许被编译器重新排序，因此它可以强制保证一个线程中的顺序关系，但是它并&lt;strong&gt;不保证这些副作用在跨线程环境下&lt;/strong&gt;的可见性。
同时，volatile本身并不保证操作的原子性，因而并发的读写可能会产生未定义的行为。&lt;/p&gt;

&lt;p&gt;当然这里有一个显著的例外就是在Visual Studio中，默认设置情况下，所有的volatile变量的写操作都有&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;语义，而所有的读操作有&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire&lt;/code&gt;语义，因此volatile也可以在Visual Studio环境下用于跨线程的同步。
除此之外，C++标准定义的volatile并不适用于多线程编程，即使它们在和std::signal的处理函数通信的时候，用于处理sig_atomic_t变量绰绰有余了。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="design" /><category term="engineering" /><category term="cpp" /><category term="performance" /><category term="multi-threading" /><summary type="html">内存模型是现代C++语言标准里面的一个经常不太为人重视的特性；这种忽视大概是由于大部分的程序员关注的还是核心语言特性或者库设施这样的一些比较实用的“硬特性”。 相对而言，内存模型这样的底层的概念和机制看起来更像是给面向程序库编程的底层程序员用的。 然而如果我们想追求极致的应用程序性能，又想追求可移植性、高性能这样一些极具挑战的目标，我们不得不借助于一些极端的编程技法，寻求尽量高效地实用标准库提供的设施， 这时候我们就没法绕过C++11开始所引入的内存模型和内存访问顺序的基本语义了。 为什么需要内存模型 有一个最简单的问题可能很多人没有意识到：为什么我们需要一个标准定义的内存模型？没有不可以吗？现代C++标准出来之前，一切都不是工作的很好吗？ 其实最简单的答案来自于多线程编程的需求驱动和跨平台可移植性的需求。 单线程环境的程序环境 因为如果按照传统的UNIX编程哲学所倡导的那样：一个程序就实用一个线程，然后用进程间通信的IPC的方式来交换数据，我们根本就不需要任何的内存模型限制，因为程序的执行逻辑和代码所呈现的时许总是一一对应的。 承担程序代码到机器码翻译角色的编译器有其自身的义务要保证我们写出来的代码在经历各种复杂微妙的汇编级别的代码优化之后依然可以保证正确的语义：唯一的前提是程序员书写的代码必须得符合语言标准的定义。 不能符合标准定义的程序会产生未定义的行为，即编译器可以按照它自己的实现来产生性能最好的代码，即使该行为不是程序员期望的。 这种情况下，程序员也怪不得别人了，谁让你不好好写程序呢？ 多线程环境的问题 在多线程的环境下，情况就会变得复杂起来了，因为旧有的语言标准选择自动忽略了多线程语义的约束。 也就是说从编译器的角度来说，它不知道你写就的代码里面用的是多线程处理逻辑，它依然按照原来的单线程的处理方式去优化汇编代码在执行。 从编译器的角度来说，只要有利于产生更加高效执行的二进制代码，它可以利用语句重排序的方法来生成“更快”的代码，然而这种排序却完全不考虑可能的线程之间的同步错误，因为从它的角度来看，根本就看不到也无法理解上层的某些代码块可能需要在多个线程里面调度执行。 当然这也并不意味之我们就不能写线程安全的代码了，只不过负责约束程序代码之间的同步和禁止代码排序的处理被转嫁到了应用程序层，程序员需要自己负责实现繁琐的同步和保护处理。 此时可以实用的技术手段就比较繁琐，可能需要实用线程库封装的特殊的API来实现内存访问保护。 跨平台问题 由于旧的语言标准没有提供线程、Mutex等程序库，可移植性也无从谈起，即便是pthread库早就成了事实上的标准的跨平台线程库，从和平台无关的“语言律师”的角度来看，这一现状远非完美。 C++11通过标准库的方式提供了关于多线程编程的各种工具类和函数的支持，进而实现一个跨平台的抽象的内存模型就是题中之义了，否则这些标准库的行为自身也会变得表现不一了。 内存模型约束了什么东西 内存模型其实从本质上来说，是首先定义了一个可以运行C++多线程程序的抽象机器，该机器必须是一种概念上的具有多线程处理能力的机器，但是又需要超脱出所有可能的具体的物理实现。 抽象机器概念 因为不同的CPU和机器架构可能又完全不同的机器指令集，所以编译器本身的代码必然不是跨平台的，而该抽象物理机所定义的语义模型其实是针对编译器而言的。 从这个角度看，不同的CPU架构和物理指令集其实可以看作是该抽象物理机的一种具体实现，实现这种翻译的正是编译器程序自身。 通过抽象机器概念的定义和C++语言提供的标准库，需要完成多线程编程任务的程序员的工作就得到了极大的简化：他们不再需要关心某些平台特有的API或者CPU架构的行为，只需要按照该抽象机器定义的概念模型来编写代码，不管采用哪种编译器来编译代码， 最终程序呈现的多线程表现行为总是确定的。 抽象机器和内存模型 因为现代的CPU架构都遵循冯诺依曼架构，而多线程处理的实体是工作在一个操作系统上的多个物理CPU（或者线程），它们在执行过程中往往不得不借助于同一个物理内存来交换数据，所以多线程编程的难题就可以简单归结到内存访问模型的行为上来了。 从一个简单的例子说起 C++的抽象机器模型是面向多线程设计概念的，考虑一个简单的例子 static int x, y; //in thread1 x = 1; y = 2; //in thread2 cout &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; 这里两个线程的代码的输出在旧的C++语言中表现得行为是不确定的，因为如果代码在不同的函数栈中被执行，那么编译器完全可以重排代码，导致第二个线程中输出的值呈现不确定性，因为它完全取决于第一个线程执行到了哪一步。 可惜同样的代码在新的C++中也是未定义的，因为程序员没有给编译器足够的提示应该怎么处理同步问题。 用atomic操作的C++11版本 稍微将上面的例子改写一些，我们得到如下的版本 atomic&amp;lt;int&amp;gt; x, y; //thread1 x.store(17); y.store(18); //thread2 cout &amp;lt;&amp;lt; y.load() &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; x.load() &amp;lt;&amp;lt; endl; 这个程序的行为就只可能是以下三种情况的一种 如果第一个线程在第一个打印之前先做完，那么就输出18 17 如果第一个线程在第二个线程打印完才开始执行，那么会输出0 0 如果两个线程交叉着执行，会打印0 17 但是其它的情况都不会发生，因为默认的atomic定义的读取和写入操作的行为约束为线性一致，即在同一个线程中，对多个原子量的操作需要按照代码书写顺序的方式来执行，编译器不得重排改变它们的相对顺序。 原子操作和内存顺序 上面例子中的关于原子量的操作行为其实就是C++的内存模型中最复杂的部分，因为原子量是实现高性能无锁算法的最底层的设施，并且其它高级的同步设施(互斥锁、信号量、条件变量等)都可以用原子量来实现。 值得注意意的是，现代C++标准中定义的内存模型其实包含了关于字节、地址、内存位置、线程和数据静态条件、线程执行进度（progress）等内容，其它的部分相对比较简单，我们这里仅关注atomic原子量的操作。 上面例子中的性能问题 如上所述，默认的原子量操作实现了同一个线程中关于多个原子量的读、写的顺序一致性要求，然而这个要求有些时候又显得代价过于高昂而影响性能， 以至于在某些条件下出于性能的考虑我们喜欢降低这个要求。 如果我们翻下原子量操作的API，就会发现它其实携带了一个额外的可选参数来允许用户指定内存顺序 template&amp;lt; class T &amp;gt; T atomic_load( const std::atomic&amp;lt;T&amp;gt;* obj ) noexcept; template&amp;lt; class T &amp;gt; T atomic_load_explicit( const std::atomic&amp;lt;T&amp;gt;* obj, std::memory_order order ) noexcept; 其中的第二个重载版本允许用户传入一个类型为memory_order的枚举值，该枚举值则定义了各种各样的内存访问模型。 memory_order定义 现有的定义如下 typedef enum memory_order { memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst } memory_order; 在更新的C++20(还没有发布的下一个大版本)中，允许编译器实现提供自己的定义，并且将里面的枚举值用constexpr方式定义成下面的方式 enum class memory_order : /*unspecified*/ { relaxed, consume, acquire, release, acq_rel, seq_cst }; inline constexpr memory_order memory_order_relaxed = memory_order::relaxed; inline constexpr memory_order memory_order_consume = memory_order::consume; inline constexpr memory_order memory_order_acquire = memory_order::acquire; inline constexpr memory_order memory_order_release = memory_order::release; inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel; inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst; 内存顺序的简单解释 这几个枚举值使用于不同的原子量操作。 最放松的内存顺序 memory_order_relaxed完全不提供任何的顺序性约束保证，多线程的读写操作和跨线程的可见性完全放由编译器来选择适合自身特征的实现；唯一提供的保证就是操作本身是符合原子性的。 适用于读取操作的内存顺序 memory_order_consume通常和对原子量的读取操作结合起来使用，用于约束如下的情况 在同一个线程中的依赖于本次读取操作的值的、其它的相关的读取和写入操作语句的顺序不允许被重新排列到该读取操作前面 其它线程中的对同样的内存位置的变量的写入操作的释放性顺序的效果在本线程中可见，该情况其实是和memory_order_release相互配对使用 memory_order_acquire形成了一个更强的读取操作的屏障 本线程中的依赖于同样内存位置的原子量的读写操作不允许被重排于该操作之前 其它线程中的写入释放原子量的操作在本线程中可见；该情况和memory_order_release配对使用 适用于单写入操作的内存顺序 memory_order_release用于写入操作之后的原子量释放的顺序约束 当前线程中的其它的依赖于本原子量的读取和写入操作不许重排在本语句之前 本线程中的其它写入操作对其它线程中的需要获取同一个原子变量对应的位置的采用memory_order_acquire的读取操作可见，同时对其它线程中的传递依赖于原子量值的读取操作(memory_order_consumed)可见 前者的内存访问顺序符合Release-Acquire顺序，而后者符合Release-Consume顺序。 适用于读取并修改操作的内存顺序 这类的操作适用于比较并交换这种特殊的原子操作；和上面的类似有如下两种组合 memory_order_acq_rel保证操作本身同时满足acquire和release；同一线程中的该语句前后的读取或者写入操作均不允许被重新排序，而其它线程中的写入并释放原子量的操作对应的修改在本线程的修改之前可见，并且本线程中对原子量的修改操作本身在其它线程的读取操作中也可见 适用于所有操作的默认值 memory_order_seq_cst是默认的操作顺序，它提供了顺序一致性顺序保证 读取操作采用该内存顺序时，等价于acquire操作 写入操作采用该内存顺序是，等价于release操作 读取并修改操作采用该内存顺序时，等同于叠加了acquire/release操作的同时，还额外保证所有的线程都能看到对多个原子量修改的一种全局顺序 形式化定义和解释 跨线程的同步和内存顺序问题其实是用于界定赋值表达式和这些表达式的副作用在多个线程并发执行的时候相互顺序表现的怎么样的问题。 正式的定义需要借助于如下的术语；这些术语比较抽象，但是却可以用来做严谨的定义和分析 Sequenced-before 表示在单线程中，两个表达式语句的赋值先后关系；这个本身是最老的语言标准以及定义，没有什么新鲜的。并发语境下的内存模型依赖于这样简单的定义无足为奇。 依赖顺序传递：这个定义稍微复杂一些，但是依赖于前一个的定义，定义为 传递依赖 赋值表达式A满足sequenced-before表达式B，并且在下面任何一个条件成立的时候，称为A传递依赖到B 表达式A是表达式B的一个操作对象，但是不是一个对std::kill_dependency的调用，也不是&amp;amp;&amp;amp;/||/?:/,操作符的左操作数。排除掉的这些操作要么有短路操作，要么是旧的语言标准故意允许编译器可以选择自己方便的实现，因而不能定义跨平台的时许关系 A写入了一个标量对象M，而B需要从M中读取值 A传递依赖到一个表达式X，而X又传递依赖于B，即产生了对传递依赖链的间接传递 修改顺序 对任何一个原子量的多线程修改由于原子量本身的不可并发，而最终形成了一个在多线程环境中，关于该原子量本身的全局顺序。这个全局顺序其实可以认为是实际反应在内存中的所有时间线上的一个一个随着各个线程中的修改而变化的值的序列，因为多线程执行是CPU的行为，而某个执行线程要想看到其它线程写入的值，必须通过内存的修改的通知得到反馈。 为了便于叙述，下面的例子都假设操作的顺序和某个原子量M的值相关。 对于原子量的所有操作都满足下述的一致性要求 写入－写入一致性：如果赋值A对原子量M的修改先于修改同一个原子量M的修改的赋值B，则在修改顺序上看来是A早于B发生；这个规则显然比较清楚，因为写入必须是一一进行的。 读取－读取一致性：如果一个计算值的关于读取原子量M的赋值A先于另外一个作用于M的赋值B的计算，并且A的值来自于对M的写入操作X，那么B的值要么等于X所写入的原子量的值，要么等于一个修改顺序上晚于X的操作Y的作用于M的副作用所产生的结果；这一**要求其实是要求读取原子量的多个操作必须符合固定的先后顺序，而不允许有穿插 读取－写入一致性：如果基于原子量M的读取操作的计算A先于作用域M的写入操作的B发生，则A的值来自于在修改顺序上早于B的一次写入操作X的副作用；即先读取后写入的情况下，读取的一定是早于写入之前的某次修改的值 写入－读取一致性：如果一个写入M的操作X的副作用早于读取M的操作B，则B的赋值结果取自于X本身，或者来自于紧跟X的内存修改的值，即先写入后读取的情况下，读取的一定是写入赋值之后的原子量的值 释放顺序 在一个关于原子量对象M的释放操作A执行后，在M的修改顺序上的最长的连续序列包含 同一个线程中关于M的修改操作 其它任意一个线程中的原子性读取－修改－写入操作 该序列被成为A的释放序列；从定义上来看，它表示同线程中可能的写入操作和跨线程中发生的读取－修改－写入操作的集合。 依赖顺序上的先序（Dependency-order before） 多线程之间，当如下任意一个条件成立的时候，赋值A为依赖顺序上先于赋值B A执行了原子量M的释放操作，另外一个线程中，B执行了一个对M的consume操作，并且B读取了A的释放顺序上的任何一部分的值 A在依赖顺序上先于X，而X传递依赖至B 这里的第二个定义其实是一种递归定义。 跨线程的先序关系 (Inter-thread happens-before) 多线程之间，如下任意一个条件成立的时候，成为A跨线程先于B A同步于B A依赖顺序上先于B A同步于某个赋值X，而X顺序先于B(同一个线程上的赋值顺序) A顺序先于X，而X跨线程先于B　－　这里叠加了同线程里面的顺序关系和自身的递归定义 A跨线程先于赋值X，而X跨线程先于B - 这里前后部分都用了递归定义 最终的先序关系(happens-before) 不管是否跨线程，先序关系定义为 A单线程中先于B A跨线程先于B 实现上语言标准要求先序关系不能出现环结构，编译器可以在需要的时候在内部引入同步机制。 强先序关系（Strong happens-before） 如果一个赋值操作修改了某个内存位置，而另外一个线程读取或者修改了同样的内存位置，而至少有一个操作不是原子操作，则程序的行为就是未定义的，除非是这些赋值操作本身之间存在强先序关系。 C++20之前的内存模型做如下的定义 要么A、B在同一个线程中，且满足顺序先于B 要么A和B进行显式的同步 要么A和B中间有一个可以传递这种强先序关系的X，使得A先序于X而X先序于B C++20标准对该定义进行了进一步修正，并引入了两个概念 简单先序 (Simply happens-before) A和B之间符合如下的任何一个条件可以称之为简单先序的 A顺序先于B，这是同线程的约束 A同步于B A简单先序于X，而X简单先序于B 该定义基本是上述定义的简单替换，目的是为更复杂的强先序关系做铺垫。 强先序则被定义为如下某一个条件成立 A顺序先于B A同步于B，并且A和B的操作都是顺序一致性的原子量操作 A顺序先于X，X简单先序于Y，而Y顺序先于B；这里的两个传递关系在多线程情况下，是通过两个跨线程的简单线序关系来进行的 A强先序于X，而X强先序于B，这是一个关于自身的递归传递定义 简单来说，强先序关系保证了A的赋值一定在任何情况下，都会早于B的赋值；它本身就排除了consume操作。 副作用可见性 某个作用于标量M的操作A的副作用在如下条件成立的时候，会对读取M的运算B可见 A先序于B 不存在其它的副作用X，满足A先于X而X先于B；即中间不存在可以插入的其它副作用 如果一个副作用A对计算Ｂ来说是可见的，那么在修改顺序上对M的最长的满足B不先于这些副作用的集合成为可见的副作用集。 根据这个定义可见，跨线程的同步问题其实可以简单归结为建立确定的先序关系来避免静态条件，明确说明哪些副作用在哪些条件下可见。 Consume操作、Acquire操作和Release操作 Consume操作指的是在读取操作中使用了memory_order_consume内存顺序类型（或者更强）的操作；比它更强的atomic_thread_fence提供了更强的同步要求。 Acquire操作指的是在读操作里使用了memory_order_acquire（或者更强内存顺序的操作）;还有一个隐式的例子是std::mutex里面的lock操作本身其实包含一种acquire操作，而同样的atomic_thread_fence提供的同步性要求更强。 Release操作则对应于比memory_order_release或者更强的一种写操作；而类似地，mutex::unlock或者atomic_thread_fence因为同步性更强，也满足release操作要求。 再看内存顺序定义 有了上述的形式化术语定义，再来看内存顺序的枚举定义就会比较清晰一些。 Relaxed Ordering 标记为memory_order_relaxed的原子量操作其实是不保证同步的，它们不对并发的内存访问施加任何同步性要求，仅仅保证多线程之间是用没有中间状态的方式来写入内存，即多线程的写入操作之间一定有全局顺序。 比如如下的例子，假设x和y都以及被初始化为0，则如下的代码 //in thread 1 r1 = y.load(std::memory_order_relaxed); x.store(r1, std::memory_order_relaxed); //in thread 2 r2 = x.load(std::memory_order_relaxed); y.store(42, std::memory_order_relaxed); 结果将可能出现r1=42, r2=42的情况，因为这里允许第二个线程执行完毕之后，第一个线程才进来读取y然后写入到x中。这里甚至允许第二个线程中的两个语句被编译器重排序，导致r2的值后加载的情况。 当然这个机制也不是像一眼看上去那么一无是处，考虑下面的例子 //thread1 r1 = x.load(std::memory_order_relaxed); if (r1==42) y.store(r1, std::memory_order_relaxed); //thread2 r2 = y.load(std::memory_order_relaxed); if (r2 == 42) x.store(42, std::memory_order_relaxed); 不可能产生两个变量都被写为42的情况，因为第一个线程中的写入操作仅仅当第一个加载操作成功之后才会发生，而第二个线程中的两个判断则是反过来，如果有这样的情况就说明编译器实现中出现了环。 常见的使用relaxed_order的情况 最常见的用法是实现计数器，比如std::shared_ptr中的引用计数本身的累加操作就仅仅要求原子性，但是不需要同步；然而需要注意的是减小计数器的行为需要用acquire-release同步。 Release-Acquire 这是一种成对的同步读、写关系；某个标记为memory_order_release的操作的之前的这些符合或者不符合原子性的副作用都会被另外一个线程中的memory_order_acquire的操作所读取到；即一旦原子性的写入完毕，那么另外一个读取就可以获得这里写入的值。 这种同步的先后关系仅仅对读写同一个原子量的操作提供保证，不同的原子量的读写操作不受影响。 在底层的CPU架构实现上，编译器将会为程序员隐藏如下的细微差别 基于强顺序保证的诸如X86、SPARC、IBM大型机这样的架构在指令级别就提供了这种同步模型的支持，因此底层上不需要额外的机器指令，仅仅是禁止一些编译器的指令重排序即可 对于像ARM、PowerPC这样的弱序机器而言，特殊的CPU保护栅指令则需要被显式的加进来以保证同步 最常见的使用该模型的例子就是std::mutex的lock/unlock操作。 一个传递的例子 如下的代码显示了在多个线程中传递这种顺序关系的例子 std::vector&amp;lt;int&amp;gt; data; std::atomic&amp;lt;int&amp;gt; flag = {0}; //thread1 data.push_back(42); flag.store(1, std::memory_order_release); //thread2 int expected = 1; while (!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) expected = 1; //thread3 while (flag.load(std::memory_order_acquire) &amp;lt; 2); assert(data.at(0) == 42); 第一个线程中，通过memory_order_release的方式写入了flag，保证当其它的线程看到了值为1的flag的时候，对data的写入已经可见。 线程二则用memory_order_acq_rel关系确保在在第一个线程写入１可见的情况下，将其替换为2； 第三个线程则需要在第二个线程完毕之后才会退出循环; 三个线程对原子量的修改是线性的，并且是完成了显式的同步。 Release-Consuming 和上述的Acquire-Release关系略有不同的是：当线程A的写入操作采用memory_order_release而线程B中的读取操作采用memory_order_consume的时候，线程A视角看到的所有的依赖顺序上先于原子量写入操作的其它的内存修改操作，不管它们是否为原子量写入，这些操作的副作用都传递依赖到线程B中的load操作。 换言之，一旦原子量写入操作完成，B中的使用读取的原子量的值作为操作符或者使用原子量的函数都可以看到线程A中写入内存的值。 这种同步模式仅仅是在获取和释放同一个原子量的多个线程之间建立同步关系。大部分的物理CPU架构（除了DEC Alpha机外）都无需增加额外指令就可以支持这种同步模型。 典型的应用场景是当我们需要实现很少需要修改的并发安全的数据结构的时候，这些数据结构包括路由表、配置、安全策略、防火墙规则等。另外一种常见的场景是实现使用指针转发的订阅、发布模型的时候的通过代理指针的发布操作的时候。 另外需要注意的是，因为几乎没有多少生产环境的编译器支持这种release-consume内存顺序约束，从C++17开始，这种用法又变得不推荐使用。 一个实现订阅、发布的例子 加入我们用一个指针来传递内容的变更，当生产者修改原子操作的指针里面存储的内容的时候，消费者可以读取到指针的变化而重新加载修改的值 std::atomic&amp;lt;std::string*&amp;gt; ptr; int data; //thread producer std::string *p = new std::string(&quot;hello&quot;); data = 42; ptr.store(p, std::memory_order_release); //thread consumer std::string* p2; while (!(p2 = ptr.load(std::memory_order_consume))); assert(*p2 == &quot;hello&quot;); //p2 carries dependency from ptr assert(data == 42); /// may or may not be true! 需要注意的是，因为data不满足传递依赖的顺序关系，所以data的写入操作可能会被重排序而导致读取不到期望的值。 可见Release-Consume是一种相对较弱的同步保障机制。 Sequentially-consistent 标记为memory_order_seq_cst的原子量操作不光保证了同样的release/acquire顺序保证，还建立了一种关于所有的带有该标记的原子量修改操作的顺序。 C++20之前的形式化定义 对于某个用memory_order_seq_cst方式来加载原子量M的操作B而言，它可以观察到如下的情况 在修改顺序上早于B的某个修改M的操作A的结果 如果存在上述的A，B可以观测到A中没有标记为memory_order_seq_cst的M的修改，这些修改本身也不在A之前发生 如果不存在上述的A，B可以观测到没有标记为memory_order_seq_cst的内存顺序无关的对M的修改 如果存在一个标记为memory_order_seq_cst的std::atomic_thread_fence的操作X，且X和B在同一个线程中先于B，那么B可以观测到如下的其中一个 全局修改顺序中的先于X的最后一个标记为memory_order_seq_cst的M的修改操作 晚于M的修改顺序中的无关的对M的修改 对于一对操作原子量M的操作A和B，假设A修改原子量，而B读取原子量；如果存在两个memory_order_seq_cst的atomic_thread_fence操作X和Y，满足A线性先于X，而Y线性早于B，且X在全局修改顺序上早于Y，则B可以观察到 A操作的副作用 或者A中对M的修改之后的一个不相关的对M的修改 对于一对修改原子量M的操作A和B，称对M的修改顺序上B晚于A，如果 存在一个memory_order_seq_cst的atomic_thread_fence的X，使得A线性早于X，而X在全局修改序上早于B 或者存在一个满足同样要求的atmoic_thread_fenceY，使得Y线性早于B，而A在全局修改序上早于X 或者存在两个memory_order_seq_cst的atomic_thread_fence的X和Y，满足A线性早于X，Y线性早于B，且X在全局修改序上早于Y 这样的定义意味着 只要我们看到没有标记为memory_order_seq_cst的原子操作的时候，顺序一致性保证就会丧失 顺序一致性的栅fence仅仅是建立了栅之间的全局顺序，而不是原子操作之间的全局顺序 C++20定义 C++20的定义更为细微，它采用了内在一致性的模型来定义，更加负责，这里暂不深入琢磨。 使用场景 Sequential Ordering对于多生产者、多消费者模型的系统中是必须的，因为多个生产者在做修改操作的时候，所有的消费者必须以同样的顺序看到对应的修改。 然而由于该内存顺序要求在多个CPU核上在指令级别施加完全的内存栅，因此它带来的性能损失在某些情况下不能忽略。 使用这种顺序的一个强同步的例子如下 std::atomic&amp;lt;bool&amp;gt; x = {false}; std::atomic&amp;lt;bool&amp;gt; y = {false}; std::atomic&amp;lt;int&amp;gt; z = {0}; void write_x() { x.store(true, std::memory_order_seq_cst);} void write_y() { y.store(true, std::memory_order_seq_cst);} void x_then_y() { while (!x.load(std::memory_order_seq_cst)); if (y.load(std::memory_order_seq_cst)) ++z; } void y_then_x() { while (!y.load(std::memory_order_seq_cst)); if (x.load(std::memory_order_seq_cst)) ++z; } 这里有两个生产者、两个消费者，因为消费者的行为依赖于生产者的顺序而执行操作，因此我们需要借助完全的顺序一致内存顺序来施加这样的保障。 和volatile的关系 其实和Java语言中的有些类似，volatile仅仅保证在单线程中通过标记为volatile的变量的操作产生的副作用不允许被编译器重新排序，因此它可以强制保证一个线程中的顺序关系，但是它并不保证这些副作用在跨线程环境下的可见性。 同时，volatile本身并不保证操作的原子性，因而并发的读写可能会产生未定义的行为。 当然这里有一个显著的例外就是在Visual Studio中，默认设置情况下，所有的volatile变量的写操作都有release语义，而所有的读操作有acquire语义，因此volatile也可以在Visual Studio环境下用于跨线程的同步。 除此之外，C++标准定义的volatile并不适用于多线程编程，即使它们在和std::signal的处理函数通信的时候，用于处理sig_atomic_t变量绰绰有余了。</summary></entry><entry><title type="html">Google的新操作系统Fuchsia的内核设计</title><link href="https://skyscribe.github.io/post/2019/10/06/fuchsia-kernel-ziron-concepts/" rel="alternate" type="text/html" title="Google的新操作系统Fuchsia的内核设计" /><published>2019-10-06T00:00:00+08:00</published><updated>2019-10-06T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/10/06/fuchsia-kernel-ziron-concepts</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/10/06/fuchsia-kernel-ziron-concepts/">&lt;p&gt;传说中的Google的下一代操作系统项目&lt;a href=&quot;https://fuchsia.dev/fuchsia-src&quot;&gt;Fuchsia&lt;/a&gt;一直处于“犹抱琵琶半遮面”的半公开状态，只是它的代码早就开源出来一段时间了，多有人猜测&lt;strong&gt;它是不是下一代的大杀器&lt;/strong&gt;，将来会通吃目前的Android和Chrome OS生态圈；然而官方的说法却一致是含糊不清。
由于最近的一些政治事件引起的余波，技术圈又有不少人讨论这个稍微有些神秘的操作系统来。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;本文尝试就其目前官方公布的技术文档就其架构设计做一简单分析。&lt;/p&gt;

&lt;h2 id=&quot;内核架构&quot;&gt;内核架构&lt;/h2&gt;
&lt;p&gt;Fuchsia其实是基于一个微内核风格的架构，&lt;strong&gt;内核项目的名字叫做Zircon&lt;/strong&gt;。Fuchsia本身是程序员直接面对的操作系统环境，
它和Ziron的关系就像Ubuntu和Linux之间的关系一样类似。Zircon作为一个内核项目，它所提供的功能和传统的Linux、Windows、MacOS/Darwin的功能类似，都是实现对底层的硬件资源管理，同时&lt;strong&gt;提供系统调用接口&lt;/strong&gt;给上层程序使用。&lt;/p&gt;

&lt;p&gt;微内核和宏内核的争论已经是一个历久弥新的话题，从学术界到工业界双方各执一词，几十年来争吵不休，因为两者的优势和劣势都非常明显&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;微内核由于选择将内核的组织&lt;strong&gt;用分布式的思路解耦&lt;/strong&gt;开来，从设计上来说比较漂亮容易扩展但是最大的不足是性能太差&lt;/li&gt;
  &lt;li&gt;宏内核则对应于软件架构上的&lt;strong&gt;大一统、集中式单体风格&lt;/strong&gt;，所有的东西都放在内核中；从设计上来说非常丑陋不看维护成本高昂但是胜在性能很好&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;学术界一致在讨伐以Linux为代表的&lt;strong&gt;宏内核架构是设计落后&lt;/strong&gt;的表现，却被Linus直接打脸说&lt;strong&gt;微内核的想法在现在的硬件条件下根本就是在浪费资源&lt;/strong&gt;，想要高效地完成实际的复杂工作，必须要采用宏内核的思路；
之前几十年的计算机系统发展历史印证了Linus实用主义思想的胜利，
而普通的PC用户日常离不开的Windows系统，它的内核却干脆在多年的打磨和演化中，坚持用混合内核的思路来不断权衡两种设计的比重。&lt;/p&gt;

&lt;p&gt;Zircon直接旗帜鲜明地宣称它是一个微内核架构，让人自然而然地好奇它怎么设计来避免传统的微内核架构需要重复拷贝数据性能低下的弊端。&lt;/p&gt;

&lt;h2 id=&quot;zircon顶层概念设计&quot;&gt;Zircon顶层概念设计&lt;/h2&gt;
&lt;p&gt;传统的Unix/Linux内核设计秉承一切皆文件的设计理念（Eric S Raymond在&lt;a href=&quot;http://www.catb.org/~esr/writings/taoup/html/index.html&quot;&gt;Unix编程哲学&lt;/a&gt;一书中详细地阐述了这一理念并对这一简单设计推崇备至）；Zircon&lt;strong&gt;完全没有&lt;/strong&gt;采用这一理念，它另起炉灶用&lt;strong&gt;面型对象的思想&lt;/strong&gt;来假设所有的内核所管理的东西都是对象;即&lt;strong&gt;一切接对象&lt;/strong&gt;。
Small Talk的发明人Alan Kay的思想终于照耀进了最底层的操作系统设计领域而不再是中看不中用不能解决实际问题的花架子。&lt;/p&gt;

&lt;p&gt;这些对象是&lt;strong&gt;通过句柄（handle）的方式在系统调用中直接&lt;/strong&gt;暴露给用户使用的，对象本身在实现上均继承自一个名字为&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;的抽象类;稍微翻阅它的代码，就可以找到其定义包含在&lt;code class=&quot;highlighter-rouge&quot;&gt;/kernel/object/include/object/dispatcher.h&lt;/code&gt;中。&lt;/p&gt;

&lt;h3 id=&quot;dispatcher定义&quot;&gt;Dispatcher定义&lt;/h3&gt;
&lt;p&gt;Dispatcher的定义声明如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCountedUpgradeable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Recyclable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCountedUpgradeable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCountedUpgradeable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCountedUpgradeable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefCountedUpgradeable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddRefMaybeInDestructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Dispatchers are either Solo or Peered. They handle refcounting
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// and locking differently.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从类体系结构上看，它用私有继承的方式（C++中私有继承一般并不用来提供传统的接口继承而是仅仅复用代码）实现了&lt;strong&gt;基于引用计数&lt;/strong&gt;的生存周期管理。&lt;/p&gt;

&lt;p&gt;于此同时它还提供了&lt;strong&gt;基于引用计数&lt;/strong&gt;的接口操作定义&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;increment_handle_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_count_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Returns true exactly when the handle count goes to zero.
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decrement_handle_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_count_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_handle_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_count_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该接口上可以添加或者删除&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RemoveObserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后一个cancel接口可以实现停止某个observer对handle状态的监控。&lt;/p&gt;

&lt;h4 id=&quot;针对具体实现子类的接口&quot;&gt;针对具体实现子类的接口&lt;/h4&gt;
&lt;p&gt;剩下的一些虚函数接口定义则是为了方便实现类似于模板方法这一设计模式而提供给具体的对象实现的&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_obj_type_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_signal_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_signal_peer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_zero_handles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;内核对象的id&quot;&gt;内核对象的ID&lt;/h4&gt;
&lt;p&gt;内核中的所有对象都有一个唯一的ID标识符，用&lt;code class=&quot;highlighter-rouge&quot;&gt;koid&lt;/code&gt;来表示；它本身是一个64bit的整形无符号数字；并且该ID在系统运行期间从来不会被回收重用。
理论上来说，有边界的正整数总会有用完的一天，只是在务实主义者的严重，这个其实完全都不能算作一个问题，因为系统中出现重复的概率实在堪比行星撞地球了。&lt;/p&gt;

&lt;h4 id=&quot;handle&quot;&gt;Handle&lt;/h4&gt;
&lt;p&gt;用户空间的代码如果想访问内核服务中的对象，必须通过&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;句柄来完成。&lt;strong&gt;句柄的概念和Linux里面的文件描述符&lt;/strong&gt;的概念比较类似。
设计思路上来说，它采用了将&lt;strong&gt;资源索引和具体资源实现隔离&lt;/strong&gt;的方法；使得更灵活的系统演进和扩展变得更加容易。&lt;/p&gt;

&lt;p&gt;Handle在用户空间的程序看来其实是一个32位的整数值，用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_handle_t&lt;/code&gt;来定义。用户程序和内核打交道的时候，需要将一个事先从内核获取的&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;对象(通过一系列创建资源的系统调用)作为参数传递进去；指明需要操作的对象。
这样系统调用的格式上&lt;strong&gt;大都携带一个所要操作的资源的标识&lt;/strong&gt;，从而让内核直到作用在哪个内核对象上。&lt;/p&gt;

&lt;h5 id=&quot;handle和object的对应和校验&quot;&gt;handle和object的对应和校验&lt;/h5&gt;
&lt;p&gt;显然，对于用户空间的进程来说，多个不同的进程可能需要访问同一个内核资源，此时它们需要有不同的handle而不能共享同一个handle;
任何时候用户通过系统调用传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;的时候，内核都会做相应的校验&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;合法性校验：对应的资源&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;&lt;strong&gt;是否存在内核为用户进程创建&lt;/strong&gt;的handle表里，即用户不能随意创建一个自定义的handle;这样可以有效避免意外的资源撞车；同时这也暗含了每个进程必然有一个类似于handle资源表的数据结构以供内核来查验&lt;/li&gt;
  &lt;li&gt;类型校验：对应的资源的类型和系统调用所对应的&lt;strong&gt;类型是否一致&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;安全校验：用户空间的程序是否有&lt;strong&gt;合理的权限&lt;/strong&gt;来操作访问对应的内核资源；这个设计在当今的网络安全环境下尤其重要&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;handle和资源的单一绑定&quot;&gt;handle和资源的单一绑定&lt;/h5&gt;
&lt;p&gt;一个内核对象资源可以绑定于多个handle，反过来对于某个具体的handle而言它却只能绑定于一个具体的资源。并且这个绑定被设计为要么绑定于内核资源对象，要么绑定于用户空间程序；同时只有绑定于用户空间的时候，它才是对用户程序而言可见的（采用上述的整数数值的方式）。&lt;/p&gt;

&lt;p&gt;当这个handle被绑定于内核的时候，我们称它为处于迁移中(&lt;code class=&quot;highlighter-rouge&quot;&gt;in-transit&lt;/code&gt;)状态。&lt;/p&gt;

&lt;h5 id=&quot;用户空间的handle值&quot;&gt;用户空间的handle值&lt;/h5&gt;
&lt;p&gt;不同用户程序中的同一个handle值之间&lt;strong&gt;没有逻辑上的直接关系&lt;/strong&gt;；它们可以指向不同类型的资源，或者对一个进程有意义的整数值对另外一个进程可能完全没有意义。
同时关于handle值目前有一些特殊的限定用法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;被定义为非法的handle值，而其它的合法的handle必然是&lt;strong&gt;一个大于0的正整数&lt;/strong&gt;。这是一个自然而然的设计，有利于实际的比较&lt;/li&gt;
  &lt;li&gt;多个&lt;code class=&quot;highlighter-rouge&quot;&gt;handel&lt;/code&gt;&lt;strong&gt;可能归属于同一个集合&lt;/strong&gt;中，此时最低的两个比特位表示它属于哪个集合，并可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_HANDLE_FIXED_BITS_MASK&lt;/code&gt;来获取掩码&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;内核中的handle&quot;&gt;内核中的handle&lt;/h5&gt;
&lt;p&gt;内核态的handle实际上是一个C++对象，它从逻辑上包含三个逻辑部分&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对实际内核对象的引用&lt;/li&gt;
  &lt;li&gt;被允许的操作权限定义&lt;/li&gt;
  &lt;li&gt;实际被绑定的进程的信息
权限和进程绑定的语义意味着内核&lt;strong&gt;允许同一个用户进程来创建不同&lt;/strong&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;来访问同一个内核对象，只要它们的权限不同就可以。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;handle定义&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handle&lt;/code&gt;定义&lt;/h5&gt;
&lt;p&gt;内核中的类定义在&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel/object/include/object/handle.h&lt;/code&gt;文件中，它是一个标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的具体类;
类开头的注释说吗了它维护了进程和关联的内核对象的关联信息。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// A Handle is how a specific process refers to a specific Dispatcher.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Returns the Dispatcher to which this instance points.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Returns the process that owns this instance. Used to guarantee
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// that one process may not access a handle owned by a different process.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;zx_koid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process_id_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Sets the value returned by process_id().
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_process_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zx_koid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了避免不同的进程访问，类结构里面保存了它所关联的进程ID信息。&lt;/p&gt;

&lt;p&gt;针对内核资源的引用计数方面，该类提供了丰富的读取和查询操作；并提供接口返回权限检查操作。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// Returns the |rights| parameter that was provided when this instance
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// was created.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rights_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Returns true if this handle has all of the desired rights bits set.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HasRights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zx_rights_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rights_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;// Returns a value that can be decoded by Handle::FromU32() to derive a
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// pointer to this instance.  ProcessDispatcher will XOR this with its
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// |handle_rand_| to create the zx_handle_t value that user space sees.
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base_value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Get the number of outstanding handles for a given dispatcher.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dispatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;内核对象的封装&quot;&gt;内核对象的封装&lt;/h6&gt;
&lt;p&gt;同样的头文件中还包含了一个管理内核对象生存周期的&lt;code class=&quot;highlighter-rouge&quot;&gt;KernelHandle&lt;/code&gt;类。因为这里都是C++代码，我们可以借用C++语言的语义，从它的定义可以看出&lt;strong&gt;内核对象使用的是典型的移动语义&lt;/strong&gt;，即不允许复制但是可以移动。
由于这是内核的代码，并且&lt;strong&gt;C++标准库中的智能指针被禁用&lt;/strong&gt;了(参考这里的&lt;a href=&quot;https://fuchsia.dev/fuchsia-src/zircon/cxx&quot;&gt;C++语言使用&lt;/a&gt;说明)，所以该类的实现基本就是重复了C++标准库的做法&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KernelHandle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;// Movable but not copyable since we own the underlying Dispatcher.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个类是一个针对抽象资源的封装，并且对用传入的内核对象引用来构造的方式，采用了直接的&lt;code class=&quot;highlighter-rouge&quot;&gt;move&lt;/code&gt;操作来替换所有权。
同时拷贝和复制操作也被直接禁用。&lt;/p&gt;

&lt;p&gt;对不同类型资源(模板参数类型不一样)的构造和赋值，也是直接采用move语义来操作实现中封装的内核对象。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KernelHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reset&lt;/code&gt;操作和&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;实现基本就是照搬了&lt;code class=&quot;highlighter-rouge&quot;&gt;uniq_ptr&lt;/code&gt;类型的唯一所有权的处理手法。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_zero_handles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fbl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RefPtr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatcher_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;用户空间的创建替换更新和关闭&quot;&gt;用户空间的创建、替换、更新和关闭&lt;/h5&gt;
&lt;p&gt;如果要访问内核资源，用户空间的进程需要先通过具体资源的&lt;strong&gt;系统调用来创建&lt;/strong&gt;一个对应资源的handle；比如如下这些系统调用函数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_event_create&lt;/code&gt;创建一个事件类型的资源&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_process_create&lt;/code&gt;创建一个进程资源，这里进程本身其实也是一类具体的资源；这里的概念和Linux里面的进程管理作为内核的基本构造的方法完全不同：Zircon是&lt;strong&gt;将进程也作为抽象对象的一种实现&lt;/strong&gt;了。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_thread_create&lt;/code&gt;创建一个线程资源
这些函数在创建对应资源的同时，也返回了一个用户空间可用的指向对应资源的&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Handle本身可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_handle_duplicate&lt;/code&gt;调用被复制，这种情况下新创建的handle指向和旧的handle完全相同的内核资源;一般情况下惯用的做法是通过该API来&lt;strong&gt;降低需要访问的资源权限&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_handle_replace&lt;/code&gt;用来替换一个已有的handle,用户甚至可以在这个API中添加新的&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;的权限。
&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_handle_close&lt;/code&gt;顾名思义完成关闭handle的目的。&lt;/p&gt;

&lt;h5 id=&quot;用户空间和内核空间的迁移&quot;&gt;用户空间和内核空间的迁移&lt;/h5&gt;
&lt;p&gt;如下的两组API用来完成&lt;strong&gt;handle在内核和用户空间的转换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_write&lt;/code&gt;将对应的用户空间的handle转移到内核空间中，即放置于&lt;code class=&quot;highlighter-rouge&quot;&gt;in-transist&lt;/code&gt;状态&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_read&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_call&lt;/code&gt;将处于内核中的handle提前出来并绑定到用户空间中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两组API的功能实现了类似于传统Linux内核的上下文切换的功能。&lt;/p&gt;

&lt;h5 id=&quot;基于引用技术的资源权限管理&quot;&gt;基于引用技术的资源权限管理&lt;/h5&gt;
&lt;p&gt;内核中的资源如上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;类的接口声明，采用了&lt;strong&gt;基于引用计数的生命周期管理思路&lt;/strong&gt;；任何时候有一个新的handle指向一个资源，其内部的引用计数就会增加；已有的handle被关闭的时候，引用计数会自减。
当引用减小为0的时候，对应的资源会被&lt;strong&gt;自动销毁或者处于终结状态等待延迟的垃圾回收机制&lt;/strong&gt;来清理无人使用的资源。&lt;/p&gt;

&lt;h2 id=&quot;如何运行用户代码jobprocessthread&quot;&gt;如何运行用户代码：Job/Process/Thread&lt;/h2&gt;
&lt;p&gt;Zircon将&lt;strong&gt;应用程序的加载和执行放到了内核之外&lt;/strong&gt;，由用户空间的工具和函数来提供；从内核提供的资源角度来看，由下面三种重要的资源&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Job是最顶层的对象资源，它定义了运行期的种种限制，并且&lt;strong&gt;Job之间采用父子关系结构&lt;/strong&gt;，并且在系统启动的时候有个&lt;strong&gt;顶层的根(RootJob)&lt;/strong&gt;，这一设计基本是复用了传统的Linx系统设计思路&lt;/li&gt;
  &lt;li&gt;一个Job拥有一个或者多个Process资源对象，这里的Process类似于我们熟悉的进程&lt;/li&gt;
  &lt;li&gt;一个Process拥有一个或者多个Thread资源对象，而Thread代表了CPU可以执行的最小单元如CPU、寄存器、堆栈等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的设计方式比传统的Unix基于Task的思路要方便不少，比如传统的用户进程组的概念被Job所替代，并且Thread和Process的关系也被显示地设计为包含关系，不管是使用的&lt;strong&gt;便利性还是安全性上都更为干净清晰&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;Job&lt;/h3&gt;
&lt;p&gt;Job主要的目的是用来做进程的分组控制，它可以在分组的层面上提供诸如系统调用权限、资源使用限额控制等。这方面明显可以看到目前的Linux上的&lt;strong&gt;容器技术设计&lt;/strong&gt;的考虑。&lt;/p&gt;

&lt;p&gt;所有的Job构成了一个&lt;strong&gt;单根的树形结构&lt;/strong&gt;，除了根节点外每一个Job都可以由一个或者多个子Job。同时因为Process是Job的子节点，它可以在树结构中和Job处于平级结构。&lt;/p&gt;

&lt;p&gt;Job对象中包含如下信息&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;指向父对象的引用&lt;/li&gt;
  &lt;li&gt;包含子Job的集合&lt;/li&gt;
  &lt;li&gt;一组成员进程的集合&lt;/li&gt;
  &lt;li&gt;一组控制策略（目前尚未实现）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前由两个系统调用来完成对Job的控制，&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_job_create()&lt;/code&gt;用于创建Job，而&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_job_set_policy()&lt;/code&gt;用于设置控制策略。&lt;/p&gt;

&lt;h3 id=&quot;进程process&quot;&gt;进程Process&lt;/h3&gt;
&lt;p&gt;Process和传统的Linux进程的概念比起来没有太大的差别，都是用来表示可以被运行的一些程序指令的集合。
它被Job所控制，包含如下的资源&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;handles句柄对象&lt;/li&gt;
  &lt;li&gt;虚拟内存区域对象&lt;/li&gt;
  &lt;li&gt;线程对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程的创建和启动&lt;strong&gt;需要两个步骤&lt;/strong&gt;来完成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_process_create&lt;/code&gt;负责创建但不执行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_process_start&lt;/code&gt;负责执行，它在创建之后只能被执行一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个进程里面可以加入多个线程，进程会一致执行直到下列一个条件满足&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;最后一个包含的线程退出&lt;/li&gt;
  &lt;li&gt;进程自己调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_process_exit&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;父Job终止了自己的执行&lt;/li&gt;
  &lt;li&gt;父Job被销毁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程thread&quot;&gt;线程Thread&lt;/h3&gt;
&lt;p&gt;线程是一种实际消耗CPU运行资源并&lt;strong&gt;被内核调度器所调度执行&lt;/strong&gt;的一种资源，这一点和传统的Unix内核设计截然不同。它运行在一个特定的父进程对象中，使用进程所提供的内存、资源句柄等信息来完成IO处理和计算功能。&lt;/p&gt;

&lt;h4 id=&quot;线程生存周期&quot;&gt;线程生存周期&lt;/h4&gt;
&lt;p&gt;线程随着&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_thread_create()&lt;/code&gt;调用而被创建，但是&lt;strong&gt;并不会在创建后就立即被执行&lt;/strong&gt;。只有有人调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_thread_start()&lt;/code&gt;或者调用了&lt;strong&gt;父进程&lt;/strong&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_process_start()&lt;/code&gt;之后才会被执行（此时该线程是进程里面的&lt;strong&gt;第一个线程&lt;/strong&gt;）。两种系统调用都包含了实际代码执行的入口信息。
该入口信息是一个内存地址资源，传递的时候也是以句柄的方式来传入的。&lt;/p&gt;

&lt;p&gt;线程的退出条件包含以下几种情况之一&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_thread_exit()&lt;/code&gt;调用用于自行退出，入口点函数的&lt;strong&gt;返回并不会自行退出&lt;/strong&gt;线程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmar_unmap_handle_close_thread_exit()&lt;/code&gt;调用回收了对应的虚拟内存资源，此时调用方的堆栈信息也会被系统回收&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_futex_wake_handle_close_thread_exit()&lt;/code&gt;调用&lt;/li&gt;
  &lt;li&gt;父进程自身退出的时候，连带终止所有子线程&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_task_kill&lt;/code&gt;终止了线程的句柄&lt;/li&gt;
  &lt;li&gt;系统产生了异常行为，此时没有其它的处理程序可以顺利退出该线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，线程&lt;strong&gt;默认总是和父进程解绑&lt;/strong&gt;(detach)的，这意味着在父进程退出的时候，无需调用专门的&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;函数来做清理。&lt;/p&gt;

&lt;h3 id=&quot;内核到用户空间的启动&quot;&gt;内核到用户空间的启动&lt;/h3&gt;
&lt;p&gt;基于微内核的架构的一个比较复杂的地方是如何启动第一个用户空间的进程。
一种流行的做法是在内核层面实现一个仅仅用于启动加载的“迷你版“的文件系统读写和程序加载功能，然后再内核完成自启动之后旧不再使用这些功能；而Ziron并未采用这一流行的设计方法。&lt;/p&gt;

&lt;p&gt;Ziron使用的Bootloader会用&lt;strong&gt;称为ZBI的镜像文件格式&lt;/strong&gt;来同时加载内核镜像和一个数据块。该镜像格式是一个内嵌了诸如硬件细节信息、内核启动时候的命令行参数、压缩的内存磁盘镜像文件等内容的&lt;strong&gt;简单容器格式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;内存磁盘镜像文件使用LZ4格式压缩，解压后它的镜像格式是BOOTFS格式；该格式其实是一个&lt;strong&gt;简单的只读文件系统&lt;/strong&gt;，内含了用户空间程序需要运行的环境、共享库和数据文件等，且每一项都包含了&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件名&lt;/li&gt;
  &lt;li&gt;文件大小&lt;/li&gt;
  &lt;li&gt;文件在BOOTFS里面的相对偏移量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些数值都需要&lt;strong&gt;保证和页面大小对齐&lt;/strong&gt;，并且目前仅限于32位数字。
当内核完成自举之后，BOOTFS里面的这些文件随之变成一个挂载在&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot目录&lt;/code&gt;的文件系统。&lt;/p&gt;

&lt;p&gt;但是内核本身并不包含任何解压和解析BOOTFS文件格式的代码，这些功能是通过第一个用户空间的称为&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;的进程来完成的。&lt;/p&gt;

&lt;h4 id=&quot;userboot进程的加载&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;进程的加载&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;进程是一个普通的用户空间进程，它可以使用内核定义的系统调用来完成具体的工作；它和其它用户空间进程的区别在于内核加载它的方式是特殊的。
在编译阶段，userboot被和内核镜像直接用&lt;strong&gt;简单的ELF文件格式打包&lt;/strong&gt;在一起。
然而内核并不需要真的来解析ELF文件才能使用它，在编译期间诸如只读段的大小、可执行段的大小、入口函数的位置这些信息都被从文件中提取出来然后&lt;strong&gt;用常量定义的方式传递给内核&lt;/strong&gt;代码。&lt;/p&gt;

&lt;p&gt;随后在加载过程中，内核会发送初始的bootstrap消息给userboot，内核启动的命令行参数会被解析为一个一个的单词并以字符串环境变量的格式传递给userboot；这样所有它需要使用的资源句柄都会包含在该消息中。&lt;/p&gt;

&lt;h5 id=&quot;解压bootfs和启动加载服务&quot;&gt;解压BOOTFS和启动加载服务&lt;/h5&gt;
&lt;p&gt;随后基于内核映射系统调用的vDSO的工作方式，userboot可以在其后的内存位置上找到系统调用的代码入口，完成系统调用。
它需要做的第一件事就是&lt;strong&gt;通过传入为VMO类型的句柄来解压ZBI格式的BOOTFS镜像&lt;/strong&gt;，使用自己包含的LZ4格式支持代码来完成解压处理，将解压之后的文件内容放入新的VMO对象中。&lt;/p&gt;

&lt;p&gt;接下来它需要环境变量传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot=&amp;lt;file&amp;gt;&lt;/code&gt;信息，来&lt;strong&gt;查找到对应的文件作为第一个真正的用户空间&lt;/strong&gt;进程；如果用户没有指定该启动选项，则默认启动BOOTFS镜像中包含的&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/bootsvc&lt;/code&gt;程序。
因为usertoot实现了完整的ELF格式解析功能，它可以识别到具体的动态链接文件的属性信息，并在需要的时候调用额外的解析器来加载需要解释执行的文件。&lt;/p&gt;

&lt;p&gt;随后userboot会将包含系统调用服务的vDSO加载到一个随机的内存地址（这样可以有效地防止黑客攻击内核），并用正常的基于Channel的方式启动新的进程，将这个vDSO的基地址和Channel资源的句柄传递给子进程。
在这个Channel上，userboot会将它从内核接收到的启动信息简单替换处理后发送个子进程。&lt;/p&gt;

&lt;h5 id=&quot;加载服务传递&quot;&gt;加载服务传递&lt;/h5&gt;
&lt;p&gt;直接被&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;启动的是一个加载服务进程，它会接收到userboot传递来的vDSO和一个包含加载服务信息的通道的句柄。
正常情况下加载服务处理完成这些信息之后，应该&lt;strong&gt;尽快关闭该通道&lt;/strong&gt;。
userboot程序会循环处理来自加载服务的请求，并且在收到加载对象的请求的时候，查询BOOTFS中的以&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/&lt;/code&gt;为前缀的文件&lt;strong&gt;并用VMO的方式将内容返回&lt;/strong&gt;给加载服务；这样第一个真正的用户进程就可以访问放在BOOTFS中的动态链接库信息。
这些文件同时也会以文件的形态出现在&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;作为一个单线程的应用，&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;在通道被对方关闭之后，就立马退出处理循环并不再需要做其它事情了。
除了特殊测试场景的设置它会等待启动的用户程序退出才自己退出外，正常情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;userboot&lt;/code&gt;就会自行退出，留下它所启动的子进程作为用户可以看见的第一个进程。&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存对象&quot;&gt;虚拟内存对象&lt;/h3&gt;

&lt;h2 id=&quot;ipc机制&quot;&gt;IPC机制&lt;/h2&gt;
&lt;p&gt;Zircon提供了&lt;strong&gt;基于消息传递&lt;/strong&gt;设计的IPC机制，这里面主要的IPC对象是Socket和Channel；两者都提供双向的消息交互，具有两个通信端点。
创建Socket或者Channel的时候，我们就会得到&lt;strong&gt;指向同一个IPC对象资源的两个句柄&lt;/strong&gt;，每一个代表通信的一方向。&lt;/p&gt;

&lt;h3 id=&quot;socket&quot;&gt;Socket&lt;/h3&gt;
&lt;p&gt;Socket提供了一种双向的基于数据流的IPC机制，它的主要机制是&lt;strong&gt;数据搬运和移动&lt;/strong&gt;。
创建之后，连接socket的两端都可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_sockert_read/write&lt;/code&gt;执行读写操作;同时它支持类似于TCP协议的半关闭的概念，用户可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_socket_shutdown&lt;/code&gt;里设置&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_SOCKET_SHUTDOWN_READ/WRITE&lt;/code&gt;来关闭读或者写操作。&lt;/p&gt;

&lt;p&gt;Socket本身分为两种类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ZX_SOCKET_STREAM类型的socket在写入的时候会检查内部缓冲的大小，如果&lt;strong&gt;缓冲区未满则允许写入一部分或者全部&lt;/strong&gt;数据，写操作会返回成功，并且调用者可以得到实际写入的字节数；如果缓冲已满，则返回&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_ERR_SHOULD_WAIT&lt;/code&gt;，此时调用方需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_async&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_one&lt;/code&gt;这样的异步调用来等待&lt;/li&gt;
  &lt;li&gt;ZX_SOCKET_DATAGRAM类型的socket在类似情况下&lt;strong&gt;不会部分写入&lt;/strong&gt;，如果缓冲可用空间不足则会直接返回&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_ERR_SHOULD_WAIT&lt;/code&gt;,如果写入成功返回值就会包含实际写入的数据大小。而该类型的socket在读取的时候会仅仅读取第一个可用的DATAGRAM。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Socket相关的系统调用还提供了类似于查询缓冲大小的API，用户需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_get_info&lt;/code&gt;中指定对象类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_INFO_SOCKET&lt;/code&gt;，然后再返回的结构体中查看&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_info_socket_t&lt;/code&gt;。
这个获取内核对象信息的接口是一个C风格的泛型接口&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;zircon/syscalls.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;zx_status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_object_get_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zx_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;channel&quot;&gt;Channel&lt;/h3&gt;
&lt;p&gt;Channel对象&lt;strong&gt;是一种基于数据报&lt;/strong&gt;的IPC对象；不同于socket的机制，IPC的两端通过Channel&lt;strong&gt;交换的是内核资源的句柄&lt;/strong&gt;。
Channel最大不能超过&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_CHANNEL_MAX_MSG_BYTES&lt;/code&gt;个字节，同时它还限制了最多可以关联&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_CHANNEL_MAX_MSG_HANDLES&lt;/code&gt;个内核对象句柄。&lt;/p&gt;

&lt;p&gt;当对应的内核资源的句柄被写入到一个Channel中去的时候，它再当前调用进程里面的句柄引用就会被删除；而当Channel的读取方获得该资源句柄的时候，它又被内核自动关联到接收进程的引用句柄列表中。
&lt;strong&gt;处于中间状态的内核对象会持续存在&lt;/strong&gt;，除非有一些关闭进程或者异常处理的程序关闭了Channel的另外一端，这种情况下对应的资源句柄会被一同清理。&lt;/p&gt;

&lt;h4 id=&quot;channel和消息队列&quot;&gt;Channel和消息队列&lt;/h4&gt;
&lt;p&gt;Channel自身维护了一个&lt;strong&gt;有序的消息队列&lt;/strong&gt;，其中的每一个消息里面包含数据和某些内核资源句柄。
对&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_write&lt;/code&gt;的调用会将对应的消息放入Channel的消息队列中，而&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_read&lt;/code&gt;则会将已经排队的消息出队。
某个线程可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_one&lt;/code&gt;系统调用显示地阻塞等待另外一方发送消息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_channel_call&lt;/code&gt;调用则会完成如下的操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将消息写入队列&lt;/li&gt;
  &lt;li&gt;等待对方的消息响应&lt;/li&gt;
  &lt;li&gt;将收到的消息出队，此时收到的消息的&lt;strong&gt;前４个字节&lt;/strong&gt;包含内核提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;transaction ID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;通过channel收发消息的操作原子化和一致性&quot;&gt;通过Channel收发消息的操作原子化和一致性&lt;/h5&gt;
&lt;p&gt;通过一个Channel来发送消息总是经过如下的两步式操作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用&lt;strong&gt;原子化的方式&lt;/strong&gt;将数据写入channel并将消息中包含的所有对象的句柄的所有权移动到Channel中去&lt;/li&gt;
  &lt;li&gt;消息的读取方用用原子化方式将所有的资源句柄移入调用方的句柄表里面，如果有失败发生，所有权依然再Channel对象中，但是用户指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_CHANNEL_READ_MAY_DISCARD&lt;/code&gt;选项的除外&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正式因为这个移动和所有权的设计，导致Channel对象不像其它内核对象一样可以被复制。Fuchsia设计的关于&lt;strong&gt;消息的顺序性保证异常严格&lt;/strong&gt;：
当一个Channel的所有权正在被内核从一个进程传递到另外一个进程的过程中的时候，即使是来自于同一个进程的同时进行的消息写入操作也不会破坏消息之间的相对次序。&lt;/p&gt;

&lt;p&gt;上述的顺序性保证是Channel独有的，其它的内核对象并没有该性质。&lt;/p&gt;

&lt;h3 id=&quot;signalport和event&quot;&gt;Signal，Port和Event&lt;/h3&gt;
&lt;p&gt;Signal和Event是用于实现进程间通知的一类内核对象。&lt;/p&gt;

&lt;h4 id=&quot;signal&quot;&gt;Signal&lt;/h4&gt;
&lt;p&gt;Zircon内核对象通过Signal接口来通知应用程序一些简单的信息：一个signal仅仅能传输&lt;strong&gt;信息容量为一即一个比特位&lt;/strong&gt;的内核发生的具体事件。有些signal是多个内核对象共享的，而另外一些则是因内核对象的不同而定。&lt;/p&gt;

&lt;p&gt;用户空间的程序可以用如下的系统调用来捕捉内核对象的signal&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_one&lt;/code&gt;会以阻塞的方式等待给定内核对象上的指定信号集中的某一个发生，直到超时或者关注的信号被触发&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_many&lt;/code&gt;允许用户&lt;strong&gt;传入多个等待的内核对象以及它们上关联的&lt;/strong&gt;信号集作为参数，并等到对应的信号通知，直到超时或者至少一个信号被触发&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_async&lt;/code&gt;是异步等待的系统调用，它通过一个额外的Port类对象来协助完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后一个异步的等待方式略微复杂，但是避免了同步等待阻塞应用程序的代价&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;zx_status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zx_object_wait_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zx_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;n&quot;&gt;zx_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;n&quot;&gt;zx_signals_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;port和异步等待&quot;&gt;port和异步等待&lt;/h4&gt;
&lt;p&gt;上面的系统调用通过&lt;code class=&quot;highlighter-rouge&quot;&gt;signals&lt;/code&gt;参数指定对应handle所指向的内核对象上的哪些signal需要被关注，当对应的signal被触发的时候，一个新的包会被排队于Port对象上。&lt;/p&gt;

&lt;p&gt;而Port的队列里会&lt;strong&gt;包含所有已经发生的信号&lt;/strong&gt;而不仅仅限于&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_wait_async&lt;/code&gt;所指定的那些signal；一旦排队发生，异步等到的操作即告完成，即不会有更多的信号引起的包被排队于Port上。&lt;/p&gt;

&lt;p&gt;Port对象的用户可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_port_wait&lt;/code&gt;来获取这些得到的信号，也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_port_cancel&lt;/code&gt;系统调用终止整个异步等待操作。&lt;/p&gt;

&lt;h5 id=&quot;port的逻辑概念&quot;&gt;Port的逻辑概念&lt;/h5&gt;
&lt;p&gt;Port其实是一个更加底层的&lt;strong&gt;消息信箱&lt;/strong&gt;的概念。它允许线程等待通过包发送的各种各样的事件；这些事件不但包含显示地排队于其上的包，也适用于通过异步IPC机制发送过来的消息数据。它通过三个系统调用来提供服务&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_port_create&lt;/code&gt;创建一个Port&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_port_queue&lt;/code&gt;发送数据包到某个Port对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_port_wait&lt;/code&gt;等待数据包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Port既可以接收来自用户空间的包，也&lt;strong&gt;可以处理来自内核的包&lt;/strong&gt;（如上面所述的Signal）；它还可以绑定于某种内核中断，此时&lt;strong&gt;内核中断的优先级比其它的非中断包的优先级要高&lt;/strong&gt;因而会被优先处理。&lt;/p&gt;

&lt;p&gt;如果一个线程需要处理大量的内核对象Handle上过来的信号，&lt;strong&gt;Port机制是一种效率更高&lt;/strong&gt;的方案所以应该被优先考虑。&lt;/p&gt;

&lt;h4 id=&quot;event&quot;&gt;Event&lt;/h4&gt;
&lt;p&gt;Event是一种包含了多个活跃信号集的简单内核对象，它代表了用户可以触发的信号对象集。目前预留了&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_USER_SIGNAL_0&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;ZX_USER_SIGNAL_7&lt;/code&gt;总共8个用户可以设置、清理、等待的自定义信号。&lt;/p&gt;

&lt;p&gt;用户需要适用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_signal&lt;/code&gt;来触发自定义的信号。&lt;/p&gt;

&lt;p&gt;Event Pair则是一对其中的信号会互相触发的Event对。用户可以适用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_object_signal&lt;/code&gt;来向对方发送自定义的信号。
当Event Pair上的一端上的所有资源句柄都被关闭的时候，另外一端则会自动收到&lt;code class=&quot;highlighter-rouge&quot;&gt;PEER_CLOSED&lt;/code&gt;信号。&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存对象vmo&quot;&gt;虚拟内存对象VMO&lt;/h3&gt;
&lt;p&gt;虚拟内存对象表示一系列&lt;strong&gt;物理内存页对象&lt;/strong&gt;，或者是需要按需创建、惰性按需填充的内存页的集合。
内核提供&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmar_map&lt;/code&gt;来允许用户将地址空间映射到进程里面；&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmar_unmap&lt;/code&gt;则执行相反的地址空间的卸映射。
用户程序也通过&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmar_protect&lt;/code&gt;来设置或者调整页面的控制权限。&lt;/p&gt;

&lt;p&gt;同一个VMO对象可以被多个进程各自映射到他们的用户地址空间中。&lt;strong&gt;不同于Linux&lt;/strong&gt;的内核空间和用户空间完全隔离的做法，
Zircon用&lt;strong&gt;同样VMO对象&lt;/strong&gt;来满足内核空间和用户空间的内存管理；它是一种通用的多进程之间共享内存的做法。&lt;/p&gt;

&lt;h4 id=&quot;页面对齐和大小调整&quot;&gt;页面对齐和大小调整&lt;/h4&gt;
&lt;p&gt;实际VMO的大小会被内核自动调整为和页面大小对齐，用户可以适用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmo_set_size&lt;/code&gt;来指定一个希望设置的大小，而&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmo_get_size&lt;/code&gt;则接收内核调整过后向上对齐的实际大小。&lt;/p&gt;

&lt;h4 id=&quot;页面映射和分配&quot;&gt;页面映射和分配&lt;/h4&gt;
&lt;p&gt;内存页面被相关的系统调用以&lt;strong&gt;按需使用的方式分配&lt;/strong&gt;给VMO对象，比如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;系统调用&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmo_read&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmo_write&lt;/code&gt;被触发的时候，或者&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmar_map&lt;/code&gt;创建的VMO对象被写入数据的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核也允许通过&lt;code class=&quot;highlighter-rouge&quot;&gt;zx_vmo_op_range&lt;/code&gt;调用来分配或者释放对应的内存页，不过这些操作应该被当作是非常底层的系统调用来使用，一般可以应用于缓存或者锁算法；一般用户空间的代码还是不用为好。&lt;/p&gt;

&lt;h2 id=&quot;libc库的支持&quot;&gt;libc库的支持&lt;/h2&gt;
&lt;p&gt;Fuchsia实现了一个部分遵循POSIX标准（子集）的C标准库；它最初是基于musl这个容器世界里非常流行的迷你C库，但是修改了很多自己的实现；但是整体的代码布局依然和musl保持一致。&lt;/p&gt;

&lt;p&gt;由于系统设计的不同，Fuchsia的C库并不支持静态链接，所有的程序都必须使用动态链接，且libc.so本身就是一个动态链接器。
另外，它也不支持Linux上的IO操作的功能，相反它提供了一个针对fdio.so的弱符号封装。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="os" /><category term="kernel" /><category term="design" /><category term="architecture" /><category term="engineering" /><summary type="html">传说中的Google的下一代操作系统项目Fuchsia一直处于“犹抱琵琶半遮面”的半公开状态，只是它的代码早就开源出来一段时间了，多有人猜测它是不是下一代的大杀器，将来会通吃目前的Android和Chrome OS生态圈；然而官方的说法却一致是含糊不清。 由于最近的一些政治事件引起的余波，技术圈又有不少人讨论这个稍微有些神秘的操作系统来。</summary></entry><entry><title type="html">reduce-cpp-template-overhead</title><link href="https://skyscribe.github.io/post/2019/10/04/reduce-cpp-template-overhead/" rel="alternate" type="text/html" title="reduce-cpp-template-overhead" /><published>2019-10-04T00:00:00+08:00</published><updated>2019-10-04T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/10/04/reduce-cpp-template-overhead</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/10/04/reduce-cpp-template-overhead/">&lt;p&gt;新的C++语言标准的演进越来越强调静态编译（即运行期计算）的优势，因为这一发展方向无疑更贴合现代的C++语言&lt;strong&gt;Zero Cost Abstraction&lt;/strong&gt;的目标；
可惜这样做有个非常明显的副作用就是给编译器带来了巨大的挑战，乃至于稍微复杂一点的项目也动辄需要数个小时才能编译完成。&lt;/p&gt;

&lt;p&gt;之前除了一些社区的抱怨
(参考这篇&lt;a href=&quot;//post/2018/12/30/modern-cpp-reflection/&quot;&gt;反思文章&lt;/a&gt;)
很少有正面解决问题的实用思路和技术出现。
好在最近结束的&lt;a href=&quot;https://cppcon.org/cppcon-2019-program/&quot;&gt;CppCon2019大会&lt;/a&gt;上，来自Google的软件工程师做了一个非常有趣而实用的如何优化编译器运行时模板元编程负担的演讲(原文链接在&lt;a href=&quot;https://cppcon.org/cppcon-2019-program/&quot;&gt;这里&lt;/a&gt;)，&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;由于官方&lt;a href=&quot;https://github.com/CppCon/CppCon2019&quot;&gt;放出来的材料&lt;/a&gt;里没有包含这一部分内容，本文不妨从作者的演讲视频中截取其要点详细探讨一番。&lt;/p&gt;

&lt;h2 id=&quot;基本背景知识&quot;&gt;基本背景知识&lt;/h2&gt;
&lt;p&gt;模板元编程使现代C++编程的一个&lt;strong&gt;至关重要却又极其烧脑&lt;/strong&gt;的子领域，传统的C++程序员要么使从C背景转换而来，
要么是出于&lt;strong&gt;用不着就不需要了解”的心理有意绕开&lt;/strong&gt;这部分，导致讲述一些稍微复杂的技巧的时候，他们往往由于缺乏这些基本的背景知识而无法理解，进而给C++语言扣上了一个太复杂的帽子。&lt;/p&gt;

&lt;p&gt;然而这些知识是理解优化编译技巧的基础，试想如果不能大概理解编译器如何来解析和生成模板元的代码，又怎么能发掘出有效的方法来做针对性的优化；
毕竟&lt;strong&gt;知其所以然是深入理解一项技术的基本要求&lt;/strong&gt;，没有理解其机制而盲目地抱怨设计的差是很无知的。&lt;/p&gt;

&lt;p&gt;Jorg从一个基本的例子来展开他的介绍的。&lt;/p&gt;

&lt;h3 id=&quot;如何用模板元方法计算斐波那契数&quot;&gt;如何用模板元方法计算斐波那契数&lt;/h3&gt;
&lt;p&gt;斐波那契数列是映射自然增长规律的一个数学序列，用传统的非泛型方法求取它非常容易，用最简单的数学定义和现代的C++语言可以写为如下的形式&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// fib(30) = 832040
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当然这个写法是编程入门教材中介绍的做法，虽然形式简单却不使用，因为输入的数字稍微大一点，就需要很长时间的运算才能计算出来，并且由于递归深度的限制，很容易遇到栈溢出的难题。
从编译器优化的角度来看，&lt;strong&gt;非尾递归形式的递归函数调用需要和递归深度相同的嵌套的栈帧&lt;/strong&gt;，很容易触碰到栈空间的上限而引起程序崩溃。&lt;/p&gt;

&lt;p&gt;引用模板元泛型的写法，我们可以用一个结构体加运行期计算的变量的方式来表达同样的算法&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;///This is unfortunately required for C++11/14
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个例子描述了基本的泛型算法特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将&lt;strong&gt;动态运算的变量当作模板参数&lt;/strong&gt;，并且递归地调用自身，但是模板参数的数值在缩小&lt;/li&gt;
  &lt;li&gt;对于模板中止条件，采用&lt;strong&gt;模板特化的方法，具体实现之&lt;/strong&gt;，这里即对0/1直接返回&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c17新语法&quot;&gt;C++17新语法&lt;/h4&gt;

&lt;p&gt;上述的写法虽然不失清晰，但是却略微显臃肿，相比于最初的非模板写法，需要引入三个不同的结构体定义。
C++17新引入的&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr if&lt;/code&gt;语法则轻而易举地去掉了这些臃肿，我们可以通过在if表达式中加入&lt;code class=&quot;highlighter-rouge&quot;&gt;constexr&lt;/code&gt;修饰来&lt;strong&gt;告知编译器对应的部分可以在模板元编程实例化的时候来参与&lt;/strong&gt;判断&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FibConstexprIf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[](){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FibConstexprIf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FibConstexprIf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//FibConstexprIf&amp;lt;30&amp;gt;::value
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;附带的一个小技巧是，通过显示地调用传入的lambda表达式来给一个static变量赋值，因为函数内部的操作全部是经由编译器运算完成的，最终效果是编译器可以无缝地将在编译器计算完成。&lt;/p&gt;

&lt;p&gt;这个简单的算法逻辑上的操作大概是这样&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;根据传入的参数30,生成FibConstexprIf&amp;lt;30&amp;gt;::value&lt;/li&gt;
  &lt;li&gt;生成一个临时的lambda函数，并即使调用，在函数执行中
    &lt;ol&gt;
      &lt;li&gt;比较模板参数值，如果小于等于１，则直接返回自身&lt;/li&gt;
      &lt;li&gt;否则需要实例化两个新的结构(&lt;strong&gt;递归步骤&lt;/strong&gt;),这里对应是FibConstexprIf&amp;lt;29&amp;gt;和FibConstexprIf&amp;lt;28&amp;gt;&lt;/li&gt;
      &lt;li&gt;计算求得两者的value变量，然后相加返回&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然这个算法也是递归的，这里我们需要关心模板元函数生成过程中，第二步里面的第二小步是否会生成&lt;strong&gt;结构体定义&lt;/strong&gt;，引起目标可执行文件的膨胀。
我们可以用如下的命令来检验之&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nm &amp;lt;exe&amp;gt; | c++filt | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;FibConstexprIf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;好在编译器比较完美地去掉了所有这些中间符号，给我们返回了实际计算得到的值。看起来因为这里的结构体是空结构并且只有一个静态变量声明，编译器可以&lt;strong&gt;自动记忆对应的中间计算的模板元值&lt;/strong&gt;，
并且可以&lt;strong&gt;自动地内联lambda函数的定义&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;另一种形式的探索&quot;&gt;另一种形式的探索&lt;/h4&gt;
&lt;p&gt;如果我们想采用一种更直接的方式，直接让&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr if&lt;/code&gt;这一特性应用到参数上，而不适用结构体的静态成员这一常见的模板元技巧而直接采用普通函数定义，可以得到如下的形式&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;/// fib&amp;lt;30&amp;gt;()
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这一形式能工作的原因是我们用递归调用自身的方式加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr if&lt;/code&gt;判断来终止递归，思路和最初的运行期动态计算的思路一样。
可惜当我们再次检查生成的目标可执行文件的时候，发现&lt;strong&gt;可执行文件明显增大&lt;/strong&gt;了不少。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nm&lt;/code&gt;命令查看生成的符号表（当然需要用c++filt做demangle处理）会找到如下的定义&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0000000000000d15 W auto fib&amp;lt;30&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000cf7 W auto fib&amp;lt;29&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000cd9 W auto fib&amp;lt;28&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000cbb W auto fib&amp;lt;27&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c9d W auto fib&amp;lt;26&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c7f W auto fib&amp;lt;25&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c61 W auto fib&amp;lt;24&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c43 W auto fib&amp;lt;23&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c25 W auto fib&amp;lt;22&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000c07 W auto fib&amp;lt;21&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000be9 W auto fib&amp;lt;20&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000bcb W auto fib&amp;lt;19&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000bad W auto fib&amp;lt;18&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000b8f W auto fib&amp;lt;17&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000b71 W auto fib&amp;lt;16&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000b53 W auto fib&amp;lt;15&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000b35 W auto fib&amp;lt;14&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000b17 W auto fib&amp;lt;13&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000af9 W auto fib&amp;lt;12&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000adb W auto fib&amp;lt;11&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000abd W auto fib&amp;lt;10&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a9f W auto fib&amp;lt;9&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a81 W auto fib&amp;lt;8&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a63 W auto fib&amp;lt;7&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a45 W auto fib&amp;lt;6&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a27 W auto fib&amp;lt;5&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
0000000000000a09 W auto fib&amp;lt;4&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
00000000000009eb W auto fib&amp;lt;3&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
00000000000009cd W auto fib&amp;lt;2&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
00000000000009c2 W auto fib&amp;lt;0&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
00000000000009b7 W auto fib&amp;lt;1&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然这种用法虽然看起来更加自然，&lt;strong&gt;编译器却无法自动地替我们内联这些中间状态&lt;/strong&gt;的函数。&lt;/p&gt;

&lt;h3 id=&quot;新的语言特性和函数签名&quot;&gt;新的语言特性和函数签名&lt;/h3&gt;
&lt;p&gt;从签名的例子输出我们发现这些中间函数的签名中间多了个&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;,从编译器实现角度来看，C++11扩展用法中的&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;关键字要求编译器自己做类型推到，而目前的&lt;strong&gt;编译器实现却毫不犹豫地将auto加到了函数签名前面&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;更一般地看，如下的代码&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello}, string{&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;world&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;});&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;    cout &amp;lt;&amp;lt; add2(string{&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;}, string{&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;world&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;});&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;两个地方编译器为我们实例化的函数签名如下(可以很方便地从nm命令输出来检查)&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::string add1(std::string, std::string)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;auto add2&amp;lt;std::string&amp;gt;(std::string, std::string)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;sfinae和enable_if_t&quot;&gt;SFINAE和&lt;code class=&quot;highlighter-rouge&quot;&gt;enable_if_t&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;模板元编程会大量地使用SFINAE技巧来利用编译器选择函数重载过程中遇到不匹配的重载会跳过寻找下一个可能的匹配这一事实，来提供多个针对不同类型的模板实现，提供编译器的分支运算。
较新的C++标准则显示地引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;enable_if&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;enable_if_t&lt;/code&gt;来简化编写SFINAE函数的负担。&lt;/p&gt;

&lt;p&gt;可惜的时候&lt;strong&gt;这种简化并不是特别彻底，起码函数的签名中还是带上了&lt;/strong&gt;这些痕迹；考虑如下的例子:&lt;/p&gt;

&lt;p&gt;对于一个普通的模板元函数处理&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;processing &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果我们想加上类型判断，让对应的处理仅仅使用于非空类型，那么可以写作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable_if_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_same&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processIf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;processingif &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更进一步地，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;static_assert&lt;/code&gt;技巧来做类型检查，但是不显示地使用SFINAE,则可以写作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processIf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static_assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_same&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;processWithAssert...&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果我们触发上面的函数调用，然后就可以检查编译器实际生成的函数签名&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(){
    auto test = string{&quot;test&quot;};
    process(test);

    processIf(test);
    processIf1(test);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于同样的逻辑实现，编译器生成的函数调用分别是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;第一个版本对应的为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::string process(std::string)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第二个版本对应的签名比较复杂，是&lt;code class=&quot;highlighter-rouge&quot;&gt;std::enable_if&amp;lt;!std::is_same&amp;lt;std::string, void&amp;gt;::value, std::string&amp;gt;::type processIf(std::string)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;第三个版本和第一个版本相比，仅仅加上了&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;的前缀和类型信息：&lt;code class=&quot;highlighter-rouge&quot;&gt;auto processIf&amp;lt;std::string&amp;gt;(std::string)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此我们应该多利用新的语言特性，优先选择用&lt;code class=&quot;highlighter-rouge&quot;&gt;static_assert&lt;/code&gt;做类型判断，而逐渐减少使用&lt;code class=&quot;highlighter-rouge&quot;&gt;std::enable_if_t&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;##　优化一个自定义的Tuple类
&lt;code class=&quot;highlighter-rouge&quot;&gt;Tuple&lt;/code&gt;数据结构是一个非常简单的数据聚集结构，很多讲述现代模板元编程的书籍文章都会拿它做举例；在现代的编程语言中也非常常见；
其概念非常容易理解，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;就是一堆有序的类型各异的数据的集合，我们可以用索引的方式访问某个元素，对它进行赋值。&lt;/p&gt;

&lt;p&gt;因为元素的类型可能各不相同，因此这是一个非常适合用模板元编程技巧来表达的数据结构的例子，当然另外一个因素是我们想看下怎么样能简化它的开销，包括运行时的开销和&lt;strong&gt;编译器生成目标代码时候中间数据表达&lt;/strong&gt;的开销。&lt;/p&gt;

&lt;h3 id=&quot;最简单的形式&quot;&gt;最简单的形式&lt;/h3&gt;
&lt;p&gt;实现tuple最简单的形式是采用递归包含的方式来定义，代码如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里我们先定义了一个泛化版本的携带任意多个参数的类型，然后再逐步特化&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;带有一个类型参数的类，仅仅只有一个唯一的元素，并明明为&lt;code class=&quot;highlighter-rouge&quot;&gt;first&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;携带两个以上参数的类型，它除了第一一个&lt;code class=&quot;highlighter-rouge&quot;&gt;firt&lt;/code&gt;外，还内嵌了一个剩余元素的数据成员，注意两者的类型不相同&lt;/li&gt;
  &lt;li&gt;我们需要一个辅助的类来访问特定的元素实现&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;getter实现&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Getter&lt;/code&gt;实现&lt;/h4&gt;
&lt;p&gt;使用类似的技巧，辅助类可以实现如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoreN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoreN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它的两个模板参数第一个制定对应的下表索引，第二个则对应该下标对应的元素类型。
泛化的实现采用&lt;strong&gt;递归的思路依次减小下标，并访问内嵌的第二个元素对应的tuple&lt;/strong&gt;,而特化的版本则对应为下标是0的情况，此时访问的其实是最后一个元素，直接返回对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;first&lt;/code&gt;元素即可。&lt;/p&gt;

&lt;h5 id=&quot;实现一个get函数&quot;&gt;实现一个&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数&lt;/h5&gt;
&lt;p&gt;显然上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Getter&lt;/code&gt;类很不好用，因为我们需要每次都指定下标对应的类型，这样非常容易出错并且出错的时候，编译器给出的&lt;strong&gt;诊断信息明显不足或者不好理解&lt;/strong&gt;。
为了摆脱这种窘境，我们可以采用稍微有点作弊的手法定义一个封装函数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple_element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple_element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里之所以说有点作弊，是因为我们无法得知具体的参数N对应的是什么类型，不得已我们必须借助标准库提供的类型定义，用&lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple_element&amp;lt;N, std::tuple&amp;lt;More...&amp;gt;&amp;gt;::type&lt;/code&gt;的方式来计算返回值的类型。&lt;/p&gt;

&lt;h4 id=&quot;代码生成的开销&quot;&gt;代码生成的开销&lt;/h4&gt;
&lt;p&gt;当然这个不是我们最终的目标，因为稍微检查一下就会发现这个实现会引起编译器代码生成上的急剧膨胀。
假设我们有如下的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testMyTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;somthing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;检查符号表会发现，简单的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&amp;lt;4&amp;gt;&lt;/code&gt;操作会引起连锁反应，生成如下的符号&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  cmake-build-debug git:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ✗ nm myTuple|c++filt | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;MyTuple | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;Getter | cut &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f2-100&lt;/span&gt; | sed &lt;span class=&quot;s2&quot;&gt;&quot;s/__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;/string/gp&quot;&lt;/span&gt; | uniq    
W bool&amp;amp; Getter&amp;lt;0ul, bool&amp;gt;::get&amp;lt;bool, std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;bool, std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W char&amp;amp; Getter&amp;lt;0ul, char&amp;gt;::get&amp;lt;char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W double&amp;amp; Getter&amp;lt;0ul, double&amp;gt;::get&amp;lt;double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W int&amp;amp; Getter&amp;lt;0ul, int&amp;gt;::get&amp;lt;int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W std::string&amp;amp; Getter&amp;lt;0ul, std::string &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;::get&amp;lt;std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W char&amp;amp; Getter&amp;lt;1ul, char&amp;gt;::get&amp;lt;int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W double&amp;amp; Getter&amp;lt;1ul, double&amp;gt;::get&amp;lt;char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W int&amp;amp; Getter&amp;lt;1ul, int&amp;gt;::get&amp;lt;std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W std::string&amp;amp; Getter&amp;lt;1ul, std::string &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;::get&amp;lt;bool, std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;bool, std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W char&amp;amp; Getter&amp;lt;2ul, char&amp;gt;::get&amp;lt;std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W double&amp;amp; Getter&amp;lt;2ul, double&amp;gt;::get&amp;lt;int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W int&amp;amp; Getter&amp;lt;2ul, int&amp;gt;::get&amp;lt;bool, std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;bool, std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W char&amp;amp; Getter&amp;lt;3ul, char&amp;gt;::get&amp;lt;bool, std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;bool, std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W double&amp;amp; Getter&amp;lt;3ul, double&amp;gt;::get&amp;lt;std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
W double&amp;amp; Getter&amp;lt;4ul, double&amp;gt;::get&amp;lt;bool, std::string, int, char, double&amp;gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MyTuple&amp;lt;bool, std::string, int, char, double&amp;gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然这里单独是Getter函数就生成了15个之多，因为随着每次N的减小，新的Tuple总是会被生成。
考虑到目标文件中留下的仅仅是唯一类型的函数定义，中间重复的计算并没有包含在内。
对于每一个给定N个类型的Tuple，它同时&lt;strong&gt;还需要生成所有小于N的子Tuple类型内嵌于自身中&lt;/strong&gt;，实际编译器生成的算法的&lt;strong&gt;时间复杂度其实是三次幂指数&lt;/strong&gt;O(N^3)的。&lt;/p&gt;

&lt;h3 id=&quot;采用继承的方式优化&quot;&gt;采用继承的方式优化&lt;/h3&gt;
&lt;p&gt;一种简单的思路是采用继承的方法来优化这个定义，避免嵌套。这里我们定义一个用于被具体类型继承的基类如下；
为防止其&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数被调用，我们将其声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;=delete&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NewTuple&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//serves as a base type only
&lt;/span&gt;    &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的基类其实是一个空元素的Tuple，它本身其实并没有任何意义。&lt;/p&gt;

&lt;h4 id=&quot;逐级继承&quot;&gt;逐级继承&lt;/h4&gt;
&lt;p&gt;基于此，我们让每一个更复杂的Tuple类型从比它少了头部元素的一个维度更低的tuple上去继承。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;get成员函数的实现&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;成员函数的实现&lt;/h5&gt;

&lt;p&gt;为了实现&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数对不同的索引取调用不同的类型，我们需要根据索引值触发对应的类型定义。
好在&lt;code class=&quot;highlighter-rouge&quot;&gt;std::integral_constant&lt;/code&gt;类型提供了&lt;strong&gt;将任何一个类型的某个具体值转换成一个唯一的编译器可以识别的类型的能力&lt;/strong&gt;，即&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::integral_constant&amp;lt;size_t, 1&amp;gt;&lt;/code&gt;表述的是某个特殊的总是取值为1的编译器可识别的唯一类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::integral_constant&amp;lt;size_t, 2&amp;gt;&lt;/code&gt;表述的是取值为2的唯一类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::integral_constant&amp;lt;size_t, 3&amp;gt;&lt;/code&gt;表示的是另外一个类型，它和算数加法没有任何关联&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以利用它将每个整数索引变换成一个具体的类型从而来书写&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它的定义依赖于下面的技巧&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当目前的tuple具有N个元素的时候，其直接基类就有N-1个元素&lt;/li&gt;
  &lt;li&gt;当前类的&lt;code class=&quot;highlighter-rouge&quot;&gt;get(type&amp;lt;N-1&amp;gt; t)&lt;/code&gt;返回的是&lt;strong&gt;当前tuple的头部&lt;/strong&gt;元素，而&lt;strong&gt;比&lt;code class=&quot;highlighter-rouge&quot;&gt;N-1&lt;/code&gt;更小的索引的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数则由这些基类来提供&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;而所有的基类的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数具有不同的参数类型，并且都可以被子类所访问，因为他们都被声明为是&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;use&lt;/code&gt;声明引入了比当前类型少一个元素的直接基类的类型声明。&lt;/p&gt;

&lt;h5 id=&quot;实现全局的get函数&quot;&gt;实现全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数&lt;/h5&gt;
&lt;p&gt;全局函数的实现可以依赖上面的具体类中的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数的组合来实现：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即对当前有M个元素的tuple取第N个元素，等价于访问继承体系中的&lt;strong&gt;参数类型的整数值为&lt;code class=&quot;highlighter-rouge&quot;&gt;M-1-N&lt;/code&gt;的&lt;/strong&gt;某个基类的成员函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;的访问。
这里起关键作用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;std::integral_constant&lt;/code&gt;模板。&lt;/p&gt;

&lt;h4 id=&quot;代码膨胀开销&quot;&gt;代码膨胀开销&lt;/h4&gt;
&lt;p&gt;考虑下面的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testNewTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;somthing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同样检查编译器的生成代码符号可以发现此时的&lt;strong&gt;算法简化为二次幂&lt;/strong&gt;O(N^2)了，因为每一次初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;操作我们仍然需要为它生成每一个基类的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数访问。&lt;/p&gt;

&lt;h4 id=&quot;再看继承手法&quot;&gt;再看继承手法&lt;/h4&gt;
&lt;p&gt;表面上看这里的&lt;strong&gt;模板元定义采用了继承的语法&lt;/strong&gt;，但是这里的继承功能其实是&lt;strong&gt;用的组合而非传统面向对象设计中的继承&lt;/strong&gt;技巧，因为没有任何的虚函数，也没有任何的方法重载。
唯一有一点可能迷人眼的其实是&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;的声明语法，它其实是&lt;strong&gt;通过数值转类型的方法，将每个基类中都定义了一个独一无二的函数&lt;/strong&gt;，然后交给编译器来根据不同的值选择对应的定义。&lt;/p&gt;

&lt;p&gt;如果我们去掉这个继承的障眼法，将层层递进的继承结构给拍平变成完全只有一级的继承，是否可以进一步优化减小编译器的负担呢？&lt;/p&gt;

&lt;h3 id=&quot;采用多继承和浅继承&quot;&gt;采用多继承和浅继承&lt;/h3&gt;
&lt;p&gt;采用这种新的思路，我们需要将单个元素的tuple重新定义为一个叶子节点，然后让复杂的多元素类从它继承而来；即如下的定义&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// Using leaf
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进而我们就可以采用多继承的思路，这里需要使用可变模板的省略技巧&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;explict&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*??? */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后我们发现这里的get没有办法定义，因为基类里面并没有提供这一方法，而由于多继承的关系，我们也不知道如何派发到哪一个叶子节点。&lt;/p&gt;

&lt;p&gt;显然我们需要将&lt;strong&gt;索引信息传递到具体的基类里面，然后再在组合类里面静态派发&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;添加索引&quot;&gt;添加索引&lt;/h4&gt;
&lt;p&gt;可以通过在叶子节点里面添加一个索引类型&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里具体叶子节点实现的get方法其实是返回自己的值定义。&lt;/p&gt;

&lt;p&gt;而子类的具体实现需要合理的派发这个索引：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This is C++17 only
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;和上面的深度继承类似，我们只需要将所有基类的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数引入进来，然后用同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;integral_constant&lt;/code&gt;方法来做类型派发就可以了。&lt;/p&gt;

&lt;h4 id=&quot;封装索引&quot;&gt;封装索引&lt;/h4&gt;
&lt;p&gt;上面的类型定义中带了两个参数，第一个参数是一个索引列表，第二个参数则是实际的类型列表，两者需要保持对应关系(务必要保证&lt;strong&gt;个数和位置是逐一对应的，否则会产生恐怖的编译错误&lt;/strong&gt;)，使用起来有些不方便，比如我们需要用如下的代码来操作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;好在我们可以封装它为一个新的类型&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们就可以简化实际的代码书写&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;进一步简化来分离声明和实现&quot;&gt;进一步简化来分离声明和实现&lt;/h4&gt;
&lt;p&gt;我们可以使用using声明来分离这些index相关的实现细节，然后重命名具体的实现类&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTupleImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NNTupleImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Indexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NNTupleImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_index_sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由此使用者看到的Tuple声明就是一个只有目标类型接口序列的类，而具体的索引相关的操作就被隐藏了。&lt;/p&gt;

&lt;h4 id=&quot;c14的考虑&quot;&gt;C++14的考虑&lt;/h4&gt;
&lt;p&gt;上述的代码中用到了C++17才支持的语法，如果我们要考虑C++14的兼容，可以将&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;写作如下的形式&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;//C++14 version of get
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;甚至可以进一步来简化具体的类型，因为我们可以用传入参数的方法来自动推到之&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get14_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLeaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;integral_constant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为this指针的类型是确定的，那么根据具体的索引值的不同，我们&lt;strong&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;推到得到具体的叶子节点的类型&lt;/strong&gt;，
再调用get就显然去掉了对外暴露的&lt;code class=&quot;highlighter-rouge&quot;&gt;get14_1()&lt;/code&gt;函数声明上的一个类型参数的依赖。&lt;/p&gt;

&lt;h4 id=&quot;去掉子类中的get&quot;&gt;去掉子类中的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;我们甚至可以去掉叶子节点中的get定义，而直接返回&lt;code class=&quot;highlighter-rouge&quot;&gt;value_&lt;/code&gt;，即简化为&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTupleLeaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//.... inside NNTupleImpl
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_leaf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;代码生成情况&quot;&gt;代码生成情况&lt;/h3&gt;
&lt;p&gt;对于第三个版本，假设我们由如下的代码&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testNNTuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NNTuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;something&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get14_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对应的符号表则如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  cmake-build-debug git:(master) ✗ nm myTuple|c++filt | grep NNTuple | cut -d &quot; &quot; -f2-100 | sed &quot;s/__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;/string/gp&quot; | uniq 
T testNNTuple()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::get&amp;lt;0ul&amp;gt;()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::get&amp;lt;1ul&amp;gt;()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::get&amp;lt;2ul&amp;gt;()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::get14&amp;lt;3ul, char&amp;gt;()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::get14_1&amp;lt;4ul&amp;gt;()
W auto&amp;amp; NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::getLeaf&amp;lt;4ul, double&amp;gt;(MyTupleLeaf&amp;lt;4ul, double&amp;gt;*)
W NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::NNTupleImpl()
W NNTupleImpl&amp;lt;std::integer_sequence&amp;lt;unsigned long, 0ul, 1ul, 2ul, 3ul, 4ul&amp;gt;, bool, std::string, int, char, double&amp;gt;::~NNTupleImpl()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显然对每一个索引，它仅仅生成了一个唯一的get函数，其&lt;strong&gt;复杂度终于降低到了最低&lt;/strong&gt;的O(N)。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;模板元和泛型编程是&lt;strong&gt;现代C++语言演进的一个重要方向&lt;/strong&gt;，它用&lt;strong&gt;几乎为零的代价实现了高层的逻辑抽象&lt;/strong&gt;，不幸的是程序员必须付出额外的编译时间较长的代价来达成这一目标，这不得不说是另外一种形式的权衡。
Jorg通过他探索的技巧来降低编译时间的负担，我们可以借助这些技巧来有针对性地优化模板元代码，让编译器减少生成不必要的代码，从而在编译期也实现零成本抽象的目标。&lt;/p&gt;

&lt;p&gt;同时需要留意的是，这些例子中呈现的行为可能并不适用于所有的C++编译器，有些签名特征甚至是GCC/Clang的实现而MSVC编译器看起来有完全不同的行为。
也许随着编译器的逐步完善和演化，我们会不再需要这些技巧；然而&lt;strong&gt;演练这些技巧对提高我们对静态语言编译期元编程的认识&lt;/strong&gt;也有莫大的好处。&lt;/p&gt;

&lt;p&gt;Rust语言是另外一个秉承零成本抽象使命的静态编译语言，而今天它的泛型代码编译也承受着类似的痛苦和不便，只是不知道是否Rust社区有人发掘过类似的技巧来提升编译速度和减小模板文件体积?&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="cpp" /><category term="design" /><category term="language" /><category term="engineering" /><summary type="html">新的C++语言标准的演进越来越强调静态编译（即运行期计算）的优势，因为这一发展方向无疑更贴合现代的C++语言Zero Cost Abstraction的目标； 可惜这样做有个非常明显的副作用就是给编译器带来了巨大的挑战，乃至于稍微复杂一点的项目也动辄需要数个小时才能编译完成。</summary></entry><entry><title type="html">微服务开发：C++语言是否真的不适用？</title><link href="https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp/" rel="alternate" type="text/html" title="微服务开发：C++语言是否真的不适用？" /><published>2019-10-01T00:00:00+08:00</published><updated>2019-10-01T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/10/01/microservice-with-cpp/">&lt;p&gt;微服务架构模式是当今炙手可热的企业软件架构范式，经过最近几年的广泛的讨论和优缺点争辩之后已经随着
&lt;a href=&quot;//post/2018/04/26/cloud-native/&quot;&gt;云原生架构&lt;/a&gt;　的逐渐火热而日益呈现星火燎原之势。
抛开这些争论不谈，假设我们需要实现一个微服务架构的服务，是否&lt;strong&gt;该用&lt;/strong&gt;C++语言或者&lt;strong&gt;是否能用&lt;/strong&gt;C++语言呢？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;乍一看似乎这个问题没有什么深入探讨的必要，因为&lt;strong&gt;微服务开发本身是编程语言中立&lt;/strong&gt;的，它本身倡导的思想就是用尽量和具体语言无关的技术来解耦业务复杂性，通过智能的API来串联各个可以分布式开发的服务单元。
然而一个不容忽视的现实是，很多谈论微服务开发的书籍或者博客文章&lt;strong&gt;要么不谈落地仅仅谈理论&lt;/strong&gt;（也许这样的贩卖理论的书籍大多多乏味至极没有多少营养）；
要么谈到的时候也是无外乎用流行的几个大的技术栈&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Java 生态圈的基于JVM的技术，使用Spring Boot/Spring Cloud等一些&lt;strong&gt;现成的服务&lt;/strong&gt;，或者稍微时髦一些的会用到Scala或者Kotlin来实现新潮的&lt;strong&gt;函数式编程乃至流计算技巧&lt;/strong&gt;或者&lt;strong&gt;事件驱动&lt;/strong&gt;机制&lt;/li&gt;
  &lt;li&gt;新生代的Golang技术，这个在&lt;strong&gt;特别强调Cloud的部署环境中&lt;/strong&gt;讨论的格外多一些，因为Golang语言在很多云计算的基础设施项目中有极大的应用&lt;/li&gt;
  &lt;li&gt;还有一些则用流行的NodeJs技术栈来举例，这方面多多少少&lt;strong&gt;得益于NPM这一强大的第三方包管理工具&lt;/strong&gt;所支持起来的庞大的开源软件分发管理系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看起来并没有多少人谈论用C++语言来实现微服务；然后是否是因为C++就不适合来实施微服务？
回答这个问题其实并不难，只要从简单的微服务架构的实现要求来看一下就清楚明了了。&lt;/p&gt;

&lt;h2 id=&quot;微服务实现的技术要求&quot;&gt;微服务实现的技术要求&lt;/h2&gt;

&lt;p&gt;微服务架构的软件系统的最基本思想其实就是&lt;strong&gt;分治和解耦&lt;/strong&gt;；其它的技术需求都可以认为是因此而衍生出来用于解决它所带来的具体问题的。&lt;/p&gt;

&lt;p&gt;因为系统被拆分为多个松耦合的粒度较小的服务，并且服务之间需要能够松耦合，因此每个拆分的服务需要提供和其它服务的通信来协作完成端到端的业务场景。
这样的业务交互是通过某些广泛可用的上层&lt;strong&gt;应用程序编程接口&lt;/strong&gt;来完成的；目前来说这样的接口定义有两种&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;基于HTTP协议的REST风格API，本身是基于存在了二十年以上的HTTP协议来实现的&lt;/li&gt;
  &lt;li&gt;基于Google Protobuf编码的GRPC远程过程调用协议,该协议相对较新，由Google提出&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rest-api&quot;&gt;REST API&lt;/h3&gt;
&lt;p&gt;基于REST风格的API其实要求服务提供方需要按照资源化的风格封装它对外曝露的接口，每一个接口都需要作用域某个资源之上，并且针对该资源提供创建、读取、修改、删除等操作。
这些操作方法通过&lt;strong&gt;遵循既有的HTTP协议的方法动词&lt;/strong&gt;来表达，而实际资源的&lt;strong&gt;内容则通过HTTP消息体&lt;/strong&gt;来传递和交换。&lt;/p&gt;

&lt;p&gt;实际的资源内容的定义和校验则&lt;strong&gt;依托现有的JSON或者XML容器来封装&lt;/strong&gt;；API的请求和相应中可以依据需要来提供或者返回具体资源负载；这些资源的定义本身用OpenAPI来定义，客户端和服务端都可以根据这一独立于代码实现的API定义规范来解析和处理。&lt;/p&gt;

&lt;p&gt;当然在比较高级的基于HATEOS的用法中，实际消息中封装的资源可能会按照媒体内容互相关联的方式来组织，
使得客户端可以无需在代码中写死资源的URI，而是通过一次请求关联资源并根据返回的链接来动态发现的方式来降低服务之间的耦合。&lt;/p&gt;

&lt;p&gt;HTTP协议的实现自然是和语言无关的技术，而JSON的封装对具有几十年历史积淀的C++语言来说也完全不是问题。
至于OpenAPI规范的定义更加是和语言无关的技术。&lt;/p&gt;

&lt;h3 id=&quot;grpc&quot;&gt;GRPC&lt;/h3&gt;
&lt;p&gt;GRPC是相对比较新一点的服务之间的API调用接口实现方式；详细的探讨可以参考&lt;a href=&quot;//post/2018/04/26/cloud-native/&quot;&gt;这篇文字&lt;/a&gt;。
从上层架构上来看，GRPC的设计思路可能更加&lt;strong&gt;契合传统的程序员的思路&lt;/strong&gt;，它的直接思路其实就是要求各个服务之间通过远程过程调用的方式来实现相互交互。&lt;/p&gt;

&lt;p&gt;GRPC和传统的基于方法调用的RCP所不同的地方在于它&lt;strong&gt;在传统的请求／响应模型之上还提供了客户端和服务端之间的全双工的数据流推送&lt;/strong&gt;，因而它需要和HTTP/2在一起才能配合完好。
在这种接口范式下，服务提供者需要按照Proto Buffer的语法规范定义自己的服务声明定义文件，然后该文件会被protoc编译器检查解析并生成样板代码。&lt;/p&gt;

&lt;p&gt;基于GRPC技术实现的服务&lt;strong&gt;需要根据上述的服务样板代码来二次开发，扩展实现自己的业务逻辑&lt;/strong&gt;；客户端则可以响应的使用生成的客户端样板代码来发起远程调用请求。&lt;/p&gt;

&lt;h3 id=&quot;这些技术本身有强烈的语言偏爱吗&quot;&gt;这些技术本身有强烈的语言偏爱吗？&lt;/h3&gt;

&lt;p&gt;基于这些讨论，单纯看微服务落地实现的技术栈要求，它并&lt;strong&gt;没有特意对编程语言提出很硬的约束&lt;/strong&gt;，即理论上任何能够完成中等复杂度任务的编程语言都可以来实现微服务。
无论是REST/JSON还是GRPC/ProtoBuffer，它们本身都具有多语言支持的能力，尤其是GRPC自带的代码生成工具有个很微妙的限制就是&lt;strong&gt;不同的编程语言的支持能力是不同的，但是C++语言是功能最完善的&lt;/strong&gt;之一。&lt;/p&gt;

&lt;p&gt;显然我们可以在需要的情况下，豪不犹豫地选用C++语言来实现微服务，只要我们弄清楚了我们确实需要使用C++语言来实现微服务。&lt;/p&gt;

&lt;h2 id=&quot;什么时候需要使用c来实现&quot;&gt;什么时候需要使用C++来实现&lt;/h2&gt;
&lt;p&gt;回答这样的问题并没有一个放之四海而皆准的经验，因为微服务架构的其中一个关键要素就是需要考虑到具体的开发团队的因素，以及业务领域问题的具体需求。
很多时候这样的决策和选择需要不少深思熟虑和权衡才能找到最适合自己情况的那个选项。&lt;/p&gt;

&lt;h3 id=&quot;业务场景需求&quot;&gt;业务场景需求&lt;/h3&gt;
&lt;p&gt;从业务场景需求的角度来说，可能&lt;strong&gt;性能需求以及扩展性需求&lt;/strong&gt;是需要被着重考虑的。对于CPU密集型的微服务来说，选用一个以性能见长的编程语言可能是一个明智的选择，
这方面正是C++语言比较擅长的地方，也许只有Rust语言可以与之比肩，但是C++长期的历史积淀和成熟稳定的特性短期之内Rust还无法匹及。&lt;/p&gt;

&lt;h3 id=&quot;开发团队技能&quot;&gt;开发团队技能&lt;/h3&gt;
&lt;p&gt;从开发团队的方面来考虑，则必须要认识到&lt;strong&gt;C++语言对成员的编程水平总体上还是要求比较高&lt;/strong&gt;，尽管现代的C++语言标准一直在努力尝试往简化语言门槛的方向迈进。
如果既有的团队有很好的C/C++语言背景和丰富的系统编程知识，使用C++语言来做微服务是很自然的选择。
反之期望一个没有什么C/C++背景的团队来临时抱佛脚开发C++为主要语言的微服务很容易给项目的按序推进带来巨大的挑战。&lt;/p&gt;

&lt;h2 id=&quot;技术和工具&quot;&gt;技术和工具&lt;/h2&gt;

&lt;p&gt;假设这些因素我们都以及考虑周详，具体到实现上，是否就万事大吉可以马上撸起袖子开工写代码了呢？
&lt;strong&gt;不幸的是事情并没有那么简单&lt;/strong&gt;，稍微详细看一下这些技术栈就清楚了。
下面假设我们决定采用随处可见的流行的REST API + JSON的方式来实现微服务。&lt;/p&gt;

&lt;h3 id=&quot;rest框架&quot;&gt;REST框架&lt;/h3&gt;
&lt;p&gt;如前所述，REST技术栈本质上是基于HTTP协议之上的一些二次发挥；而选择C++实现的时候第一个现实的因素是&lt;strong&gt;C++标准库里面并没有提供HTTP协议的实现&lt;/strong&gt;，
这也是C++生态系统目前比较大的一个问题：标准库里面的东西实在是太少了，这里面一个很大的原因应该是能放到标准库里面的东西必须要经过委员会的仔细审查，加上过去近四十年的各种技术积累和包袱，加入新的库总要面临重口难调的窘境。
甚至于在Reddit上还有这么帖子就是在探讨&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/7ghn75/defactoindustry_standard_restful_serverlibraryapi/&quot;&gt;是否有一个事实标准的REST框架实现&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h4&gt;
&lt;p&gt;如果是将标准稍微放开一些，或者可以访问比较新的boost库，那么&lt;a href=&quot;https://www.boost.org/doc/libs/1_71_0/libs/beast/doc/html/index.html&quot;&gt;Beast&lt;/a&gt; 可以算一个比较冒险的选择，因为它也是在1.66版本才被加入进去。
要是你所在的公司或者组织由其它方面的考虑停留在了一个比较老的版本的Boost上，那么引入这么一个库就显得比较麻烦。&lt;/p&gt;

&lt;p&gt;Beast的主要特点如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;保持了header only的方式，最小化编译和链接依赖；副作用就是冗长模板元编译开销&lt;/li&gt;
  &lt;li&gt;采用Boost.asio的&lt;strong&gt;异步网络编程&lt;/strong&gt;模型和协程来实现高性能和高并发，熟悉这些库的话上手会比较容易&lt;/li&gt;
  &lt;li&gt;库本身提供的&lt;strong&gt;抽象层次比较高&lt;/strong&gt;，实际上手可能需要写比较多的代码，或者需要二次封装&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文档并不是很完备&lt;/strong&gt;，也许需要一些时间才能更加成熟&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rest-sdk&quot;&gt;REST SDK&lt;/h4&gt;
&lt;p&gt;微软平台上的C++程序员可能会更偏爱微软出品的&lt;a href=&quot;https://github.com/microsoft/cpprestsdk&quot;&gt;开源在GitHub上的REST SDK&lt;/a&gt;，同样的它也采用了异步编程模型。&lt;/p&gt;

&lt;p&gt;虽然是一个微软官方提供的开源库，它本身还是可以在多个平台上运行的，并且提供了流行Linux环境的二级制发布包，如果没有交叉编译的需求，可以直接下载安装。&lt;/p&gt;

&lt;h4 id=&quot;pistache-framework&quot;&gt;Pistache Framework&lt;/h4&gt;
&lt;p&gt;这是一个功能相当完善并且性能也很出色的REST框架，它本身的特色是&lt;strong&gt;能够和swagger的代码生成工具无缝结合&lt;/strong&gt;，可以用open API的声明来生成模型代码，极大简化了用户的编码负担。&lt;/p&gt;

&lt;p&gt;Pistache使用epoll机制来完成高性能的传输层，并提供了&lt;strong&gt;流式的API给用户使用&lt;/strong&gt;，用户可以在REST方法回调中使用异步API将内容写入流，就像操作一个标准输入输出流那样方便。&lt;/p&gt;

&lt;p&gt;但是由于这个&lt;strong&gt;epoll机制和核心的部分耦合比较紧密&lt;/strong&gt;，并且没有很好的办法来用epoll来模拟IOCP机制，因此如果需要在Windows上（甚至符合POSIX的Cygwin环境也是一样）使用该库则会碰上&lt;strong&gt;跨平台可移植性的难题&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;性能评估&quot;&gt;性能评估&lt;/h4&gt;
&lt;p&gt;C++程序的一个很大的关注点就是性能，
&lt;a href=&quot;https://blog.binaryspaceship.com/2017/cpp-rest-api-frameworks-benchmark/&quot;&gt;这篇博文&lt;/a&gt;
提供了一个性能评估数据，总体而言&lt;strong&gt;Pistache的性能明显占据上风&lt;/strong&gt;。
可惜这个对比的报告时间有些老，好在代码是开源的，拉取三个仓库自己的最新版本在本地虚拟机上跑一下，可以得到如下的结果：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;框架&lt;/th&gt;
      &lt;th&gt;98%请求完成的时间(ms)&lt;/th&gt;
      &lt;th&gt;每秒处理的请求数&lt;/th&gt;
      &lt;th&gt;示例代码的行数&lt;/th&gt;
      &lt;th&gt;Github星标&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cpprestsdk/default&lt;/td&gt;
      &lt;td&gt;107&lt;/td&gt;
      &lt;td&gt;12.23&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;4478&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cpprestsdk/RapidJSON&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;14.28&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;4478&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;restbed&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;32.54&lt;/td&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;1078&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pistache&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;182.85&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;1683&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;此外，因为最新的库代码以及发生了变更，因此原来repo中的&lt;strong&gt;示例代码或者CMakeLists.txt文件需要做些微调&lt;/strong&gt;，基本上按照对应项目的最新文档适度改动即可。我自己的虚拟机只分了２个CPU核，所以绝对数据比原作者的要低。&lt;/p&gt;

&lt;p&gt;稍微有点奇怪的是，从项目的流行度上来看，来自微软的开源项目cpprestsdk表现的更加热门一些，无论是星标数还是fork数字都非常亮眼；
但是这里的性能比较却是三者之中最差的一个，是否和微软的自带明星光环有关有待进一步详查。&lt;/p&gt;

&lt;h3 id=&quot;json解析和处理&quot;&gt;JSON解析和处理&lt;/h3&gt;

&lt;p&gt;传统的REST微服务实现用JSON来编码消息中的资源内容，因而&lt;strong&gt;JSON解析能力&lt;/strong&gt;是实现REST服务的一个重要的考量因素。
从使用的角度来看，JSON表述的文档结构常常可以简单地看作是一颗树结构，里面的具体节点元素只要符合
&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc8259/&quot;&gt;RFC8259规范要求&lt;/a&gt;(更老一点的版本是&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc4627/&quot;&gt;RFC4627&lt;/a&gt;)
就可以了。&lt;/p&gt;

&lt;p&gt;本质上来说，JSON的解析就是文本文件的解析，其语法规则比较简单直接，自己手工实现一个满足自己使用场景的也并非难事。
只是考虑到性能、跨平台、编码、代码大小等各种各样的要素带来的复杂性，直接&lt;strong&gt;复用已有的库&lt;/strong&gt;是更为明智的做法。&lt;/p&gt;

&lt;h3 id=&quot;开源实现比较&quot;&gt;开源实现比较&lt;/h3&gt;

&lt;p&gt;JSON处理的开源库非常多，目前就职于腾讯的&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc4627/&quot;&gt;MiloYip&lt;/a&gt;做了一个很好的比较总结，开源在&lt;a href=&quot;https://github.com/miloyip/nativejson-benchmark&quot;&gt;GitHub&lt;/a&gt;这里，
我们直接拿来参考就是了。&lt;/p&gt;

&lt;h4 id=&quot;比较对象&quot;&gt;比较对象&lt;/h4&gt;
&lt;p&gt;作者从如下几个方面考察了常见的数十个JSON库&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能兼容性&lt;/strong&gt;，包括校验，双精度数字的解析处理，字符串解析和压缩JSON文档的序列化反序列化；这在&lt;strong&gt;跨语言的微服务场景下尤为重要&lt;/strong&gt;，因为客户端可能是用另外一种完全不同的编程语言开发的&lt;/li&gt;
  &lt;li&gt;各种操作下的性能表现，包含
    &lt;ul&gt;
      &lt;li&gt;运行时间（越短越好）&lt;/li&gt;
      &lt;li&gt;处理过程中的内存占用&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;最大内存&lt;/strong&gt;占用情况（越少越好）&lt;/li&gt;
      &lt;li&gt;内存分配器调用次数多少，经验表明很多时候CPU的耗费时间有很大一部分花费在不必要的内存分配和释放操作上。&lt;strong&gt;更少的内存分配操作往往意味着更好的性能&lt;/strong&gt;，即便这个结论并不是绝对准确，否则也不会有各种各样优化小对象分配的内存分配器出现了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可执行文件的大小 - 在微服务的容器化场景下，这也是一个很重要的要素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;比较结果&quot;&gt;比较结果&lt;/h4&gt;
&lt;p&gt;各项的比较结果如下 - 因为&lt;strong&gt;JSONCPP是一个很早就出现并且得到广泛使用的JSON解析库&lt;/strong&gt;，这里将其单独放在一列做比较。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;比较项目&lt;/th&gt;
      &lt;th&gt;最高得分项目&lt;/th&gt;
      &lt;th&gt;第二名得分项目&lt;/th&gt;
      &lt;th&gt;第三名得分项目&lt;/th&gt;
      &lt;th&gt;jsoncpp&lt;/th&gt;
      &lt;th&gt;说明　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;功能兼容性　　&lt;/td&gt;
      &lt;td&gt;taocpp/json(100%)&lt;/td&gt;
      &lt;td&gt;RapidJSON_pre(100%)&lt;/td&gt;
      &lt;td&gt;configuru(99%)&lt;/td&gt;
      &lt;td&gt;85%&lt;/td&gt;
      &lt;td&gt;前三基本达到&lt;strong&gt;100%&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;解析时间&lt;/td&gt;
      &lt;td&gt;RapidJSON(8ms)&lt;/td&gt;
      &lt;td&gt;gason(8ms)&lt;/td&gt;
      &lt;td&gt;json4c(9ms)&lt;/td&gt;
      &lt;td&gt;166ms&lt;/td&gt;
      &lt;td&gt;前三和后面的相差巨大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存占用　　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(4.8MB)&lt;/td&gt;
      &lt;td&gt;strdup(6.6MB)&lt;/td&gt;
      &lt;td&gt;Jvar(7.56MB)&lt;/td&gt;
      &lt;td&gt;24.56MB&lt;/td&gt;
      &lt;td&gt;Qt的数据不准确&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;序列化时间　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(11ms)&lt;/td&gt;
      &lt;td&gt;ujson(25ms)&lt;/td&gt;
      &lt;td&gt;jzon(28ms)&lt;/td&gt;
      &lt;td&gt;94ms&lt;/td&gt;
      &lt;td&gt;部分纯C实现表现较好&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;美化输出　　　&lt;/td&gt;
      &lt;td&gt;RapidJSON(17ms)&lt;/td&gt;
      &lt;td&gt;ujson(29ms)&lt;/td&gt;
      &lt;td&gt;SchederdomJson(29ms)&lt;/td&gt;
      &lt;td&gt;NA&lt;/td&gt;
      &lt;td&gt;jsoncpp未提供　　　　&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可执行文件大小&lt;/td&gt;
      &lt;td&gt;pjson(15KB)&lt;/td&gt;
      &lt;td&gt;Qt(18KB)&lt;/td&gt;
      &lt;td&gt;RESTSDK(18.3KB)&lt;/td&gt;
      &lt;td&gt;243KB&lt;/td&gt;
      &lt;td&gt;C实现毫无疑问靠前，RapidJSON31KB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从结果来看，RapidJSON在多项比较重都名列前茅，称之为&lt;strong&gt;性能最好功能最全的JSON库&lt;/strong&gt;也毫不为过。&lt;/p&gt;

&lt;p&gt;需要额外指出的是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;RapidJSON提供了几个版本变种，默认情况下的版本提供了93%的标准兼容性，却能够在其它性能比拼中拔得头筹。
提供完全兼容的版本&lt;strong&gt;性能稍差一些或者毫无损失但在各项比较中依然排在前列&lt;/strong&gt;，这里没有列出它的其它变种的排名情况而是将它们合并在一起展示。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C版本的实现并没有特别明显的优势&lt;/strong&gt;，除了最后一向需要考虑可执行文件大小的场合，而C++的实现并没有落后太多。
这一项里RapidJSON的得分在C++里面居于第六，绝对大小依然远好于jsoncpp&lt;/li&gt;
  &lt;li&gt;某些REST库自身也提供了自己的JSON实现，比如来自&lt;strong&gt;微软的REST SDK，只是本身并不特别出彩&lt;/strong&gt;，在上述的REST比较重以及可以看到一些端倪，这里不赘述&lt;/li&gt;
  &lt;li&gt;RapidJSON的最初实现也来自于这个benchmark的作者，只是两三年前以及被重命名&lt;strong&gt;成为腾讯开源库的一部分&lt;/strong&gt;；目前在GitHub上有超过8000个👍&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于微服务的架构设计正在席卷几乎所有的软件开发组织，形形色色的开源的REST和JSON框架使得能否用C++来开发微服务这一简单问题的&lt;strong&gt;答案不言自明&lt;/strong&gt;。
在业务场景需要、团队技术能力匹配的情况下，使用上述的这些工具和框架库实现高性能的微服务不应该有任何障碍。
腾讯开源的FastJSON给了我们不少的惊喜，这也许是国内的大技术公司给开源社区的巨大贡献。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="cpp" /><category term="design" /><category term="tools" /><summary type="html">微服务架构模式是当今炙手可热的企业软件架构范式，经过最近几年的广泛的讨论和优缺点争辩之后已经随着 云原生架构　的逐渐火热而日益呈现星火燎原之势。 抛开这些争论不谈，假设我们需要实现一个微服务架构的服务，是否该用C++语言或者是否能用C++语言呢？</summary></entry><entry><title type="html">重学Kubernetes - 读张磊的《深度剖析Kubernetes》</title><link href="https://skyscribe.github.io/post/2019/08/24/learn-kubernetes-again/" rel="alternate" type="text/html" title="重学Kubernetes - 读张磊的《深度剖析Kubernetes》" /><published>2019-08-24T00:00:00+08:00</published><updated>2019-08-24T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/08/24/learn-kubernetes-again</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/08/24/learn-kubernetes-again/">&lt;p&gt;云计算从十年前的风起云涌却叫好不叫座的局面慢慢地变成了无人刻意提起的境地，这一切的幕后游戏规则改变者某种程度上来说
都是因为Kubernetes这个伟大的开源项目以及依托于它的云原生运动
(&lt;a href=&quot;//post/2018/04/26/cloud-native/&quot;&gt;参考前文&lt;/a&gt;))
的蓬勃发展而激发。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;购买专栏的缘起&quot;&gt;购买专栏的缘起&lt;/h2&gt;

&lt;p&gt;极客时间也在刚刚开始大规模推广不久就推出了自身Kubernetes贡献者张磊的《深度剖析Kubernetes》课程；作为一个资深付费用户，
我并没有在第一时间购买该课程，一部分原因是&lt;strong&gt;出于谨慎&lt;/strong&gt;(显然之前是过分谨慎了才有遗珠之恨)，一部分原因则是出于人性的懒惰：
总觉得这样的内容应该网上一找一大把，官方文档又这么丰富，为什么还要专门购买？&lt;/p&gt;

&lt;p&gt;然而一次偶然听到的InfoQ大会上张磊做的关于Kubernetes本质和演进的演讲勾起了我内心的兴趣；我不禁想&lt;strong&gt;能够将这个庞大的开源项目做条分缕析、深入浅出地介绍的明明白白的技术人&lt;/strong&gt;开的专栏必然不简单。
于是才又“精明”地收藏了这个专栏并在节日活动的时候果断购入，然后依照自己的节奏慢慢消化吸收。&lt;/p&gt;

&lt;p&gt;原作者的内容分为几个部分来阐述的，这里也就着作者本身的顺序简单地记录下自学过程中的一些重要要素和思考。&lt;/p&gt;

&lt;h2 id=&quot;kuberenetes的背景和容器技术的基本发端&quot;&gt;Kuberenetes的背景和容器技术的基本发端&lt;/h2&gt;
&lt;p&gt;第一个部分是关于历史背景的讲述，这方面的故事在好多地方都流传甚广了。简单来说Kubernetes这个项目其实是&lt;strong&gt;Google内部自己已经做了很多年的分布式系统开发经验&lt;/strong&gt;并经历了多次迭代之后的结晶，开源给整个业界使用的。&lt;/p&gt;

&lt;p&gt;然而这里面有个很&lt;strong&gt;偶然的因素便是Docker这个容器打包项目的流行和壮大&lt;/strong&gt;，因为从Google本身而言，它并没有动力将自己强大的云计算基础设施开放出来给其它的云平台竞争对手使用。
徐飞在他的技术于商业案例解析的专栏中甚至提到，Google一开始可能是藏着掖着故意不开放自己的容器管理技术，
而仅仅开放了GFS、BigTable这些大数据技术，导致开源社区在基于虚拟机的方案上走了很多弯路。&lt;/p&gt;

&lt;p&gt;商业公司上的开源与不开源的抉择其实不太容易为外人所知；但是回顾过去十数年的云计算发展历史，&lt;strong&gt;Kubernetes无疑是站在了正确的赛道&lt;/strong&gt;上。&lt;/p&gt;

&lt;p&gt;###　容器打包技术为什么成为颠覆者
早期的云计算技术其实都是围绕着虚拟机技术而展开的，即便是操作系统层面的虚拟化技术在十几年前就已经出现了。
Docker容器技术的出现初看起来没有太大技术本质上的创新，不过是用分层的文件系统打包应用程序，然后交给一个容器运行时后台去调度和执行。&lt;/p&gt;

&lt;p&gt;它的流行其实是因为软件工程上的便利：传统的方式下软件工程师需要面对的是一系列复杂的软件运行时相关环境，包括采用什么样的操作系统，程序怎么样启动，如何和系统服务／系统调用打交道，如何将软件的价值交付给用户。&lt;/p&gt;

&lt;p&gt;容器技术则提倡&lt;strong&gt;开发者应该专注于业务逻辑本身&lt;/strong&gt;，只需要将自己的应用程序写好就行了，其它怎么运行的事情统统交给容器引擎来完成就行。
这样的思想不光成就了程序员，也成就了一系列服务于云技术底层的技术公司。&lt;/p&gt;

&lt;h3 id=&quot;docker容器技术和其它既有技术的区别&quot;&gt;Docker容器技术和其它既有技术的区别&lt;/h3&gt;
&lt;p&gt;Docker技术虽然脱胎于旧有的容器技术，它本身却和老的基于LXC的容器技术有着显著的区别&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;LXC技术的基本侧重点是提供系统级容器，容器隔离的&lt;strong&gt;沙箱内提供给开发者的是一个看起来像一个完整的操作系统的运行环境&lt;/strong&gt;，可谓麻雀虽小五脏俱全，用户可以像使用一个Linux服务器一样使用这个容器，可以启动多个应用服务，实现服务监控等&lt;/li&gt;
  &lt;li&gt;Docker技术则主要提供应用程序容器，并且提倡&lt;strong&gt;一个容器一个应用程序&lt;/strong&gt;的概念。某种程度上看一个Docker容器就是一个进程；
进程的上下文环境需要保持尽可能的简单，仅仅提供程序运行本身必要的运行时库和可执行文件等；多余的东西可以一概不要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然讨论到Kubernetes和云原生的语境的时候，我们已经很少去刻意关照古老的LXC容器了；
大部分情况下我们&lt;strong&gt;说到容器的时候，基本就是在说应用程序容器&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;容器的本质是对进程的隔离和限制&quot;&gt;容器的本质是对进程的隔离和限制&lt;/h3&gt;
&lt;p&gt;容器技术本身提供的机制是基于内核提供的名字空间namespace和控制组cgroups的概念，它本身的实现也不是完美无缺的；
尤其是我们关心安全的时候，就会发现就所有同一宿主上运行的&lt;strong&gt;容器必须共享内核这一限制就会带来潜在的风险&lt;/strong&gt;；而新型的容器技术可能会弥补这一缺陷。&lt;/p&gt;

&lt;p&gt;由于是&lt;strong&gt;基于系统调用层面的虚拟隔离&lt;/strong&gt;，容器技术有着相比虚拟机高很多的性能。&lt;/p&gt;

&lt;h3 id=&quot;容器镜像格式的本质&quot;&gt;容器镜像格式的本质&lt;/h3&gt;
&lt;p&gt;具体就Docker容器所使用的aufs文件系统来说，其镜像其实是通过&lt;strong&gt;分层的方式来组织的&lt;/strong&gt;，任何改变容器的方法必须要通过修改文件系统的挂载方式来实现。
简单的来说，容器的aufs文件系统通过层层叠加的方式描述软件和它自身的依赖，可以看作是三层组成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;只读层存放一些不希望被程序修改的内容，比如一个busybox环境或者ubuntu文件系统的可执行文件&lt;/li&gt;
  &lt;li&gt;init对应于一些配置文件，类似/etc/等，没有修改的时候为空&lt;/li&gt;
  &lt;li&gt;用户指定的可读写层，用于用户添加自己的内容，但是如果用户删除了某些文件，容器镜像只会将其设置为隐藏而不会真正的删除对应的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于需要依赖于网络环境来交换镜像的应用场景而言，容器应用的&lt;strong&gt;开发者需要力保容器的镜像要能够足够的小&lt;/strong&gt;，并且可以增量编译，因为容器格式本身也是用分层的思路来设计的。
这里一个很重要的点是需要选择一个比较小的基础镜像；而由于aufs的删除隐藏策略，删除一个臃肿的基础镜像里面不用的文件并不会使你的容器文件变小：他们只是变得不可访问了而已。&lt;/p&gt;

&lt;h3 id=&quot;kubernetes承担的角色&quot;&gt;Kubernetes承担的角色&lt;/h3&gt;
&lt;p&gt;容器化的应用开发、测试、部署方式其实对底层的管理和调度平台提出了不少要求，因为一个基于云原生理念开发的微服务系统不可避免需要有很多个容器实例来组成，各种&lt;strong&gt;方方面面的需求最后被用编排这两个词&lt;/strong&gt;来概括，大概包含了下面这些功能&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;镜像管理和分发&lt;/li&gt;
  &lt;li&gt;容器实例的启动、管理和状态监控&lt;/li&gt;
  &lt;li&gt;多个服务实例之间的服务发现、负载均衡、扩展、发布和升级&lt;/li&gt;
  &lt;li&gt;其它高级功能如日志、监控、熔断、限流等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于Google自身&lt;a href=&quot;https://storage.googleapis.com/pub-tools-public-publication-data/pdf/44843.pdf&quot;&gt;从Borg到Omega再到开发Kubernetes系统&lt;/a&gt;
的长期的基础设施虚拟化管理经验(参加前面的&lt;a href=&quot;(//post/2019/07/21/from-borg-to-kubernetes/)&quot;&gt;笔记&lt;/a&gt;)，
Kubernetes项目本身采用了完全基于声明式API的做法来
构建一个极度强调灵活性的基础平台&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;其主要系统都是基于Object来建模的，并且对各种Object提供了丰富的REST API&lt;/li&gt;
  &lt;li&gt;内部各种Object之间使松散耦合的&lt;/li&gt;
  &lt;li&gt;请求改变状态的指令使通过&lt;strong&gt;提交一个Object的目标状态&lt;/strong&gt;给Kubernetes平台来实现的&lt;/li&gt;
  &lt;li&gt;Kubernetes会监控用户提交的请求，&lt;strong&gt;循环调用相应的对象控制器来尝试改变对象的状态&lt;/strong&gt;，然后比较是否满足要求，如果未满足则会继续调度执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes使一个运维工具吗&quot;&gt;Kubernetes使一个运维工具吗？&lt;/h3&gt;
&lt;p&gt;从其API设计上来看，毋宁说它是一个&lt;strong&gt;面向开发者的工具&lt;/strong&gt;而不是一个面向运维人员的平台。
由于其内部各个部分都是面向REST API的，因此使用者需要提供一个对象的目标状态的对象声明文件；
而既有的一些命令行工具都不过是对这一过程的封装。&lt;/p&gt;

&lt;p&gt;因而从运维人员的角度来看，Kubernetes的命令行工具非常难用，因为它本身&lt;strong&gt;不是为完成一个一个具体的管理任务的网络服务运维人员量身打造&lt;/strong&gt;的。&lt;/p&gt;

&lt;h2 id=&quot;集群搭建和部署&quot;&gt;集群搭建和部署&lt;/h2&gt;
&lt;p&gt;这一部分相对比较简单，尽管作者也花了很大力气来介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;kubeadm&lt;/code&gt;这个强大的工具。
其实对于简单学习而言最简单的部署方式是再自己的笔记本或者服务机上安装一个&lt;code class=&quot;highlighter-rouge&quot;&gt;minikube&lt;/code&gt;的环境，模拟一个单节点的最小化的运行环境；
如果需要搭建一个具有多个节点的集群，大抵需要遵循如下的步骤&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;准备节点机器，确认内核版本，网络可达性&lt;/li&gt;
  &lt;li&gt;部署集群的master节点，它上面一般不建议部署应用程序容器，而仅仅用于集群自身的管理和维护&lt;/li&gt;
  &lt;li&gt;部署网络插件，确保各个节点之间可以互相连通&lt;/li&gt;
  &lt;li&gt;部署多个集群的worker节点，这里是真正地跑应用程序容器的地方&lt;/li&gt;
  &lt;li&gt;部署容器存储插件，以便有状态的服务可以访问持久化存储设施&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;容器管理和编排&quot;&gt;容器管理和编排&lt;/h2&gt;
&lt;p&gt;容器的管理和控制是Kubernetes最为核心的功能，也是初步了解Kubernetes最容易卡壳的地方，因为它提出了自身特有的一些抽象的概念。&lt;/p&gt;

&lt;h3 id=&quot;pod&quot;&gt;POD&lt;/h3&gt;
&lt;p&gt;POD是一个不太容易让人理解的概念，它&lt;strong&gt;纯粹是Kubernetes抽象出来的一个概念&lt;/strong&gt;以方便Kubernetes的调度控制器实现复杂的逻辑。
好在我们可以用一个很简单的操作系统中的概念来类比：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果将kubernetes自身看作是操作系统（它的确也是云环境下的操作系统），那么典型的Linux操作系统是由很多个进程组成的&lt;/li&gt;
  &lt;li&gt;Docker容器所运行的程序本质上是一个可运行的进程，上面已经探讨过&lt;/li&gt;
  &lt;li&gt;POD可以看作是逻辑上相关的一个进程组，这些&lt;strong&gt;进程之间相互由比较亲密的关系&lt;/strong&gt;，适合于放在一起做调度；而进程组和进程组之间则关系没有那么紧密
当然这里的类比只是为了便于理解而并不是特别准确。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pod资源管理&quot;&gt;POD资源管理&lt;/h4&gt;
&lt;p&gt;从资源管理的角度来看，POD里面的所有的容器都会&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;共享同一个网络空间，即它们之间的网络默认就是互通的，甚至可以使用Unix　Domain　Socket这样依赖于本地网络的机制。&lt;/li&gt;
  &lt;li&gt;共享同样的磁盘存储，一个容器写入在某个路径的文件，共享同一个POD的其它容器也可以访问&lt;/li&gt;
  &lt;li&gt;享有同样的生存周期，即Kubernetes平台会保证当需要杀掉一个容器的时候，共享同一个POD的其它容器也会被一并杀掉&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;特殊的infra容器&quot;&gt;特殊的Infra容器&lt;/h4&gt;
&lt;p&gt;为了实现上面的资源共享，Kubernetes平台其实提供了一个非常特殊的Infra容器并用它来串起来各个容器。
这个特殊的容器本身是用汇编语言写成的，本身只有100~200KB几乎不占用什么额外的资源。
进而一个POD&lt;strong&gt;生存周期控制和它的进出网络流量都是通过这个基础设施容器&lt;/strong&gt;来实现的。&lt;/p&gt;

&lt;h4 id=&quot;projected-volume投射数据卷&quot;&gt;Projected Volume投射数据卷&lt;/h4&gt;
&lt;p&gt;Kubernetes里和POD紧密相关的一个重要的概念是Project Volume，它本身是&lt;strong&gt;为容器提供预先定义好的数据&lt;/strong&gt;，这样当容器启动的时候，这些数据就可以直接使用了。&lt;/p&gt;

&lt;p&gt;这样的投射数据卷有如下一些类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ConfigMap常常用于保存一些文本的配置数据，里面&lt;strong&gt;不能包含二进制&lt;/strong&gt;数据，一般用来保存非加密数据&lt;/li&gt;
  &lt;li&gt;Secret用于防止加密数据，其数据&lt;strong&gt;本身是放在Kubernetes自身的etcd数据库&lt;/strong&gt;中的，一般放入用户就不能再获取到明文&lt;/li&gt;
  &lt;li&gt;Downward API可以将POD自身的一些信息暴露给容器内部的应用程序使用，比如宿主机名字，IP，POD的名字，IP地址，标签和标记信息等；这些信息必须是容器启动前就可以从POD里面拿到的，不能是动态信息&lt;/li&gt;
  &lt;li&gt;ServiceAccountToken则通过授权的方式允许容器里面的程序访问Kubernetes本身的API Server来获取平台自身的信息；而默认情况下POD里面的容器是无权访问底层平台的API信息的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pod健康检查&quot;&gt;POD健康检查&lt;/h4&gt;
&lt;p&gt;POD自身的运行状态是通过健康检查机制来实现的，&lt;strong&gt;用户需要提供POD健康检查对应的探针&lt;/strong&gt;（可以是一个REST API也可以是一个命令行输出）,
而Kubernetes平台会定期检查这个探针的返回状态来决定POD是否出于正常运行状态。
如果没有定义，则Kubernetes则会根据docker容器的运行命令的结果来判断POD是否出于健康状态。&lt;/p&gt;

&lt;p&gt;如果POD的健康检查返回的是异常状态，默认Kubernetes会尝试再同一个节点上重启该POD；同时这个恢复机制的策略可以通过修改POD的SPEC声明来指定。&lt;/p&gt;

&lt;p&gt;由于POD本身的&lt;strong&gt;自我复机制只能限定在启动的那个节点&lt;/strong&gt;上，万一该节点发生故障，Kubernetes也不能将其移动到另一个节点上；要实现类似的功能，需要采用更为高级的Deployment控制器来完成。&lt;/p&gt;

&lt;h3 id=&quot;控制器模式&quot;&gt;控制器模式&lt;/h3&gt;
&lt;p&gt;控制器模式是Kubernetes平台最基本的编排模式，其思路等同于如下的伪代码&lt;/p&gt;

&lt;div class=&quot;language-golang highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual_state&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_actual_state_of_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected_state&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_expected_state_of_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual_state&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected_state&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_nothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute_orchestration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不同的控制器有不同的实现，但是它们都遵循如上的处理逻辑。实际的状态来自于当前集群上，对应的API对象的实际状态，而&lt;strong&gt;期望的状态则来自于用户提交的API声明&lt;/strong&gt;。
任何时候用户想改变对象的状态，都&lt;strong&gt;不是直接提交命令完成，而是修改期望的对象状态&lt;/strong&gt;，然后默默等待后台的控制器异步调度对应的预定义动作，完成对象更新。&lt;/p&gt;

&lt;p&gt;至于控制器对象本身的YAML声明可以理解为包含两个部分&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;控制器自身的定义，包括期望的状态&lt;/li&gt;
  &lt;li&gt;被控制对象的期望状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;deployment控制器&quot;&gt;Deployment控制器&lt;/h4&gt;
&lt;p&gt;Deployment用于控制POD的容器镜像、标签、网络设置等信息；每次更新这些内容，Deployment的控制器就会被触发确保POD被调度到期望的状态。&lt;/p&gt;

&lt;h3 id=&quot;水平扩展和多副本&quot;&gt;水平扩展和多副本&lt;/h3&gt;
&lt;p&gt;可扩展性是云计算给应用程序开发者提供的最大的一个灵活性之一；我们可以按照不同的负载和扩展性要求组织不同的服务到不同的POD中，进而实现按照需要自动伸缩、按需付费的理想;
这一能力也是最早的云计算想法被提出的时候，一个合格的云平台就应该提供的能力。&lt;/p&gt;

&lt;p&gt;本来扩展性支持水平和垂直两个方向的扩展要求，水平扩展支持&lt;strong&gt;增加新的服务实例&lt;/strong&gt;来提高服务能力，而垂直扩展则是通过添加既有服务实例的资源的方式来提升容量。
随着云平台应用的逐步深入，人们发现&lt;strong&gt;水平扩展比垂直扩展更为方便和易用&lt;/strong&gt;，因此Kubernetes本身提供了对水平扩展的灵活支持；支持的方法是&lt;strong&gt;通过ReplicaSet来完成&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;ReplicaSet和Deployment、POD之间有着&lt;strong&gt;层层递进的控制&lt;/strong&gt;关系，是三个关系紧密的控制器&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ReplicaSet通过其spec中定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;replicas=x&lt;/code&gt;声明，来控制&lt;code class=&quot;highlighter-rouge&quot;&gt;POD&lt;/code&gt;对象，保证实例数目总是等于&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Deployment对象则通过控制ReplicaSet实现具体的水平缩放、滚动更新等动作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;scale&lt;/code&gt;命令，其实是对ReplicaSet控制的一种封装，它虽然具&lt;strong&gt;有命令是控制的外壳，其内部却依然是通过上述的通用的控制器模式&lt;/strong&gt;来实现的。&lt;/p&gt;

&lt;h4 id=&quot;滚动更新&quot;&gt;滚动更新&lt;/h4&gt;
&lt;p&gt;对于需要滚动更新的常见，Deployment其实会创建多个版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;ReplicaSet&lt;/code&gt;,并且根据期望的新旧版本的实例个数，
动态的创建、停止新旧版本的软件，实现服务的动态滚动部署。&lt;/p&gt;

&lt;h3 id=&quot;statefulset有状态服务&quot;&gt;StatefulSet有状态服务&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Deployment控制器模式所能控制的POD默认是需要保持无状态&lt;/strong&gt;的，即不同的副本关闭和重启对服务提供的业务逻辑而言是没有关联的；这也是云原生模式要求的。
然而现实实际往往没有这么美好，实际情况是往往我们还有很多有状态的服务，即不同的实例之间是不能无缝替换的。
对于这种情况，Kubernetes提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;StatefulSet&lt;/code&gt;这一对象来描述和管理。&lt;/p&gt;

&lt;p&gt;其设计将状态分为两种&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;拓扑状态，即某些服务实例需要按照特定的顺序来启动，它们的拓扑结构上产生的依赖和状态&lt;/li&gt;
  &lt;li&gt;存储状态，即不同的服务实例需要不同的存储数据，比如数据库的主从关系等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;拓扑状态&quot;&gt;拓扑状态&lt;/h4&gt;
&lt;p&gt;基于拓扑顺序而言的有状态应用而言，我们可以利用headless service的概念（即需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;clusterIP=None&lt;/code&gt;），通过拿到service名字之后，直接用label选择规则就可以定位到对应的service POD实例的IP，而不需要经过virtual IP机制。&lt;/p&gt;

&lt;p&gt;这一策略能行得通是因为POD在被创建的时候，&lt;strong&gt;每个POD都被赋予一个带编号的名字&lt;/strong&gt;(比如web-1/web-2/等)，并且这些编号从1开始依次增加，严格按照顺序创建。
销毁的时候，也需要按照顺利进行。&lt;/p&gt;

&lt;p&gt;通过这种方式，Kubernetes可以为有状态的服务提供一个独一无二的DNS名字，这样服务使用方就&lt;strong&gt;可以根据名字来解析到对应的POD IP进行访问&lt;/strong&gt;，即使是POD的IP地址可以在运行的时候被改变也不至于造成太大的影响。&lt;/p&gt;

&lt;h4 id=&quot;存储状态&quot;&gt;存储状态&lt;/h4&gt;
&lt;p&gt;对于需要访问有状态存储的服务而言，Kubernetes通过如下的服务对象来支持&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Persistent Volume Claim用于指定持久化卷访问声明，这是一个关于访问需求的描述对象&lt;/li&gt;
  &lt;li&gt;Persistent Volume持久化卷用于提供具体的持久化访问能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PV和PVC的概念设计非常类似于应用程序开发中的&lt;strong&gt;接口和实现分离的具体实现；PV是具体的实现，而PVC则充当接口&lt;/strong&gt;。
应用程序的POD声明需要绑定一个具体的PVC对象，Kubernetes平台就会自动完成POD需要的持久化卷和实际可用的持久化卷之间的匹配。&lt;/p&gt;

&lt;p&gt;在完成对应的PVC绑定之后，&lt;strong&gt;PVC的名字就会和StatefulSet的名字绑定在一起&lt;/strong&gt;完成统一编号，形成类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pvcname&amp;gt;-&amp;lt;satefulset&amp;gt;-1&lt;/code&gt;这样的名字。&lt;/p&gt;

&lt;p&gt;当POD被删除的时候，&lt;strong&gt;PVC对应的存储卷里面的内容并不会丢失&lt;/strong&gt;而是被持久化保存起来，这样下次POD再次被Statefulset创建起来的时候，它还可以访问到之前对应的那个PVC里面的内容。
它的工作原理如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当POD被删除的时候，StatefulSet会留意到对应的POD停止了&lt;/li&gt;
  &lt;li&gt;控制器会重新尝试创建对应编号的POD，并且在创建之后，尝试重新关联相同编号的PVC&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;statefulset的设计思想&quot;&gt;StatefulSet的设计思想&lt;/h4&gt;
&lt;p&gt;综合以上两种情况，可以看出来StatefulSet的核心思路是&lt;strong&gt;其本身是一种特殊的Deployment，它所控制的POD资源在运行调度的时候，每一个POD都会被单独编号&lt;/strong&gt;；并且这些编号信心还会反应在其POD资源的名字和DNS信息上，作为POD的网络身份名字。&lt;/p&gt;

&lt;p&gt;基于该编号信息，它就可以利用Kubernetes里面的Headless Service和PV、PVC的概念，实现对POD的拓扑状态和存储资源状态的维护和控制。&lt;/p&gt;

&lt;h3 id=&quot;daemonset守护进程&quot;&gt;DaemonSet守护进程&lt;/h3&gt;
&lt;p&gt;DaemonSet是另外一个控制器，它的主要场景类似于普通Linux系统里面的守护进程，只不过它的作用域是一个一个独立的Kubernetes集群节点，即我们想控制一些POD的部署，让它&lt;strong&gt;确保在整个集群的每个节点上都有且仅有一个POD实例&lt;/strong&gt;在运行的场景。&lt;/p&gt;

&lt;p&gt;如果集群被扩容（即有新的节点加入进来），那么DaemonSet会立刻在这个新的节点上创建一个新的POD出来；而当某个节点被删除的时候，其上的POD也会被自动清理掉。&lt;/p&gt;

&lt;p&gt;这种控制器的应用场景包含一些特殊的插件的Agent，比如网络或者存储插件，监控和日志等组件；它们基本的工作原理都是在一个节点上创建一个唯一的实例，完成网络处理、文件系统挂载、日志转发和监控等节点层面唯一的处理。&lt;/p&gt;

&lt;h4 id=&quot;daemonset如何保证唯一&quot;&gt;DaemonSet如何保证唯一&lt;/h4&gt;
&lt;p&gt;其控制器通过&lt;strong&gt;获取etcd数据库里面的Node列表，然后逐一遍历&lt;/strong&gt;其中的节点并做相应的检查，即可判定是否需要创建或者删除POD。
如果没有，则新创建POD；如果多余一个，则执行删除即可。&lt;/p&gt;

&lt;p&gt;删除的操作比较简单，通过现有的API调用即可；添加操作稍微麻烦一点。
旧版的API可以通过指定POD对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;nodeSelector&lt;/code&gt;将新的节点名字加上去；但是这样的操作多少有些不方便并且将要被废弃。&lt;/p&gt;

&lt;p&gt;更好的方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.nodeAffinity&lt;/code&gt;来实现，例如下面的例子&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;with-node-affinity&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;affinity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;nodeAffinity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;nodeSelectorTerms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;matchExpressions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;metadata.name&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;In&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;node-geektime&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里要求在每次调度的时候予以考虑如下的匹配条件，具体的条件是当其&lt;code class=&quot;highlighter-rouge&quot;&gt;metadata.name&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;node-geektime&lt;/code&gt;的时候才需要运行POD。&lt;/p&gt;

&lt;h5 id=&quot;污点标记&quot;&gt;污点标记&lt;/h5&gt;
&lt;p&gt;DaemonSet能在Node初始化完毕之前就启动，它所依赖的机制是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.tolerations&lt;/code&gt;的声明，比如我们允许对应的节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;unschedulable&lt;/code&gt;的节点也可以允许调度；而默认情况下这样的节点上不会调度任何POD。&lt;/p&gt;

&lt;p&gt;加上了这个标记，即使对应的Node不可用，Kubernetes也会尝试去调度对应的POD直到成功位为止。当然对应的节点如果发生故障的话，调度则会失败。&lt;/p&gt;

&lt;p&gt;这样的机制很有用，是因为一些特殊的插件agent比如&lt;strong&gt;网络插件，必须要在节点还没有完全完成初始化的时候&lt;/strong&gt;被先调度起来。利用这个技巧，我们甚至可以在集群的master节点上选择调度某个POD。&lt;/p&gt;

&lt;h3 id=&quot;非长时间执行的服务&quot;&gt;非长时间执行的服务&lt;/h3&gt;
&lt;p&gt;除了常见的微服务应用，Kubernetes也可以用来处理一些不是需要一直运行的任务，一般情况下人们称之为离线业务或者批处理业务。这些业务的执行特点是&lt;strong&gt;一次执行之后就退出&lt;/strong&gt;了，如果我们仍然选择上述的控制器来管理，
就会引起循环的调用和推出，类似于滚动更新等高级功能就无法工作了。&lt;/p&gt;

&lt;p&gt;早期Google自己的Borg系统就提出了两种业务形态，分别是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Long Running Service即长时间运行的服务&lt;/li&gt;
  &lt;li&gt;Batch Jobs即批处理作业；该形态自然也被加入到了Kubernetes中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job&quot;&gt;Job&lt;/h4&gt;
&lt;p&gt;Job对应于专门的一次性执行的任务，它通过&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.template.spec.restartPolicy=Never&lt;/code&gt;来指定任务完成后不用重启。
Job控制器会在运行期的时候为实际的POD实例生成一个常常的UUID，保证对应的JOB和它的POD实现一一匹配。&lt;/p&gt;

&lt;p&gt;当然上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;restartPolicy&lt;/code&gt;&lt;strong&gt;可以被设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;OnFailure&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Never&lt;/code&gt;&lt;/strong&gt;,前者对应于失败的时候允许重新启动以便实现出错重试的逻辑。
同时需要谨慎使用该逻辑，因为如果程序有问题，我们不太会期望Job被重试太多次而浪费资源！
幸好Kubernetes自己已经给设置了一个最大的重试次数，&lt;strong&gt;没有指定的情况下会重试6次&lt;/strong&gt;，我们可以通过指定一个新的值给&lt;code class=&quot;highlighter-rouge&quot;&gt;backoffLimit&lt;/code&gt;来自定义重试次数。&lt;/p&gt;

&lt;p&gt;离线作业还有一种情况是因为种种原因，POD容器里面定义的操作迟迟没有结束，为了避免占用太多的资源，Kubernetes允许我们设置&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.activateDeadlineSeconds&lt;/code&gt;来指定最长允许运行的时间；超过了之后，对应的Pod就会被终止。
因为超过时限而终止的POD的状态也可以在POD的状态里面看到。&lt;/p&gt;

&lt;h4 id=&quot;并行作业和最小完成数&quot;&gt;并行作业和最小完成数&lt;/h4&gt;
&lt;p&gt;某些特殊的任务可以并行去完成，对应的控制参数是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.parallelism&lt;/code&gt;指定最多同时可以启动的POD的个数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.completions&lt;/code&gt;定义了Job完成时最少需要正常完毕的POD的个数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cronjob&quot;&gt;CronJob&lt;/h4&gt;
&lt;p&gt;CronJob用来描述需要定期执行的任务，它和Job的关系就如同Deployment和POD的关系一样，即&lt;strong&gt;CronJob是通过控制Job对象来完成定时任务&lt;/strong&gt;的。
它所创建和删除Job的依据是API定义中传入的符合Unix Crontab格式的调度表达式。&lt;/p&gt;

&lt;h2 id=&quot;持久化存储&quot;&gt;持久化存储&lt;/h2&gt;
&lt;p&gt;前面部分探讨有状态服务部署的时候，以及简要涉猎了存储部分的概念，这一部分则深入探究这些概念背后的细节。
从概念上说，PV描述了实际运维人员负责创建并放置到Kubernetes集群里给各个POD使用的持久化存储数据卷实现，而PVC则相当于是存储需求的接口描述；这里的基本思想是&lt;strong&gt;面向对象式的接口和实现分离&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;但是一个棘手的问题是，有可能POD启动的时候，PVC的匹配没有成功，那么POD启动就会失败。如果此时运维人员及时发现了这一问题，并创建新的PV存储加入到平台中，怎么保证新创建的PV可以被正确的识别和匹配？
问题的答案在于系统内部的一个特殊的控制器：PersistentVolumeController。&lt;/p&gt;

&lt;h3 id=&quot;persistentvolumecontroller&quot;&gt;PersistentVolumeController&lt;/h3&gt;
&lt;p&gt;该控制器会定期去查看每一个PVC，&lt;strong&gt;检查它是否已经处于绑定状态&lt;/strong&gt;，如果不是则会查找所有的PV，找到一个匹配的并与PVC做绑定。
绑定的过程其实是通过填充&lt;code class=&quot;highlighter-rouge&quot;&gt;spec.volumeName&lt;/code&gt;字段来完成的，从而只要Kubernetes能够找到这个PVC对象，它就可以将之分配给需要的POD来使用。&lt;/p&gt;

&lt;h3 id=&quot;pv如何完成绑定&quot;&gt;PV如何完成绑定&lt;/h3&gt;
&lt;p&gt;PV的所谓持久化，意味着挂载目录里面的内容不会因为容器的删除而被销毁清理，也不会跟某个具体的宿主机（节点）进行绑定，因为容器可能在下次重新调度的时候，在一个完全不同的宿主机上被创建出来。
因而&lt;strong&gt;持久化卷的实现往往需要依赖于一个远程通过网络访问的存储服务&lt;/strong&gt;，比如NFS文件系统或者公有云服务提供商的远程磁盘等。&lt;/p&gt;

&lt;p&gt;其准备阶段可以认为经历两个阶段的处理&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将远程的存储服务挂载到宿主机上，这个阶段被成为Attach操作&lt;/li&gt;
  &lt;li&gt;第二个步骤类似于文件系统的格式化操作并挂载到具体的宿主机指定的挂载点上，以便POD能够访问&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过了这两个阶段，内部的kubelet只需要&lt;strong&gt;将对应的目录通过container接口的mount参数传递给docker容器&lt;/strong&gt;就可以让POD里面的容器能够访问这个持久化的存储卷了。&lt;/p&gt;

&lt;p&gt;反向的解绑和删除操作只需要理解为是以相反的顺序执行相反的操作即可，即先unmount然后再detach。&lt;/p&gt;

&lt;p&gt;更具体地说，上述两个阶段也是由两个控制器来负责的&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;AttachDetachController负责关于POD和宿主机的attach/detach情况的检查和操作，该控制器需要运行在master节点上，因为它自身是kube-controller-manager的一部分&lt;/li&gt;
  &lt;li&gt;VolumeManagerReconciler作为Kubelet组件的一部分负责宿主机上的mount/unmount操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;storage-class和pv创建&quot;&gt;Storage Class和PV创建&lt;/h3&gt;
&lt;p&gt;在大规模的生产线环境中，不同的微服务容器可能需要用到成千上万个PVC，从而意味着需要准备大量的PV。
在业务动态开发扩大的过程中，系统中的PVC可能会动态地发生变化，指望运维来人肉创建PV显然是难以为继的。
显然我们需要一种能够&lt;strong&gt;动态创建PV的机制，该机制的核心则依赖于名字为StorageClass&lt;/strong&gt;的对象。&lt;/p&gt;

&lt;p&gt;从对象的名字来看，它其实是一种PV创建方法的模板；它需要定义两个部分的信息&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;PV本身的属性，如存储类型，卷的大小容量等信息&lt;/li&gt;
  &lt;li&gt;创建过程中所要用到的存储系统插件，如Ceph等。
有了这些信息，Kubernetes就可以&lt;strong&gt;依据用户声明中的PVC，找到对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;StorageClass&lt;/code&gt;&lt;/strong&gt;，然后利用其中定义的插件来生成实际需要的PV。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pvpvc机制是否是过度设计&quot;&gt;PV/PVC机制是否是过度设计&lt;/h3&gt;
&lt;p&gt;探讨是否过度设计的问题，往往需要澄清清楚设计的目标然后才能判断是否有过度设计的嫌疑。
作为一个面向开源社区的项目，这样的分离&lt;strong&gt;主要期望的是能够支持形形色色的第三方存储&lt;/strong&gt;系统的实现机制，并尽力对容器应用隐藏这些细节差异，
因此&lt;strong&gt;灵活性和可扩展性&lt;/strong&gt;在这里成为被重点被关照的设计目标，从这个角度看就显然没有过度设计。&lt;/p&gt;

&lt;p&gt;如果需要自己实现一个类似于本地磁盘访问一样的本地存储卷，甚至还要付出额外的努力来&lt;strong&gt;适配实现Kubernetes平台所要求的抽象分离设计要求&lt;/strong&gt;；处于可用性的考虑我们不能将目录直接映射为PV，而是采用块设备的方式来对应PV。
由于这一本地块设备的挂载要早于POD调度，因此还要实现在使用本地磁盘卷之前先配置好磁盘或者块设备。&lt;/p&gt;

&lt;h2 id=&quot;网络管理&quot;&gt;网络管理&lt;/h2&gt;

&lt;p&gt;Docker容器本身提供了基于Linux内核命名空间的网络栈隔离机制，而Kubernetes本身的网络管理功能则依托于容器本身提供的网络隔离能力之上。&lt;/p&gt;

&lt;h3 id=&quot;docker的网络栈&quot;&gt;Docker的网络栈&lt;/h3&gt;
&lt;p&gt;具体到网络栈隔离，我们通常需要考虑如下这些要素&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;网卡设备&lt;/li&gt;
  &lt;li&gt;本地回环设备即loopback&lt;/li&gt;
  &lt;li&gt;路由表&lt;/li&gt;
  &lt;li&gt;iptable访问规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker本身可以支持&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;模式直接使用宿主的网络服务，而不采用命名空间隔离技术。当然这样的缺憾是所有的网络处理其实都是由宿主机来完成的，&lt;strong&gt;没有办法完成精细化的网络管理和控制&lt;/strong&gt;而且容易引起资源冲突；
这样做也由明显的性能上的优势，却不符合绝大部分虚拟化的环境中的网络资源隔离和管控需求。
Linux中我们可以&lt;strong&gt;通过网桥来实现虚拟网络交换&lt;/strong&gt;的工作，其原理是依赖于工作在数据链路层的MAC地址学习而将不同的数据包发送到不同的网络端口上的。&lt;/p&gt;

&lt;h4 id=&quot;veth虚拟网桥&quot;&gt;veth虚拟网桥&lt;/h4&gt;
&lt;p&gt;具体到Docker的实现来说，它通过&lt;strong&gt;虚拟的&lt;code class=&quot;highlighter-rouge&quot;&gt;veth&lt;/code&gt;设备来连接两个可以互联互通的容器&lt;/strong&gt;；在创建好的使用网桥的容器中，我们可以看到的&lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;其实就是网桥连通的一端。而连接的另一端则发生在宿主机上的名字为&lt;code class=&quot;highlighter-rouge&quot;&gt;vethxxxx&lt;/code&gt;的虚拟网卡设备；&lt;code class=&quot;highlighter-rouge&quot;&gt;brctl show&lt;/code&gt;可以看到虚拟网卡会被关联到具体的docker容器上；网桥设备则现实为&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样任何的&lt;code class=&quot;highlighter-rouge&quot;&gt;veth&lt;/code&gt;虚拟网卡都会变成是&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;网桥的从设备，所有的网络流量都会先发给&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;网桥，然后由网桥来决定将其转发到哪个容器对应的虚拟网卡上，即所有的这些&lt;strong&gt;从设备都变成网桥转发的一个端口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;任何网络访问的请求都会处理大概如下的流程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;容器里面的对外访问都会被路由到&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;网桥上去-具体情况可以在容器内查看路由表&lt;/li&gt;
  &lt;li&gt;根据IP地址判定目标地址是否是本地容器里的IP
　　- 如果是，则发送到&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;网桥，由网桥决定发送到哪个&lt;code class=&quot;highlighter-rouge&quot;&gt;vethxxx&lt;/code&gt;设备，一旦发送完毕，数据包就会自然出现在对应容器的&lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;网卡上
　　- 如果不是，则会根据宿主机的路由规则来决定下一跳的节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;跨主机通信&quot;&gt;跨主机通信&lt;/h4&gt;
&lt;p&gt;这样的机制保证了同一个节点上的容器之间的IP总是可以互相连通的，并且容器内的应用也可以访问宿主机上绑定的其它IP或者宿主机可以直接到达的目标地址。
然而如果&lt;strong&gt;需要跨越主机访问另外一个机器内的容器的IP&lt;/strong&gt;的时候，Docker默认的桥接技术就无能为力了；需要借助容器编排平台的能力。&lt;/p&gt;

&lt;p&gt;想要提供跨越主机的容器之间的互相访问，我们需要扩展上面的网桥的概念，创建一种虚拟的网桥将各个主机之间的容器都桥接起来，这种方法就像&lt;strong&gt;创建了一个覆盖在所有的容器网桥之上的一个虚拟网络&lt;/strong&gt;，所以被成为Overlay Network。&lt;/p&gt;

&lt;h3 id=&quot;flannel&quot;&gt;Flannel&lt;/h3&gt;
&lt;p&gt;CoreOS公司推出了被成为Flannel的框架来解决跨容器主机通信的问题；其本身由几种不同的后端实现，分别是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VXLAN&lt;/li&gt;
  &lt;li&gt;host-gw&lt;/li&gt;
  &lt;li&gt;UDP是&lt;strong&gt;最早提出也最容易&lt;/strong&gt;理解的方式，然而其&lt;strong&gt;性能也最差&lt;/strong&gt;，现在依据几乎不用了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;udp&quot;&gt;UDP&lt;/h4&gt;
&lt;p&gt;UDP的方式依赖于Flannel框架在宿主机上创建的&lt;strong&gt;工作在网络层的虚拟隧道设备&lt;code class=&quot;highlighter-rouge&quot;&gt;flannel0&lt;/code&gt;&lt;/strong&gt;，和重定向到这个隧道的路由表。当宿主机收到无法匹配到本机&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;的数据包的时候，它会根据flannel创建的路由重定向到这个名字为&lt;code class=&quot;highlighter-rouge&quot;&gt;flannel0&lt;/code&gt;的隧道设备上。&lt;/p&gt;

&lt;p&gt;同时在宿主机上还有一个&lt;strong&gt;守护进程flanneld负责监控收到的包，然后依据各个节点上的flanneld之间相互维护的子网关系，将其转发到对应的其它宿主机上&lt;/strong&gt;的flanneld。
实现上不同的机器会处于不同的子网中，因此flanneld可以根据子网信息决定应该发送到哪个具体ide节点上。而子网和节点的对应关系则存储在etcd数据库中。&lt;/p&gt;

&lt;p&gt;flanneld之间的通信是通过UDP协议来完成的，UDP的源地址是发送方的宿主机的地址，而目的地址则是接收方的宿主机的地址。这样利用宿主机之间的路由表就可以完成数据的收发。&lt;/p&gt;

&lt;h5 id=&quot;性能问题&quot;&gt;性能问题&lt;/h5&gt;
&lt;p&gt;操作系统的运行概念上将程序的状态分为内核态和用户态，在这两个状态之间切换需要经历&lt;strong&gt;上下文切换&lt;/strong&gt;，并且它们访问的&lt;strong&gt;内存空间是物理上隔离&lt;/strong&gt;的；如果需要交换数据则必须要做内存的搬运。TUN隧道设备的特色是&lt;strong&gt;工作于用户空间&lt;/strong&gt;，即使简单的考虑用户从容器内发送数据出去就需要经过&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;容器到docker0的数据交换，从用户态到内核&lt;/li&gt;
  &lt;li&gt;docker0到flanneld的交换，从内核态到用户态&lt;/li&gt;
  &lt;li&gt;flanned到eth0的数据交换，又从用户态到内核态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算上接收方的方向处理，&lt;strong&gt;一次数据收发需要６次的数据切换&lt;/strong&gt;，性能开销很大，而用户的角度来看可能只期望两次。
所以UDP方式的性能很差，很快人们就不再使用了。&lt;/p&gt;

&lt;h4 id=&quot;vxlan&quot;&gt;VXLAN&lt;/h4&gt;
&lt;p&gt;Linux本身支持Virtual Extensible LAN的虚拟可扩展局域网技术；使用这种技术来完成封装和解封工作就可以有效地规避UDP隧道带来的不必要的数据切换拷贝开销。&lt;/p&gt;

&lt;p&gt;VXLAN的实现方式要求工作于数据链路层，并且会在宿主机上设置一个特殊的设备作为隧道通信的两端，即VTEP(VXLAN Tunning End Point)，它需要在数据链路层完成和上面的IP隧道类似的流程；主要的区别是&lt;strong&gt;所有的类似操作都在内核态完成&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;VETP设备的表现形态是&lt;code class=&quot;highlighter-rouge&quot;&gt;flannel.1&lt;/code&gt;设备，它工作在内核态并且作用在数据链路层上。
&lt;code class=&quot;highlighter-rouge&quot;&gt;flanneld&lt;/code&gt;则负责维护对应隧道的出口的VETH设备信息。
因为二层设备需要依赖于MAC地址，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;flanneld&lt;/code&gt;在宿主机上会依据节点的信息，通过ARP协议查询获取对应的MAC地址，然后将其对应关系保存下来。这样&lt;code class=&quot;highlighter-rouge&quot;&gt;flannel.1&lt;/code&gt;就可以根据该信息查询到IP对应的MAC信息了。&lt;/p&gt;

&lt;p&gt;Linux内核会把目的设备的MAC地址和目标容器的&lt;strong&gt;IP地址信息写入VXLAN的内部数据帧结构&lt;/strong&gt;中，这部分信息会放在封装的外部数据帧中。同时此外部数据帧还包含VXLAN对应的头，里面包含由类似VNI的信息，然后将这些数据帧封装为一个UDP包发送出去。&lt;/p&gt;

&lt;p&gt;同时为了使得该UDP包可以正确地发送出去，&lt;code class=&quot;highlighter-rouge&quot;&gt;flanneld&lt;/code&gt;还负责维护了一个&lt;strong&gt;转发数据库FDB，里面放置了MAC地址和IP地址、设备名称(flannel.1)的对应信息&lt;/strong&gt;，从而Linux内核可以依据该转发信息将UDP包发送到正确的主机上。&lt;/p&gt;

&lt;h3 id=&quot;kubernetes的cni插件&quot;&gt;Kubernetes的CNI插件&lt;/h3&gt;
&lt;p&gt;Kuberenetes管理网络插件的方法是通过&lt;strong&gt;名字为CNI的接口&lt;/strong&gt;来实现的。在CNI的术语里面，用于替代上述&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;的网桥名字被成为是&lt;code class=&quot;highlighter-rouge&quot;&gt;cni0&lt;/code&gt;。
而Kubernetes里面的网络管理方式和上面的VXLAN模式几乎没有任何不同，只是&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;被换成了&lt;code class=&quot;highlighter-rouge&quot;&gt;cni0&lt;/code&gt;而已。&lt;/p&gt;

&lt;p&gt;默认情况下，Kubernetes为Flannel分配的子网范围是&lt;code class=&quot;highlighter-rouge&quot;&gt;10.244.0.0/16&lt;/code&gt;，部署参数&lt;code class=&quot;highlighter-rouge&quot;&gt;--pod-network-cidr=xxx.xxx.xxx.xxx/yy&lt;/code&gt;可以指定新的子网。&lt;/p&gt;

&lt;h4 id=&quot;为什么要用不同的名字&quot;&gt;为什么要用不同的名字&lt;/h4&gt;
&lt;p&gt;如果是用docker命令行创建的容器，它的容器内的网桥还是会连接在&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;上，而使用POD的方式创建的容器则会具有&lt;code class=&quot;highlighter-rouge&quot;&gt;cni0&lt;/code&gt;的接口，这样的不同是因为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Kubernetes没有也不希望直接绑定于Docker的网络管理模型，因而它不希望管理和控制cni0&lt;/li&gt;
  &lt;li&gt;Kubernetes自身的POD里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;infra&lt;/code&gt;容器有特殊的设计；当&lt;strong&gt;POD被创建之后，Infra容器总是被先创建&lt;/strong&gt;，然后Kubernetes再调用CNI网络插件设置符合预期的网络空间&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;host-gw模式&quot;&gt;host-gw模式&lt;/h4&gt;
&lt;p&gt;上述的第三种模式的工作模式如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;假设需要通信的&lt;strong&gt;节点之间在二层链路层是互通&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;将每个flannel的子网的下一跳&lt;strong&gt;直接设置为该子网对应的宿主机的IP&lt;/strong&gt;地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从而达到该宿主机本身成了容器通信路径里面的网管的作用，并且这些子网和对应主机的关联信息依然保存再etcd中；
&lt;code class=&quot;highlighter-rouge&quot;&gt;flanneld&lt;/code&gt;则需要监控数据的变化，然后实时更新路由表。&lt;/p&gt;

&lt;p&gt;实现host-gw模式的插件除了flannel之外还有&lt;strong&gt;利用BGP网关协议来实现互通性&lt;/strong&gt;的Calico项目。
Calico的特色是不依赖上述的虚拟网桥设备的概念，而利用强大的边界网管协议，直接实现节点与节点之间的全息路由交换。&lt;/p&gt;

&lt;h3 id=&quot;service对象&quot;&gt;Service对象&lt;/h3&gt;
&lt;p&gt;Service对象其实就对应于常说的微服务应用，之所以我们需要这个概念是因为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;POD是一个部署、调度期的概念，它的&lt;strong&gt;IP地址可能是不固定&lt;/strong&gt;的，而服务使用方却希望有一个确定的访问点&lt;/li&gt;
  &lt;li&gt;需要考虑扩展性，多个POD还可能被负载均衡器所控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kuberenetes通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Service&lt;/code&gt;对象来&lt;strong&gt;选择某些符合条件的POD运行期实例&lt;/strong&gt;，并提供稳定的访问点(virtual IP)来提供外部应用程序对所抽象的应用服务的访问。
显然Service要能正常工作，Kuberenetes灵活的网络层功不可没。&lt;/p&gt;

&lt;h4 id=&quot;查看service的服务端点&quot;&gt;查看Service的服务端点&lt;/h4&gt;
&lt;p&gt;具体哪些POD可以对外提供所声明的服务，是&lt;strong&gt;由Kubernetes运行时平台决定&lt;/strong&gt;的，它需要保证对应的POD满足&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;处于运行状态&lt;/li&gt;
  &lt;li&gt;可用性检查探针检查通过&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而当POD运行出现问题的时候，Kubernetes会立刻将其从Service的实例里面删除。&lt;/p&gt;

&lt;h4 id=&quot;网络层如何工作&quot;&gt;网络层如何工作&lt;/h4&gt;
&lt;p&gt;Service其实是&lt;strong&gt;依赖于iptables规则&lt;/strong&gt;来实现Virtual IP的重定向的，即这个所谓的ClusterIP可以不真正存在（即使ping不同它代理的Service也照样可以正常工作）。&lt;/p&gt;

&lt;p&gt;同时Kubernetes提供了默认的基于轮询的负载均衡实现，而&lt;strong&gt;每一个提供服务的POD都会得到一条对应的路由转发规则&lt;/strong&gt;。为了保证多个POD实例得到服务的机会均等，对应的iptables规则里面会加上&lt;strong&gt;对应的probability设置&lt;/strong&gt;来影响路由规则的命中率。&lt;/p&gt;

&lt;h4 id=&quot;iptables数量的限制&quot;&gt;iptables数量的限制&lt;/h4&gt;
&lt;p&gt;由于Service的重定向需要依赖于大量的iptables规则的实时刷新和查询，当宿主机上由大量的POD需要被调度的时候，
宿主机的资源会被大量消耗在iptables的处理中，因而&lt;strong&gt;基于iptables规则的Service机制成为制约POD数量&lt;/strong&gt;的一个主要因素之一。&lt;/p&gt;

&lt;p&gt;IPVS模式通过在创建Service的时候在宿主机上创建虚拟网卡并分配service地址的方式来解决这个问题。
然后kubeproxy组件就会通过Linux提供的IPVS模块为IP地址设置成多个虚拟主机，然后主机之间通过轮询的方式作负载均衡。
通过将&lt;strong&gt;高负载的处理请求放入操作系统内核态&lt;/strong&gt;，IPVS有效地规避了大量动态iptables规则的刷新带来的性能问题。&lt;/p&gt;

&lt;h4 id=&quot;service和dns&quot;&gt;Service和DNS&lt;/h4&gt;
&lt;p&gt;Kubernetes会为Service和POD分配DNS名字；而Service从服务模式上可以分为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ClusterIP模式，对应的&lt;strong&gt;访问方式是基于Virtual IP&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;Headless模式，此时ClusterIP设置为None,DNS解析的时候会&lt;strong&gt;直接指向一个稳定的POD对应的IP&lt;/strong&gt; 
实际使用的过程中，需要根据应用服务的特征做合理的选择。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kubernetes的调度和资源管理&quot;&gt;Kubernetes的调度和资源管理&lt;/h2&gt;
&lt;p&gt;如前面所述，POD是Kuberenetes提供的最基本的资源调度单元，因此&lt;strong&gt;所有和资源控制管理有关的属性都可以并且应该属于POD&lt;/strong&gt;的字段；其中我们最熟悉也最重要的就是CPU和内存资源。&lt;/p&gt;

&lt;h3 id=&quot;资源压缩&quot;&gt;资源压缩&lt;/h3&gt;
&lt;p&gt;因为CPU资源不足的时候，POD只会因为饥饿而执行缓慢却&lt;strong&gt;不会直接退出&lt;/strong&gt;，因此CPU资源属于可压缩的资源。
而内存则不同，当程序内存不足的时候，POD就会由于内存不足而&lt;strong&gt;直接被内核杀掉&lt;/strong&gt;，所以内存属于不可压缩的资源。&lt;/p&gt;

&lt;p&gt;POD里面可以由多个不同的容器组成，而资源消耗的最小单元是容器而不是POD，所以一个&lt;strong&gt;POD所占用的资源等价于所有容器的资源的总和&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;cpu资源&quot;&gt;CPU资源&lt;/h4&gt;
&lt;p&gt;Kubernetes用逻辑抽象的方式来定义CPU，其单位是CPU的个数，数字１表示限制为１个CPU，至于这个具体的1的含义是如何解释，完全取决于宿主机的实现，因为CPU资源属于可压缩的资源。
同时我们&lt;strong&gt;可以将CPU资源限制设置为分数&lt;/strong&gt;，Kubernetes的惯用法是用类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;500m&lt;/code&gt;来表示0.5个CPU。&lt;/p&gt;

&lt;h4 id=&quot;内存资源&quot;&gt;内存资源&lt;/h4&gt;
&lt;p&gt;Kubernetes的内存资源因为其不可压缩性，只能用类似于绝对数量的单位来表示。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;1Ki&lt;/code&gt;表示1KB，而&lt;code class=&quot;highlighter-rouge&quot;&gt;1Mi&lt;/code&gt;表示1MB,
基本上常见的表示内存容量的&lt;strong&gt;大写字母后面再加上小写字母i&lt;/strong&gt;就表示对应的容量。&lt;/p&gt;

&lt;h3 id=&quot;资源请求和限制&quot;&gt;资源请求和限制&lt;/h3&gt;
&lt;p&gt;从设计上来说，Kubernetes允许用户设置资源的上限和请求值，一般&lt;strong&gt;上限(limit)需要大于请求(request)&lt;/strong&gt;值。
这样当调度的时候，&lt;strong&gt;调度器会按照请求值&lt;/strong&gt;进行计算，而传递给内核的cgroups的时候，实际设置的参数是上限。&lt;/p&gt;

&lt;p&gt;这样的实际来源于Borg的动态资源边界定义&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;作业提交时设置的资源边界不一定是调度器需要严格遵守的&lt;/li&gt;
  &lt;li&gt;实际情况下，大多数作业&lt;strong&gt;实际使用的资源比它请求的资源限制要小&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pod调度类型&quot;&gt;POD调度类型&lt;/h4&gt;
&lt;p&gt;考虑到POD可能由多个容器组成，容器里面可能会设置请求值和上限值，Kubernetes会给POD设定一个调度类型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;所有&lt;/strong&gt;的容器都设置了请求和上限值，并且&lt;strong&gt;请求和上限值总是相等&lt;/strong&gt;，POD就是guaranteed&lt;/li&gt;
  &lt;li&gt;不满足上述条件，但是&lt;strong&gt;至少有一个容器&lt;/strong&gt;设置了请求值，那么POD就是Burstable&lt;/li&gt;
  &lt;li&gt;既没有设置请求值也没有设置上限值，POD是BestEffort&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当宿主机上的资源不足的时候，Kubernetes会根据POD的类型做不同的调度回收策略。默认情况下，这个触发阈值为&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;memory.available&amp;lt;100Mi
nodefs.available&amp;lt;10%
nodefs.inodesFree&amp;lt;5%
imagefs.available&amp;lt;15%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当不得不回收POD资源的时候，根据POD的类型会&lt;strong&gt;先回收BestEffort类型&lt;/strong&gt;的，然后查找Burstable中那些&lt;strong&gt;使用量超出请求量&lt;/strong&gt;的POD优先进行回收，最后才是回收Guaranteed中的使用量超出限制量的POD。
因此对于重要的应用POD，我们最好设置它的&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt;是相等的。&lt;/p&gt;

&lt;h4 id=&quot;cpuset来提升性能&quot;&gt;cpuset来提升性能&lt;/h4&gt;
&lt;p&gt;使用容器的时候，我们可以将某个&lt;strong&gt;容器绑定到特定的CPU核&lt;/strong&gt;上来减少上下文切换次数，提高应用程序的性能。
如果要使用该特性，需要保证POD是Guaranteed类型的，然后设置&lt;code class=&quot;highlighter-rouge&quot;&gt;limits&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;requests&lt;/code&gt;里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;cpu&lt;/code&gt;&lt;strong&gt;属性是相同的整数值&lt;/strong&gt;，而具体的整数值的含义是由Kubernetes调度器来负责分配的。&lt;/p&gt;

&lt;h3 id=&quot;gpu和device-plugin&quot;&gt;GPU和Device Plugin&lt;/h3&gt;
&lt;p&gt;除了常见的CPU和内存资源外，Kubernetes平台也提供了灵活的&lt;strong&gt;插件化机制来分配和管理特殊的&lt;/strong&gt;资源，诸如GPU、FPGA等非常规资源。&lt;/p&gt;

&lt;h4 id=&quot;gpu&quot;&gt;GPU&lt;/h4&gt;
&lt;p&gt;对用户的诉求来说，支持GPU就相当于一旦再&lt;strong&gt;POD里面添加了需要的GPU个数信息&lt;/strong&gt;，Kubernetes为用户创建的容器里面就自动出现对应的GPU设备和目录。
比如对于Nvidia的GPU来说，容器里需要由&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;GPU设备，比如/dev/nvdia0/&lt;/li&gt;
  &lt;li&gt;GPU驱动程序，如/usr/local/nvidia/*&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kubernetes里面并没有出现一个字段叫&lt;code class=&quot;highlighter-rouge&quot;&gt;gpu&lt;/code&gt;,而是使用了一个抽象的叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;extended resource&lt;/code&gt;的字段来表述这类信息&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;xxxx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;xxxx.xxx/imagex...&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;limites&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;nvidia.com/gpu:1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而提供GPU资源的宿主机上，我们需要利用&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;对象的Status字段，使用&lt;strong&gt;Patch的方式对它进行更新，加上自定义的资源数目信息&lt;/strong&gt;。
幸好这这似乎一个概念上的步骤，实际的方案中，会有Device插件来负责完成维护。&lt;/p&gt;

&lt;h4 id=&quot;device-plugin的工作原理&quot;&gt;Device Plugin的工作原理&lt;/h4&gt;
&lt;p&gt;对任意一种Device，都需要有一个关联的插件来负责维护和监控可用资源的变化。该插件会通过gRPC协议和kubelet组件连接起来，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ListAndWatch&lt;/code&gt;API来&lt;strong&gt;定期汇报Node上的设备的列表&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;kubelet组件在得到这个列表之后，就会直接在它发给API Server的心跳消息里面，用Extended Resource的方式来加上这些设备的数量。
这种处理机制是&lt;strong&gt;和具体设备特性无关的&lt;/strong&gt;，因此不仅限于GPU，还适用于其它类型的设备。目前社区里已经有的插件还包括&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;FPGA&lt;/li&gt;
  &lt;li&gt;SRIOV&lt;/li&gt;
  &lt;li&gt;RDMA等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为资深的Kubernetes开发人员，张磊提供了一个百科全书式的深入浅出的介绍，既有&lt;strong&gt;深度探索实现机制的例子&lt;/strong&gt;又有各种可选方案的理论特色的介绍。
课程的内容无论是广度还是深度上都远远超出了专栏本身的定价；
显然这&lt;strong&gt;不是一门浅尝辄止就可以掌握&lt;/strong&gt;的课程，值得多次回顾以便更加深入地理解这一改变技术界的云平台管理工具。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kubernetes" /><category term="notes" /><category term="engineering" /><category term="tools" /><category term="container" /><summary type="html">云计算从十年前的风起云涌却叫好不叫座的局面慢慢地变成了无人刻意提起的境地，这一切的幕后游戏规则改变者某种程度上来说 都是因为Kubernetes这个伟大的开源项目以及依托于它的云原生运动 (参考前文)) 的蓬勃发展而激发。</summary></entry><entry><title type="html">读Google著名的分布式设计论文－从Borg到Kubernetes的演进</title><link href="https://skyscribe.github.io/post/2019/07/21/from-borg-to-kubernetes/" rel="alternate" type="text/html" title="读Google著名的分布式设计论文－从Borg到Kubernetes的演进" /><published>2019-07-21T00:00:00+08:00</published><updated>2019-07-21T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/07/21/from-borg-to-kubernetes</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/07/21/from-borg-to-kubernetes/">&lt;p&gt;Kubernetes是目前炙手可热的云计算管理基础设施平台，并且是一个诞生不久就迅速鉴定了业界实际标准地位的一个容器编排平台。&lt;/p&gt;

&lt;p&gt;Google于2016年底发表了这篇著名的&lt;a href=&quot;https://www.techrepublic.com/article/why-docker-is-finally-embracing-kubernetes/&quot;&gt;Borg, Omega, and Kubernetes&lt;/a&gt;的论文，几年来已经被引用无数。
深入学习这篇论文，可以学习到很多分布式系统设计的宝贵经验和知识最终在工作和学习中为我所用。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;云计算平台发展的简单回顾&quot;&gt;云计算平台发展的简单回顾　&lt;/h2&gt;
&lt;p&gt;云计算技术从概念到落地已经&lt;strong&gt;经历了超过十年的打磨&lt;/strong&gt;，从早期的CloudFoundry到中间热闹非凡的开源项目OpenStack，云计算的应用一度处于&lt;strong&gt;叫好不叫座的尴尬境地&lt;/strong&gt;。
随后Docker项目的横空出世一下子简化了应用服务部署上云的步伐，从而在一段时间内出现了容器云管理平台百家争鸣的局面。&lt;/p&gt;

&lt;p&gt;然而直到两三年前的容器云管理市场上，还有DockerSwarm、MeSOS、Kubernetes等几个大的玩家在进行着激烈的竞争，企业做技术选项的时候还要考虑它们之间的优缺点，做仔细的权衡和技术决策。随着2017年底&lt;strong&gt;Docker母公司宣布自己的DockerSwarm工具也&lt;a href=&quot;https://www.techrepublic.com/article/why-docker-is-finally-embracing-kubernetes/&quot;&gt;拥抱和支持Kubernetes开始&lt;/a&gt;&lt;/strong&gt;，
正常竞争就变得毫无悬念了；Kubernetes毫无疑问笑到了最后。&lt;/p&gt;

&lt;h2 id=&quot;kubernetes为什取得最后的成功&quot;&gt;Kubernetes为什取得最后的成功&lt;/h2&gt;
&lt;p&gt;略去商业和管理上的原因不谈，来自Google的这篇论文帮我们讲述了&lt;strong&gt;深层次上的技术原因&lt;/strong&gt;：原来Kubernetes从来不是一个表面上看起来很年轻稚嫩的开源项目。
一切成功的&lt;strong&gt;背后有着Google几十年&lt;/strong&gt;来分布式系统开发、部署、管理经验的演进在助推。&lt;/p&gt;

&lt;p&gt;在Google内部，其分布式大规模应用的部署和管理平台的开发经历了三代，每一代项目都是在前一个的基础上做了进一步的改进&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Borg是第一代分布式基础设施管理系统，可以管理长期运行的服务和短时间运行的批处理作业任务，但是两者是采用两个内部的组件来完成的。这是一个早在Google成立之初就开始存在并继续完善的项目，传言很多牛人在进入Google之前本来都以开发开源的好用的工具为乐，一旦被Google收入囊中之后就&lt;strong&gt;因为Borg太好用了而不再继续投入开源事业&lt;/strong&gt;；这也侧面表明了Borg的强大。&lt;/li&gt;
  &lt;li&gt;Omega是基于Borg的第二代产品&lt;/li&gt;
  &lt;li&gt;Kubernetes则是今天我们看到的站在Omega项目肩上的产品&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;borg的开发经验&quot;&gt;Borg的开发经验&lt;/h3&gt;
&lt;p&gt;在开发Borg的过程中，Google认识到大部分情况下&lt;strong&gt;很多应用程序实际在运行时占用的资源比它们声明的要少得多&lt;/strong&gt;。而管理平台需要做的事情就是尽力地共享物理的机器，提高资源的使用效率。&lt;/p&gt;

&lt;p&gt;从一开始，Google就奔着使用已有的Linux内核中的命名空间的概念做&lt;strong&gt;轻量级的资源隔离&lt;/strong&gt;，从而有效地避开了虚拟机带来的巨大的性能开销。
在此过程中，&lt;strong&gt;Google本身也贡献了大量的代码到Linux内核相关cgroups控制的子系统&lt;/strong&gt;中，他的出发点其实还是为了服务于自己需要面临的隔离不同的应用程序负载的目的。&lt;/p&gt;

&lt;p&gt;从这个角度看，Kubernetes的核心概念甚至比外面看到的开源出来的Docker还要早的多，只是&lt;strong&gt;Google密而不发&lt;/strong&gt;而已。也许DockerSwarm/MeSos之类的平台才算作起步较晚。&lt;/p&gt;

&lt;h3 id=&quot;omega&quot;&gt;Omega&lt;/h3&gt;
&lt;p&gt;随着Google内部的应用程序越来越多地被部署到Borg上，各种&lt;strong&gt;复杂、使用不同编程语言、结构各异的&lt;/strong&gt;应用程序对这一基础设施平台提出了越来越高的要求，
而Borg一直被期望于完成包括&lt;strong&gt;服务发现、负载均衡、自动扩展、机器生存周期管理、资源分配额度控制&lt;/strong&gt;等任务。
为了提升Borg中发现的一些问题，Google在吸取Borg经验的基础上开发了Omega系统。&lt;/p&gt;

&lt;p&gt;Omega的开发并&lt;strong&gt;没有复用Borg的代码但是吸取了Borg的设计思想&lt;/strong&gt;。
它将集群的状态信息保存在一个&lt;strong&gt;基于Paxos算法控制的的一个中心化的数据库&lt;/strong&gt;中，然后系统的各个部分的控制模块都可以来访问这个中心化的数据存储。当有冲突发生的时候，Omega使用&lt;strong&gt;乐观并发锁&lt;/strong&gt;来协调访问冲突。&lt;/p&gt;

&lt;p&gt;这样做的好处是系统被解耦成为若干个互相不干扰的子部分，尤其是&lt;strong&gt;多个控制调度模块&lt;/strong&gt;的想法是继承了Borg的成功经验。&lt;/p&gt;

&lt;h3 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h3&gt;
&lt;p&gt;Kubernetes是外部容器技术已经变得流行之后，Google用云时代的Go语言重写之后开源给社区使用的第三代产品。
中心化的数据被一个可以被&lt;strong&gt;多个调度模块共享的状态数据库锁代替&lt;/strong&gt;(来自于etcd的贡献)，而各个分布式的控制器则通过云时代的&lt;strong&gt;REST API的方式&lt;/strong&gt;来访问对象的状态。&lt;/p&gt;

&lt;p&gt;Kubernetes的重心是&lt;strong&gt;面向容器云时代的开发者&lt;/strong&gt;，他们需要编写能够在集群中运行的基于容器的应用程序。
因此它的设计目标是要尽量简化复杂分布式系统的部署和管理，同时复用前辈产品中的基于容器的良好的资源使用率。&lt;/p&gt;

&lt;h2 id=&quot;设计经验和知识&quot;&gt;设计经验和知识&lt;/h2&gt;
&lt;p&gt;论文中总结了一下几个方面的经验和知识：&lt;/p&gt;

&lt;h3 id=&quot;容器技术&quot;&gt;容器技术&lt;/h3&gt;
&lt;p&gt;容器的概念无疑是最核心的技术；而&lt;strong&gt;容器概念本身却是一个很古老的技术&lt;/strong&gt;，从早期的基于&lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt;的单纯的Unix根文件系统隔离技术，
到FreeBSD系统提出的Jails的概念开始为进程ID加上名字空间隔离，
再到后来的Solaris系统实现了完整的网络空间隔离，提出了Solaris Zone的概念，这些&lt;strong&gt;最底层的核心技术的演进其实是非常缓慢&lt;/strong&gt;的。某种程度上说这些底层技术才是计算机科学最核心的领域知识。&lt;/p&gt;

&lt;p&gt;Linux容器技术其实是基于以上这些既有的技术逐步发展壮大起来的。
它本身提供了一系列&lt;strong&gt;基于CPU和内存资源的隔离控制&lt;/strong&gt;手段，并在&lt;strong&gt;内核层面&lt;/strong&gt;防止一个进程干扰到另外一个进程的执行，Borg利用了这些技术然而做的并不是特别完善。
比如对于一些Linux内核不能控制和隔离的资源，容器技术就无能为了了，这样的例子包括&lt;strong&gt;CPU的L3缓存和内存带宽这些&lt;/strong&gt;，就是虚拟机技术可以对其管理的对象而提供的隔离和保护，而容器却毫无办法。&lt;/p&gt;

&lt;p&gt;现代容器技术处理提供资源隔离外，另外还有一个很重要的机制是实现&lt;strong&gt;应用程序依赖文件的打包和部署&lt;/strong&gt;。Google内部使用了一个叫MPM的工具来构建和部署。这一技术本身和容器的关系就如同docker容器和docker image之间的关系。&lt;/p&gt;

&lt;h3 id=&quot;面向应用程序的基础设施&quot;&gt;面向应用程序的基础设施&lt;/h3&gt;
&lt;p&gt;Google越来越深地意识到，容器化技术的最大的益处早就超越了单纯的提高硬件资源使用率的范畴；更大的变化在于&lt;strong&gt;数据中心运营的范畴已经从以机器为中心迁移到了以应用程序为中心&lt;/strong&gt;。
容器封装了应用程序所依赖的程序开发环境，从而使得程序开发人员可以无需关注繁琐的操作系统和机器的细节。
同时因为设计良好的容器和容器镜像包裹了应用程序，&lt;strong&gt;管理容器也就等同于应用程序管理&lt;/strong&gt;，而不再是管理机器本身。&lt;/p&gt;

&lt;p&gt;这一管理中心的转移极大地提高了应用程序部署和管理的效率。&lt;/p&gt;

&lt;h4 id=&quot;应用开发环境&quot;&gt;应用开发环境&lt;/h4&gt;
&lt;p&gt;最初内核提供的类似于cgroup/chroot/namespace这样的机制的目的是想保护应用程序运行时候的资源使用，避免相邻的应用程序（他们共享一个内核）带来的噪音和干扰。
随着这些隔离能力和容器镜像被结合在一起，甚至&lt;strong&gt;使用不同操作系统（可能是异构的系统）的应用程序也可以在同样的内核里面被调度&lt;/strong&gt;执行。&lt;/p&gt;

&lt;p&gt;这种镜像和实际运行的操作系统的解耦使得为开发环境和实际生产环境部署同样的运行环境成为可能；从而又极大地提高了部署的可靠性，经由&lt;strong&gt;减少环境的不一致&lt;/strong&gt;而加速了应用程序开发的步伐。&lt;/p&gt;

&lt;p&gt;这种做法能够成功的关键在于使用一个具有&lt;strong&gt;良好隔离性的容器镜像&lt;/strong&gt;，保证该镜像可以封装应用程序所需要的几乎所有的依赖；
然后唯一剩下的依赖是&lt;strong&gt;容器和宿主内核之间的系统调用&lt;/strong&gt;接口。
因为这些系统接口是非常稳定很少变更的，容器镜像的可移植性得到了极大的提高。&lt;/p&gt;

&lt;p&gt;当然这样做也不是万无一失，应用程序仍然可能通过调用一些没有被隔离的调用而逃逸到宿主内核空间中，譬如使用socket套接字的选项，读取&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;文件系统，或者使用底层的&lt;code class=&quot;highlighter-rouge&quot;&gt;ioctl&lt;/code&gt;接口等。
好在正在进行中的&lt;strong&gt;开放容器接口项目OCI可以逐渐理清这些灰色地带&lt;/strong&gt;，逐步提高容器的隔离能力。&lt;/p&gt;

&lt;p&gt;容器镜像良好的隔离性至关重要；而Borg的做法是强迫&lt;strong&gt;所有的二进制程序都使用静态编译的方法&lt;/strong&gt;来严格地保证程序库的一致性。
这样能工作良好的基本前提是Google内部又一个巨大的单一代码库。
即便如此，Borg的容器镜像还是没有达到足够好的紧凑性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础镜像是按照每个机器一份的方式来安装的，而不是按照每个容器一份&lt;/li&gt;
  &lt;li&gt;基础镜像中包含了类似&lt;code class=&quot;highlighter-rouge&quot;&gt;tar&lt;/code&gt;和libc库这样的应用程序工具和库，导致每次升级基础镜像所有的运行的容器必须得随之升级，这样反而对正在运行得应用带来了巨大的影响，即便是这样的基础镜像升级并不是很常见&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;幸好现代的Docker技术已经&lt;strong&gt;将这些抽象限制的更为严格&lt;/strong&gt;，我们今天无需为类似的问题担忧。&lt;/p&gt;

&lt;h4 id=&quot;管理任务的基本单元迁移到了容器&quot;&gt;管理任务的基本单元迁移到了容器&lt;/h4&gt;
&lt;p&gt;构建面向容器的API而不是面向机器的API这一范式的转变带来了如下巨大的好处&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;它减轻了应用程序开发团队对特定的机器细节或者操作细节可能对程序造成巨大影响的担忧&lt;/li&gt;
  &lt;li&gt;它赋予了基础设施管理团队&lt;strong&gt;自由部署新的硬件或者升级操作系统&lt;/strong&gt;方面的巨大的灵活性，这些升级几乎不对运行的应用程序造成太多影响&lt;/li&gt;
  &lt;li&gt;它将从机器收集到的诸如&lt;strong&gt;CPU／内存使用情况的统计数据和应用程序自身关联起来&lt;/strong&gt;，这样极大地提高了应用程序监控和干预的效率，尤其是我们想支持自愈、自动伸缩或者应对硬件故障和维护的时候，便利性得到了极大提高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;容器提供了一种抽象API的机制来完成应用程序运行状态到基础设施管理系统之间的信息流转，使得管理平台甚至无需直到具体的因公程序实现。
比如实现健康情况检查的系统仅仅依赖于容器应用提供一系列服务端点；Borg通过让&lt;strong&gt;应用程序提供一些HTTP服务端点&lt;/strong&gt;来完成，
而Kubernetes则可以支持一个用户声明的HTTP端点或者一个可以运行在容器里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;命令。
利用该机制，管理平台可以在检测到程序发生异常的时候，自动终止它并重启之，实现高级的自愈能力，这是&lt;strong&gt;高级可靠的分布式系统必须具备&lt;/strong&gt;的能力。&lt;/p&gt;

&lt;p&gt;容器管理系统还可以将资源限制情况、容器元数据信息发送给容器内的应用程序，而容器管理系统还可以提供&lt;strong&gt;基于应用程序级别的日志监控和性能诊断&lt;/strong&gt;，乃至于应用程序自定义的一些统计和控制信息。
从而我们很少需要像传统的管理一台Linux机器一样频繁地用ssh命令进入容器内用&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;命令来查看资源使用情况。&lt;/p&gt;

&lt;p&gt;监控是一方面的例子，同时传统的负载均衡、日志收集方式也不再是按照传统的依照机器调度分类的方式，而是采用按照应用程序分开处理的方式。
同时来自多个应用程序的信息也不会担心被互相干扰和混淆，因为任何一个&lt;strong&gt;应用程序的信息都有唯一的身份识别&lt;/strong&gt;信息（容器管理系统可以唯一地编号和识别）。
对应用程序开发者而言，这样&lt;strong&gt;构建、管理和调试应用程序都变得更加轻松&lt;/strong&gt;容易。&lt;/p&gt;

&lt;h4 id=&quot;容器封装的分级&quot;&gt;容器封装的分级&lt;/h4&gt;

&lt;p&gt;Borg里容器被分为两级，&lt;strong&gt;最外层的提供对于池化资源的集合&lt;/strong&gt;，而内层的容器则负责具体的部署；外层的容器被成为Alloc。
Kubernetes里外层的容器被叫做POD。
Borg甚至允许应用程序跑在最外层的容器外面，然而这一设计变成了一系列麻烦的来源，所以Kubernetes&lt;strong&gt;统一化了所有的应用程序部署和调度&lt;/strong&gt;方法。&lt;/p&gt;

&lt;p&gt;一种常见的范式是将一个复杂的应用程序的一个实例防止在外层的容器中，然后将其内部的不同的部分防止在不同的内部子容器中。
这样做的好处是一个应用的不同子部分可以有不同的逻辑资源上下文，享有不同的日志等，便于解耦和快速开发。&lt;/p&gt;

&lt;h3 id=&quot;容器编排仅仅是个开始&quot;&gt;容器编排仅仅是个开始&lt;/h3&gt;
&lt;p&gt;起初Borg仅仅是一个编排不同容器以调高资源使用率的系统，随着系统的演进，Google发现&lt;strong&gt;如下的服务也可以被该容器管理系统所提供&lt;/strong&gt;，这些服务今天已经成为微服务治理的一些通用基础设施&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;域名服务和服务发现&lt;/li&gt;
  &lt;li&gt;主节点选举&lt;/li&gt;
  &lt;li&gt;应用程序可感知的负载均衡&lt;/li&gt;
  &lt;li&gt;水平方向和垂直方向两个维度的自动扩展&lt;/li&gt;
  &lt;li&gt;用于部署应用程序二进制文件和配置数据的外围工具的自动部署&lt;/li&gt;
  &lt;li&gt;工作流控制工具，比如运行运行多个并行的批处理作业的流水线，并且里面的子任务会存在相互依赖的逻辑关系等&lt;/li&gt;
  &lt;li&gt;收集、汇聚容器信息并将它们显示于专门的仪表盘，或根据里面的条件自动产生告警的能力&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;对象元信息&quot;&gt;对象元信息&lt;/h4&gt;
&lt;p&gt;这些工具本来是被创造出来解决一些具体服务的特定问题的，随着它们被更广泛的采纳和部署，慢慢地它们就&lt;strong&gt;演进成了更为通用的工具&lt;/strong&gt;使得所有的不属于容器中的微服务都可以采用。
由于这种做法是通过演进地方式得来的，早期的Borg系统中集成这些服务会&lt;strong&gt;遭遇诸如文件位置等类似的惯例带来的部署&lt;/strong&gt;复杂性。
Kubernetes则尝试采用&lt;strong&gt;一致的基于API的方式来降低&lt;/strong&gt;复杂性。
Kubernetes里面使用ObjectMetadata、Specification、Status这三类元信息，并&lt;strong&gt;将它们放置在所有的API对象的属性&lt;/strong&gt;集中。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectMetadata&lt;/code&gt;包含了对象的&lt;strong&gt;名字、UUID、版本号&lt;/strong&gt;等信息，所有的API队形都包含同样的结构&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spec&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Status&lt;/code&gt;字段则&lt;strong&gt;依API对象的类型的不同而具有不同的结构&lt;/strong&gt;；前者用于描述期望的状态，而后者用于展示目前的对象状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;通用api的好处&quot;&gt;通用API的好处&lt;/h4&gt;
&lt;p&gt;统一形式的API带来的好处是多重的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;学习系统的API变得简单 - 尽管很多初学者反应Kubernetes非常不好理解有陡峭的学习曲线&lt;/li&gt;
  &lt;li&gt;创建通用的工具变得简单，因为API对象具有很多相似的地方&lt;/li&gt;
  &lt;li&gt;开发&lt;strong&gt;体验的一致性&lt;/strong&gt;，这是上面两点自然而然的结果&lt;/li&gt;
  &lt;li&gt;未来扩展新的对象更加容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些概念是Kubernetes从Borg系统设计上继承之后新发展出来的&lt;strong&gt;超强的可扩展能力&lt;/strong&gt;；这种扩展能力对于平台性的应用来说是至关重要的。&lt;/p&gt;

&lt;h5 id=&quot;一致性&quot;&gt;一致性&lt;/h5&gt;
&lt;p&gt;Kubernetes的一致性是通过&lt;strong&gt;不同API对象相互之间的解耦&lt;/strong&gt;来实现的；各个API组件基本关注于不同的任务，它们除了共享这些基本的元信息之外，
互相之间是&lt;strong&gt;尽量地保持功能上的正交&lt;/strong&gt;。
比如负责无状态服务实例部署复制&lt;code class=&quot;highlighter-rouge&quot;&gt;replication&lt;/code&gt;的控制器和负责自动扩展的控制器互相之间就可以互不干扰；前者负责控制有多少个POD实例需要被创建，而后者会基于这一能力来动态地调整POD的个数，而无需关心这些POD具体是怎么被创建和删除的。&lt;/p&gt;

&lt;p&gt;这一设计思路对应到设计模式上来说就是&lt;strong&gt;单一职责模式&lt;/strong&gt;的直接化用。&lt;/p&gt;

&lt;p&gt;一致性还&lt;strong&gt;体现在这些API对象的通用的外观&lt;/strong&gt;上，比如Kubernetes提供了三种POD级别部署复制的控制器&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReplicationController&lt;/code&gt;负责运行诸如Web服务器这样的多实例负载均衡的无状态服务&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DaemonSet&lt;/code&gt;保证单个集群节点上总有一个唯一的实例再运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt;表示一个运行完毕就结束的批处理作业
尽管它们内部的控制逻辑和策略完全不同，它们都共享同样的POD模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;控制器协调调度循环&quot;&gt;控制器协调调度循环&lt;/h5&gt;
&lt;p&gt;Borg、Omega、Kubernetes都遵循了同样的&lt;strong&gt;控制器协调调度循环&lt;/strong&gt;的的概念来增强系统的灵活性。该机制的大噶i思路是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;循环&lt;strong&gt;比较&lt;/strong&gt;对象的期望状态(&lt;code class=&quot;highlighter-rouge&quot;&gt;spec&lt;/code&gt;)和当前的实际运行期状态(&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;如果发现不一致，则&lt;strong&gt;执行控制器对应的动作&lt;/strong&gt;来尝试协调差异&lt;/li&gt;
  &lt;li&gt;重新回到第一步继续这个循环&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个处理思路是基于观察者－控制器模式，而不是基于复杂的状态图，因此它更容易处理系统错误。
任何时候控制器因为失效等原因需要重启的时候，它只需要从上次的状态继续运行下去就可以了。&lt;/p&gt;

&lt;p&gt;这种结合了&lt;strong&gt;微服务和微控制循环&lt;/strong&gt;的设计模式是一种典型的&lt;strong&gt;通过编排来达成控制&lt;/strong&gt;的思想。该设计思路是被精心选择设计出来的，并有意和传统的基于中心化的编排系统不同。
中心化的编排系统可能一开始起步比较容易，当系统的规模和需求变得更加复杂的时候，它就会因为&lt;strong&gt;过于严格而变得更加不容易维护&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;需要避免的一些陷阱&quot;&gt;需要避免的一些陷阱&lt;/h2&gt;
&lt;p&gt;Google自己总结了一些自己所犯过的错误，同时也期望其他人不要再误入同样的误区。&lt;/p&gt;

&lt;h3 id=&quot;不要尝试让容器管理系统直接来管理端口&quot;&gt;不要尝试让容器管理系统直接来管理端口&lt;/h3&gt;
&lt;p&gt;早期的Borg系统由于允许所有的服务共享宿主机的IP地址，所以它为每个容器都分配了唯一的端口号，同时该端口号成为平台调度处理的一部分。
问题是当容器被移动到一个新的机器上的时候，它会得到一个新的端口号；甚至它再同一个物理机器上重启的时候也可能重新分得一个端口号。
这样的缺陷是传统的&lt;strong&gt;基于名字的DNS服务将不再正常工作&lt;/strong&gt;，容器管理平台不得不创建私有的机制来解决这个问题。
更糟糕的是，&lt;strong&gt;端口号不能很轻松地潜入的URL中&lt;/strong&gt;，服务要想正常工作，基于端口的&lt;strong&gt;重定向&lt;/strong&gt;不得不被适应来保证应用服务在这些异常常见下还可以正常工作。&lt;/p&gt;

&lt;p&gt;基于这些教训，Kubernetes的设计就采用了&lt;strong&gt;每个POD分配一个IP地址&lt;/strong&gt;的策略，使得IP地址成为POD唯一的网络身份标识。这样一来，
已有的第三方基于IP/DNS的工具都可以正常工作了，不管用户选用基于SDN的网络还是基于传统单机的网络方案。&lt;/p&gt;

&lt;h3 id=&quot;不为容器编号而是采用标签&quot;&gt;不为容器编号，而是采用标签&lt;/h3&gt;
&lt;p&gt;当平台允许用户很方便地创建容器的时候，用户总是倾向于创建大量的容器；很快平台就需要提供一种机制来对它们进行分组化的组织。
Borg提供了一种叫做jobs的机制来对容器进行分组，一个job里面包含多个执行等同任务的容器，它们用基于0开始的连续的整数下标作为索引。
看起来种方式很自然和直接，然而随着复杂性的增加这一方案很快就露出了它的弊端&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这个数组中的&lt;strong&gt;下标不得不承担双重职责&lt;/strong&gt;：定位某个实例的拷贝，并在程序员需要调试的时候指向老的版本&lt;/li&gt;
  &lt;li&gt;当位于中间的一个拷贝退出的时候，数组&lt;strong&gt;下标就会出现空洞&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;需要执行&lt;strong&gt;横跨多个集群的任务&lt;/strong&gt;的时候，下标的安插就显得很困难&lt;/li&gt;
  &lt;li&gt;Borg&lt;strong&gt;无法支持应用程序层面的基于角色的版本&lt;/strong&gt;指定，比如用户想用基于金丝雀部署的方式来滚动升级，这种死板的分配方式就无能为力，以至于用户不得不将类似信息编码到Job名字上的方式来间接达成目标&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes则基于这些问题的考虑而采用了基于&lt;strong&gt;松散的标签的方式来对容器进行分组&lt;/strong&gt;。如果一个容器头上打了多个标签，那么它就同时隶属于不同的组。
Kubernetes支持&lt;strong&gt;动态地添加、删除和修改&lt;/strong&gt;这些标签，并支持用&lt;strong&gt;标签选择器的类似集合的语法&lt;/strong&gt;来查询某个标签下的所有容器。&lt;/p&gt;

&lt;h3 id=&quot;当心不必要的所有权绑定&quot;&gt;当心不必要的所有权绑定&lt;/h3&gt;
&lt;p&gt;Borg系统中，一个任务是不能独立于它的Job而单独存在的；创建了一个Job的同时也就创建了对应的Task；随后这些Task就永远地和对应的Job关联起来；删除了Job也同时意味着对应的Task被删除。
这样虽然方便但是却有一个大大的缺陷：因为只有一个基于下标的分组，Borg需要管理所有的可能的场景。
如果一个Job需要存储仅仅对某个服务有意义的参数，那么用户就必须寻找一种间接的方式来完成。&lt;/p&gt;

&lt;p&gt;Kubernetes则通过上述的基于Label的解耦方式来&lt;strong&gt;分离POD的生存周期管理和容器选择&lt;/strong&gt;策略。
这样的灵活性允许下面这种用户场景：当用户想对他的服务POD进行调试的时候，他可以去掉某个POD头上的标签，然后后台的部署控制器就会注意到这个标签的变更，进而将其从服务实例列表中删除。
此时用户就可以在这个运行的POD上做调试而不用担心对正在运行的业务造成任何影响。
同时后台的控制器会根据实现定义的POD数量要求，重新创建一个新的POD来替换这个不正常的POD实例。&lt;/p&gt;

&lt;h3 id=&quot;不要泄露原始状态&quot;&gt;不要泄露原始状态&lt;/h3&gt;
&lt;p&gt;API架构的不同是Kubernetes和它的前辈们的主要的不同。&lt;/p&gt;

&lt;p&gt;Borg是一个基于单体架构的复杂软件，它的核心模块直到所有的API操作的予以逻辑。其内部维护了包括机器和机器上跑的Job和Task的集群状态控制逻辑，并使用基于Paxos的中心化存储来保存这些状态信息。&lt;/p&gt;

&lt;p&gt;Omega则不在保留中心化的状态管理逻辑，而仅仅保留了一个处于从属角色的全局的状态存储用于异常恢复。所有的逻辑语义控制操作则被下放给了数据存储的使用端，它们会直接读写对应的数据存储。
实现上每一个Omega组件使用了完全相同的客户端库来做数据结构的序列化、反序列化，重试和语义一致性处理。&lt;/p&gt;

&lt;p&gt;Kubernetes走了一条中间路线：既保留了Omega的&lt;strong&gt;去中心化存储架构的扩展性和灵活性&lt;/strong&gt;，又复用了&lt;strong&gt;系统范围的数据修改策略的一致性&lt;/strong&gt;。
这种做法依赖于一个中心化的API Server，该Server&lt;strong&gt;屏蔽了底层存储和对象校验、默认值初始化、版本处理的细节&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;悬而未决的问题&quot;&gt;悬而未决的问题&lt;/h2&gt;
&lt;p&gt;Google同时列举了一些截至论文发表时还没有很好解决的问题，以便社区可以进一步探讨找到更好的解决方案。&lt;/p&gt;

&lt;h3 id=&quot;配置问题&quot;&gt;配置问题&lt;/h3&gt;
&lt;p&gt;如何处理传递给应用程序容器它们想使用的配置数据，是Google自己所遇到的耗费了最多智力和代码的最显著的一个问题。
这个问题的本质上，我们需要找到一种方式传递一系列的值给应用程序，而不需要用写死的方式传递给它们。
Borg历史上的这类信息包含&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;繁琐的信息推导，如默认的重启策略&lt;/li&gt;
  &lt;li&gt;调整和校验应用程序的命令行参数传递&lt;/li&gt;
  &lt;li&gt;可以给一些列程序共同使用的配置文件模板库&lt;/li&gt;
  &lt;li&gt;镜像文件版本规范&lt;/li&gt;
  &lt;li&gt;发布管理工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想解决这些问题，配置管理系统可能不得不创造新的领域特定语言，并最终衍生出一套图灵完备的语言；最终这又变成了程序员想拜托的&lt;strong&gt;配置即代码&lt;/strong&gt;的窘境。
因为这种方式本身并没有降低运维的复杂性，还将&lt;strong&gt;负担从真正的业务代码变成语言转嫁到了领域特定的语言&lt;/strong&gt;上，给调试和修改带来新的麻烦。&lt;/p&gt;

&lt;p&gt;Google认为最终可能的方案是采用一些简单的数据语言格式，比如JSON或者YAML格式；因为它们自身有完整的工具链，并且被大部分人所熟悉和理解。&lt;/p&gt;

&lt;h3 id=&quot;依赖管理&quot;&gt;依赖管理&lt;/h3&gt;
&lt;p&gt;如果一个服务自身需要依赖于其它服务才能运行，一个很自然的想法是将依赖管理和部署的任务交给容器管理平台，从而让它可以自动地&lt;strong&gt;根据依赖规则来管理相关联的服务的发布、部署和升级&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;乍一看似乎一个基于传递依赖关系的有向图可以解决，然而现实应用的时候却有不少其它的复杂性需要考虑而不仅仅是一个启动状态的处理&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;依赖于外部认证服务并且需要传入对应的认证、授权信息，这期间可能需要启动一个外部服务的连接&lt;/li&gt;
  &lt;li&gt;传递依赖的过程中，服务的认证、授权、计费信息&lt;strong&gt;可能需要被通盘处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时如何&lt;strong&gt;保持这些依赖信息总是和程序的开发更新步骤一致&lt;/strong&gt;，也没有很好的答案，因为很多时候这些信息的追踪和更新都是靠已于出错的人工步骤来完成的；该事实反而加强了自动化这些繁琐操作的动机。&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;Google认为它已经将自己十数年构建容器管理系统的经验和教训总结在最新的Kubernetes项目中了；论文的最后Google号召社区能够加入这一开源社区，共同努力来提升容器管理基础设施的能力，使云时代的程序员能得到最大的效率提升。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="kubernetes" /><category term="notes" /><category term="engineering" /><category term="tools" /><category term="container" /><category term="cloud" /><category term="design" /><summary type="html">Kubernetes是目前炙手可热的云计算管理基础设施平台，并且是一个诞生不久就迅速鉴定了业界实际标准地位的一个容器编排平台。</summary></entry><entry><title type="html">C++20 - 下一个大版本功能确定</title><link href="https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine/" rel="alternate" type="text/html" title="C++20 - 下一个大版本功能确定" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/06/23/cpp-20-modules-concepts-coroutine/">&lt;p&gt;C++20的功能特性已经于3月份冻结，显然&lt;strong&gt;这次终于来了一波大的改进&lt;/strong&gt;，而不再是像之前C++14/C++17那般小打小闹的做小步快跑，尤其是三个讨论很久的大feature终于被合入主干；并且这些feature终将会极大地影响后续C++代码的书写方式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;核心语言特性终于有了大变化&quot;&gt;核心语言特性终于有了大变化&lt;/h2&gt;
&lt;p&gt;新的版本之所以被认为是下一个大的版本，主要原因还是来自于核心语言特性的扩充和简化。看起来好像两个目标有些互相矛盾，但是内在的逻辑其实还是统一的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;扩充新的特性可以弥补之前一些遗留已久的功能限制，&lt;strong&gt;方便提高程序员的生产力&lt;/strong&gt;，减少社区中长期存在的奇技淫巧侵蚀程序员宝贵的心智空间；&lt;/li&gt;
  &lt;li&gt;简化的方向主要是出于“照顾”新手程序员，帮助他们&lt;strong&gt;更快地上手产生生产力&lt;/strong&gt;而不是匍匐在陡峭的学习曲线上靠长期的实践积累来摸索，从而培养下一代的新鲜血液，否则语言就会因为失去活力而慢慢消亡；这显然不是标准委员会愿意看到的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从这两个角度看，也许片面地评价标准委员会的资深专家们为“学院派”或者“老学究”，总归是有些不合适的；因为C++一开始在90年代上半段的风靡完全是因为它是一门实用的程序语言。
只是随着时间的推进，很多&lt;strong&gt;早期做出的设计决策多多少少被整个产业界的各色各样的业务需求催生的奇技淫巧所侵蚀&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;尤其是&lt;strong&gt;模板元编程的流行和语言特性本身的滞后&lt;/strong&gt;带来的矛盾一直没有得到合适的处理，背后的原因正是标准委员会需要照顾已有的软件代码的兼容性（当然背后也有很多大公司的利益考量），妥协再妥协；最终演变成不得不变的地步。&lt;/p&gt;

&lt;h2 id=&quot;concepts&quot;&gt;Concepts&lt;/h2&gt;
&lt;p&gt;像concept这样可以&lt;strong&gt;明显提升程序员生活质量&lt;/strong&gt;的特性(想象一下用错了一个容器的成员函数之后GCC打印出来的”成吨”的编译错误，很多程序员形容是恨不得捏着鼻子绕着走)，愣是从C++03定稿之后就被提出出来，却活生生被推迟了一次又一次，甚至GCC的版本库上的concepts分支都经历了加上来又移除掉的曲折过程 - &lt;strong&gt;速度和质量&lt;/strong&gt;始终是一对很难权衡的矛盾。&lt;/p&gt;

&lt;p&gt;幸好，经历了&lt;strong&gt;十几年的再三讨论&lt;/strong&gt;，concept这一模板元大杀器终于被投票送进了C++20标准的正式列表里。&lt;/p&gt;

&lt;p&gt;关于Concepts最好的介绍当然是Bjarne自己的这篇&lt;a href=&quot;http://www.stroustrup.com/good_concepts.pdf&quot;&gt;Concepts: The Future of Generic Programming&lt;/a&gt;的文章，
另外一个比较好的描述来自于&lt;a href=&quot;https://en.cppreference.com/w/cpp/concepts&quot;&gt;cppreference&lt;/a&gt;；简单来说，它完成的事情就是用来描述泛型定义中，关于&lt;strong&gt;类型参数的约束和校验&lt;/strong&gt;；
出于零成本的考虑，我们需要做到这个校验可以&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在&lt;strong&gt;编译期间完成&lt;/strong&gt;检查，对生成的实际代码没有影响（就像手写的代码一样）&lt;/li&gt;
  &lt;li&gt;具备&lt;strong&gt;定义良好的接口&lt;/strong&gt;形式，可以方便地进行组合&lt;/li&gt;
  &lt;li&gt;尽量地保持通用性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用concepts&quot;&gt;使用Concepts&lt;/h3&gt;

&lt;p&gt;通过使用concepts，传统的模板元编程方面关于编译错误的痛点可以得到极大改善，编译器可以给出更加符合人类直觉的错误提示。
比如标准库中的&lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;std::find&lt;/a&gt;算法的声明如下：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InputIt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputIt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;strong&gt;两个模板参数其实有更多额外的要求&lt;/strong&gt;用传统的语法是没法表达的，第一个类型参数&lt;code class=&quot;highlighter-rouge&quot;&gt;Input&lt;/code&gt;我们期望它是一个可遍历的迭代器类型，并且其中的元素类型需要和&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;类型匹配，并且该类型能够用来做相等比较。
这些&lt;strong&gt;约束条件在现有的语言标准中都是隐性&lt;/strong&gt;的，一旦用错，编译器就会拿海量的错误信息来招呼你，因为编译器背后会使用SFINAE这样的语言特性来比较各种重载并给出一个常常的candidate列表，然后告诉你任何一个尝试都没有成功，所以失败了。&lt;/p&gt;

&lt;p&gt;Concepts相当于将这些要求用一种显而易见的方式给出来，比如我们想表述一个在序列容器上查找的类似算法，可以用concepts来描述为&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//using alias
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候如果使用不满足条件的输入参数，编译器会直观地告诉我们错误的具体原因&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;waldo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//okay
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//error! - can't compare string and double
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//okay
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;waldo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//error! - can't compare double and string
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然这里的例子有点啰嗦，出于&lt;strong&gt;节约键盘敲击次数&lt;/strong&gt;的考虑（Java太啰嗦了？原来的模板元函数的写法也已经够啰嗦的了！），可以进一步简化这个写法，将简单的concepts约束直接嵌入到声明的地方：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Iterator_of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义concepts&quot;&gt;自定义concepts&lt;/h3&gt;
&lt;p&gt;对于上面的简单的concepts，标准库已经提供了一个开箱可用的封装，不过&lt;strong&gt;出于学习目的自己动手做一个轮子&lt;/strong&gt;也很简单。比如用上面的比较为例，可以写作&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;concept&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Equality_comparable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//compar with ==, and should return a bool
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//compare with !=, and should return a bool
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;语法上和定义一个模板元函数很想象，所不同的地方是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这里我们定义的对象是一个关于类型的检查约束&lt;/li&gt;
  &lt;li&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;requires&lt;/code&gt;部分引申出具体的检查约束，必须同时实现操作符相等和不相等，两个操作符都需要返回bool类型&lt;/li&gt;
  &lt;li&gt;整个concept本身可以用在逻辑表达式中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;简化concept的格式负担&quot;&gt;简化concept的格式负担&lt;/h3&gt;
&lt;p&gt;如果能将简单的事情变得更简单，为什么不更进一步呢？这个设计哲学是C++的核心设计思想之一（参见Bjarne的D&amp;amp;E CPP），考虑下面的例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;Sortable&lt;/code&gt;表示某个可以被排序的容器类型；因为concept也是用于限制类型，而函数的参数也是用来限定类型，一个自然的想法就是逐步简化它&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//应用上述的简化方式，concept描述放在模板参数声明中
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;进一步地，去掉&lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt;部分的声明会更加简单，&lt;strong&gt;就像是一个普通的函数声明&lt;/strong&gt;，只不过参数类型是一个编译器可以检查的泛型类型&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sortable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样一来，就和其它语言中的接口很类似了，没错就和Java的JDK中的泛型接口很相似了；只是底层的实现技术是完全不一样的，Java由于根深蒂固的OO设计而不得不借助于类型擦除术；当然这个扯的稍微远了一点。&lt;/p&gt;

&lt;h3 id=&quot;auto类型的参数&quot;&gt;auto类型的参数&lt;/h3&gt;
&lt;p&gt;其实C++14里面已经允许了&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;作为函数参数的类型这一用法，显然它和&lt;code class=&quot;highlighter-rouge&quot;&gt;concept&lt;/code&gt;的简化写法完全不矛盾。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x实际上可以是任意类型!
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//x和y可以是任意的类型，可以不相同
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在多个参数的情况下， 如果我们想限定两个参数的类型必须总是一样，有一种很简单的机巧做到&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concept&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//任何类型都是Any
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//x和y的类型必须相同，尽管他们可以是任意类型
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;标准库中的预定义concepts&quot;&gt;标准库中的预定义concepts&lt;/h3&gt;
&lt;p&gt;C++20的标准库中预备了很多开箱即用的concepts，通过库的方式提供，用户只需要包含&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;concepts&amp;gt;&lt;/code&gt;库即可。
详细的列表可以参考&lt;a href=&quot;https://en.cppreference.com/w/cpp/header/concepts&quot;&gt;concepts header&lt;/a&gt;;从大的分来来看，包括&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;核心语言相关的concepts，比如判断类型是否相同，是否是由继承关系，是否可以赋值/拷贝/构造/析构/转换等。&lt;/li&gt;
  &lt;li&gt;比较相关的concepts，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;用来判断是否可以用在逻辑判断上下文中，&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparable&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparableWith&lt;/code&gt;声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;运算符是否表述等价关系；&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictTotallyOrdered&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictTotallyOrderedWith&lt;/code&gt;声明了比较运算符是否产生一个完全有序的结果&lt;/li&gt;
  &lt;li&gt;关于对象的concepts，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Movable&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Copyable&lt;/code&gt;，分别声明可移动和可拷贝（包含了可以swap），而&lt;code class=&quot;highlighter-rouge&quot;&gt;Semiregular&lt;/code&gt;声明对象是否可以被移动/拷贝/交换/默认构造；&lt;code class=&quot;highlighter-rouge&quot;&gt;Regular&lt;/code&gt;则等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;Semiregular&lt;/code&gt;加上&lt;code class=&quot;highlighter-rouge&quot;&gt;EquallyComparable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;关于函数调用的concepts，包含&lt;code class=&quot;highlighter-rouge&quot;&gt;Invocable&lt;/code&gt;(声明对应的类型可以想函数一样调用并用给定的一系列参数来作为输入参数)，&lt;code class=&quot;highlighter-rouge&quot;&gt;Predicate&lt;/code&gt;指定可调用的对象符合断言约束并返回bool，&lt;code class=&quot;highlighter-rouge&quot;&gt;Relation&lt;/code&gt;指定对应的可调用函数是一个二元函数；&lt;code class=&quot;highlighter-rouge&quot;&gt;StrictWeakOrdering&lt;/code&gt;则表明对应的函数满足&lt;a href=&quot;https://en.cppreference.com/w/cpp/concepts/StrictWeakOrder&quot;&gt;弱排序&lt;/a&gt;(具体细节需要一些逻辑数学知识)&lt;/li&gt;
  &lt;li&gt;用于range库的对象交换要求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应该可以预期后续的版本将会加入更多的支持。&lt;/p&gt;

&lt;h3 id=&quot;编译器的支持情况&quot;&gt;编译器的支持情况&lt;/h3&gt;
&lt;p&gt;GCC目前仍然是通过TS的方式来支持，编译时候需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;-fconcepts&lt;/code&gt;开关；
Clang的全功能支持已经在将近一年前&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/958sj9/clang_concepts_is_now_featurecomplete/&quot;&gt;在redit上宣布完工&lt;/a&gt;，只是其&lt;a href=&quot;https://clang.llvm.org/cxx_status.html&quot;&gt;官方的列表&lt;/a&gt;上依然没有更新。
MSVC则于更早一点宣布了完整的concept支持，只是我们需要Visual Studio 2017 15.7版本。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The MSVC compiler toolset in Visual Studio version 15.7 conforms with the C++ Standard!
&lt;br /&gt; https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总体上看来，GCC的开发进度有些迟缓，clange的也不算很透明，只有MSVC比较领先。&lt;/p&gt;

&lt;h2 id=&quot;模块化支持&quot;&gt;模块化支持&lt;/h2&gt;
&lt;p&gt;模块支持被写入新的语言核心，这一新的封装方式甚至可以认为是&lt;strong&gt;C++诞生35年以来最大&lt;/strong&gt;的一个新功能；
也是语言标准化以来，第一次通过修改核心语法允许程序员用一种&lt;strong&gt;全新的方式来描述带命名的信息封装边界&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;信息封装手法的更新&quot;&gt;信息封装手法的更新&lt;/h3&gt;
&lt;p&gt;传统的封装手段基本上都是采用如下的方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将用户自定义的结构或者类取一个名字&lt;/li&gt;
  &lt;li&gt;将相关联的细节都隐藏在这个名字的后面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不管是变量声明，函数定义，自定义的类，结构体，无一例外都满足这个模式。即使是模板元编程方法，其实也是通过类型绑定的方法间接地使用上述的封装手段。&lt;/p&gt;

&lt;h3 id=&quot;头文件的不完美封装&quot;&gt;头文件的不完美封装&lt;/h3&gt;
&lt;p&gt;除了上述的基本信息封装单元，C++中屈指可数的封装办法&lt;strong&gt;就剩下了从古老的C语言继承下来的头文件包含&lt;/strong&gt;的方式了。
在软件规模还局限在数万行代码一下的时代，使用头文件的方式一股脑将需要的东西都大包大揽在一个编译单元中，然后使用诸如唯一定义规则的方法让链接器在生成最终可执行代码或者库的时候做冲突检测是一个&lt;strong&gt;简单而优雅&lt;/strong&gt;的方案。
因为对于它想解决的问题规模来说，这样的解决方案就足够了。&lt;/p&gt;

&lt;p&gt;然而随着行业中软件项目的复杂性与日俱增，越来越多的商业项目&lt;strong&gt;需要数百甚至上千的头文件&lt;/strong&gt;被包含在一个编译单元中，这个时候既有的方式就越来越捉襟见肘&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;编译时间长&lt;/strong&gt;成为了一个突出的痛点，以至于实际项目中出于减少编译时间的考虑，聪明的工程师发明了如IWYU的&lt;strong&gt;头文件检测工具来缓解&lt;/strong&gt;这一问题&lt;/li&gt;
  &lt;li&gt;像pimp惯用法这样的技术手段可以减少放在头文件中的依赖，但是程序员却不得不&lt;strong&gt;承担额外内存申请&lt;/strong&gt;的开销（可能没有这么个指针很多对象本身就可以在栈上完成快速构造和析构），即使有了&lt;code class=&quot;highlighter-rouge&quot;&gt;unique_ptr&lt;/code&gt;来环境内存泄露的隐忧&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板方式提供的抽象代码无法声明，必须放置在头文件中内联实现&lt;/strong&gt;，否则对应的cpp文件在编译单元进行代码生成的时候会因为找不到定义而无法通过编译；之前提出的一些export声明也因为种种缺陷和编译器支持不力而被废弃&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单来看，&lt;strong&gt;现代的编程语言都或多或少带有模块化系统&lt;/strong&gt;；缺乏现代的模块化支持成为了C++语言的一种硬伤，严重制约了C++开发大项目的能力。&lt;/p&gt;

&lt;h3 id=&quot;模块化系统需要的核心功能&quot;&gt;模块化系统需要的核心功能&lt;/h3&gt;

&lt;p&gt;模块化是一个很自然的逻辑信息隐藏手段，一个良好的模块化系统应该允许&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;良好的信息隔离&lt;/strong&gt;，可以方便的指定哪些可以被外部访问，哪些应该不允许被外部访问&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;嵌套的隔离机制&lt;/strong&gt;，即可以在模块中嵌套子模块&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;细粒度的访问权限&lt;/strong&gt;控制，尤其是能提供模块内部/模块外部/子模块不同的访问权限则更好&lt;/li&gt;
  &lt;li&gt;和&lt;strong&gt;操作系统的文件访问系统保持一致的视图&lt;/strong&gt;，比如期望子文件夹可以对应子模块是一个非常符合直觉的方法&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;类似命名空间的隔离和访问&lt;/strong&gt;，比如支持重新导出一些模块中公开的可访问部分到另外一个空间中或者嵌套的命名、重命名模块等&lt;/li&gt;
  &lt;li&gt;和&lt;strong&gt;构建系统、打包系统&lt;/strong&gt;具有清晰易懂的交互接口；支持语言本身和IDE、语法检查等生态系统工具设施的无缝融合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要同时实现这些目标，并没有想象中的容易；其它一些流行的编程语言其实都小心仔细地对这些可能“讨好”程序员的目标做取舍，并在定义中详细地描述好限制。
比如Java一开始用Jar打包的方式来模拟模块，但是却由于不支持嵌套子模块中复杂的访问控制而遭到很多用户的不满；而Go语言中的模块和文件系统中文件名的纠葛同样也是Go语言中一个晦涩的知识点。
NodeJS通过NPM机制来提供模块化支持，然而其嵌套的打包方式和让人窒息的依赖树结构导致打包的时候需要依赖其它的第三方工具才能避免中招。&lt;/p&gt;

&lt;h3 id=&quot;后向兼容的艰难挑战&quot;&gt;后向兼容的艰难挑战&lt;/h3&gt;
&lt;p&gt;C++的模块机制是奔着替换旧有的头文件包含机制的目标来的，同时又因为需要照顾庞大的既有代码库不被破坏而&lt;strong&gt;不得不同时兼容头文件包含机制&lt;/strong&gt;。
和已有的其它语言特性一样，这种向后兼容带来的额外复杂性是否是必要的还又不小不同的声音，不过主流的声音还是决定走兼容的道路。&lt;/p&gt;

&lt;h3 id=&quot;基本语法&quot;&gt;基本语法&lt;/h3&gt;
&lt;p&gt;如果我们希望声明一个模块，可以用如下的语法&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//声明一个模块名字为example
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可以导出的函数
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为我们丢弃了头文件的方法，可以将该模块定义保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;example.cppm&lt;/code&gt;的文件中。这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;cppm&lt;/code&gt;后缀用于告诉编译器这是一个模块定义文件。&lt;/p&gt;

&lt;p&gt;假设我们希望使用该模块，则用如下的代码&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//导入上述定义的模块
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//调用example模块中的函数
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分离模块接口和实现&quot;&gt;分离模块接口和实现&lt;/h4&gt;
&lt;p&gt;如果我们想&lt;strong&gt;分离模块的声明和实现，将他们放在不同的文件&lt;/strong&gt;中，这样更符合传统的接口定义和实现分离的编写代码方法（其实可以看作是C++比Java更干净的一个地方），我们可以对上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;example.cppm&lt;/code&gt;做如下的修改&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后创建一个源代码文件，放置模块函数的实现&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//当前模块是example
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出于灵活起见，C++20支持将一个模块中声明的&lt;strong&gt;函数放在多个模块实现单元中分别实现&lt;/strong&gt;，这样更容易实现干净的代码，并提高编译速度。&lt;/p&gt;

&lt;h4 id=&quot;隔离权限指定&quot;&gt;隔离权限指定&lt;/h4&gt;
&lt;p&gt;模块访问权是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt;声明来指定的，&lt;strong&gt;没有声明的类或者函数等默认是不能被外部代码访问&lt;/strong&gt;的；基于声明的语法也决定了如果分离声明和实现，可见性在实现单元中其实是忽略的。&lt;/p&gt;

&lt;p&gt;为了避免代码变得过于啰嗦，语法层面上也支持通过括号作用于一次性声明多个导出函数或者类，比如&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doAnother&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internalImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//外部不可访问
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;模块和namespace是正交的语言设施&quot;&gt;模块和namespace是正交的语言设施&lt;/h4&gt;

&lt;p&gt;旧的C++标准早就支持通过namespace来实现信息封装和隔离，而新的module机制可以和namespace结合使用，提供清晰的隔离结构，比如&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doSth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doAnother&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;语言机制上提供了灵活的手段，但是程序员却要自己&lt;strong&gt;做好权衡，保持模块的粒度适中&lt;/strong&gt;，匹配实际的应用场景。&lt;/p&gt;

&lt;h4 id=&quot;模块重新导出&quot;&gt;模块重新导出&lt;/h4&gt;
&lt;p&gt;实际应用中，复杂的软件项目可能有很多形形色色的模块，它们可能处于不同的抽象单元；和应用代码比较近的上层模块可能&lt;strong&gt;需要将某些它自己可见的模块开放给上层代码直接使用&lt;/strong&gt;，提供重新导出的功能可以极大地提高信息封装的能力，提高模块的内聚度减少不必要的耦合。&lt;/p&gt;

&lt;p&gt;一个简单的方法就是将import的部分重新放在export块中，即下面的代码例子&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low_module1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low_module2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;标准库中的模块&quot;&gt;标准库中的模块&lt;/h3&gt;
&lt;p&gt;标准库中提供的工具函数和类显然应该被模块化，只需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;import std.xxx&lt;/code&gt;即可导入。
现代的WG21委员会的工作方式是有很多并行开发但是还没有进入主干库的”准标准库”，编译器可以选择实现，等到对应的规范成熟的时候，它们才会被正式地移入标准库中。&lt;/p&gt;

&lt;p&gt;Visual C++的封装方式如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.filesystem&lt;/code&gt;提供文件系统的库，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;experimental/filesystem&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.memory&lt;/code&gt; 提供智能指针的库，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;memory&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.regex&lt;/code&gt;提供对正则表达式库的封装，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.threading&lt;/code&gt;提供对线程库的支持（已经于C++11中正式支持），相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;atomic&amp;gt;/&amp;lt;future&amp;gt;/&amp;lt;mutex&amp;gt;/&amp;lt;thread&amp;gt;/&amp;lt;shared_mutex&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std.core&lt;/code&gt;包含了其它所有的标准库设施&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;潜在的争议&quot;&gt;潜在的争议？&lt;/h3&gt;

&lt;p&gt;作为一门有着30多年历史的语言，模块化机制的一个设计难点就是&lt;strong&gt;保持和古老的include机制（本质上是代码的复制）兼容该如何实现&lt;/strong&gt;。
好在WG21经过漫长的讨论终于实现了起码在理论上完美的兼容 - 用户可以自由混用两者，只要不产生重复和链接问题即可。
Redit的cpp频道里面有人发起了一个&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/agcw7d/c_modules_a_chance_to_clean_up_the_language/&quot;&gt;是否提供一种机制让用户强制在某一个模块中清理旧有的include模式的讨论&lt;/a&gt;，采用的思路正式类似Rust语言的版本指定的思路。&lt;/p&gt;

&lt;p&gt;这个想法其实有很重要的现实意义，因此有很多自身CPP用户发表了自己的看法，大概标准定义成现在这个样子应该主要是两个方面的原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;委员会中的代表有很多来自于大公司，这些公司有海量的遗留代码；因此出于&lt;strong&gt;自身利益的考虑&lt;/strong&gt;他们不会选择一种不兼容的方案和自己过不去。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;社区分裂的风险&lt;/strong&gt;，这个其实从C++03诞生依赖就有人开始质疑，乃至于早期的D语言就是冲着这一点不满才决定选择单干，可惜有评论认为现在的D语言的分裂情况和C++比较起来完全是不遑多让的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;这些问题其实都是很现实的问题&lt;/strong&gt;，个人觉得WG21选择向后兼容的思路并没有什么问题，因为从新发明轮子的时候都是简单的，真正&lt;strong&gt;复杂的是如何长期稳定地维护和更新&lt;/strong&gt;。
C++的使用领域一直在缩小（或者有人说它是退回到了适合的领域）是个不争的事实，然而在适合的领域，它的优势不光在于语言本身还依赖于这些遗留系统的支撑。&lt;/p&gt;

&lt;h2 id=&quot;协程支持&quot;&gt;协程支持&lt;/h2&gt;
&lt;p&gt;协程并不是一个新鲜的概念，甚至在现代编程语言出现之前很久就被提出出来，并在其它一些编程语言中被实现了很长时间了；它的基本思想是要求一个函数或者过程可以在执行过程中被操作系统或者调度器临时中止，然后在适合的时机（获取CPU计算资源等）再被恢复执行。详细的描述可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;为什么需要协程&quot;&gt;为什么需要协程&lt;/h3&gt;
&lt;p&gt;协程最明显的一个好处是允许我们书写&lt;strong&gt;看起来顺序执行但是其实背后却异步执行的代码&lt;/strong&gt;，这样技能协调人大脑擅长顺序逻辑和计算机处理擅长异步执行的矛盾，兼顾效率和心智负担。
同时协程还可以支持惰性赋值和初始化的逻辑，进一步提高程序的运行效率（仅仅在需要的时候做运算）但是又不对程序员的大脑产生太多的额外负担。&lt;/p&gt;

&lt;p&gt;协程是一个比进程和线程更轻量级一点的概念，具体实现上来说可以分为有栈协程和无栈协程；技术上来说前者可以通过第三方库实现就可以，但是性能开销比较大也容易出问题；而&lt;strong&gt;无栈协程更加轻量级但是需要语言特性上做出改动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;C++20引入的协程属于无栈协程。&lt;/p&gt;

&lt;h3 id=&quot;基本语法定义&quot;&gt;基本语法定义&lt;/h3&gt;
&lt;p&gt;C++中的协程首先要是一个函数，它满足如下特性&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;可以被中止，保存状态然后在合适的时机恢复执行 - 这也是协程的基本要求&lt;/li&gt;
  &lt;li&gt;本身是不需要额外的栈的，即stackless&lt;/li&gt;
  &lt;li&gt;当被暂时中止的时候，执行权被交回了调用者&lt;/li&gt;
  &lt;li&gt;它的定义语法满足下述的特征&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;协程函数语法和关键字&quot;&gt;协程函数语法和关键字&lt;/h4&gt;
&lt;p&gt;协程函数定义可以又如下一些特征：&lt;/p&gt;

&lt;h5 id=&quot;co_await操作符等待另外一个协程的完成&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt;操作符等待另外一个协程的完成&lt;/h5&gt;
&lt;p&gt;比如如下的从网络读取数据并写回对方的echo代码，从逻辑上看循环内部的两行代码是顺序执行的，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;关键字却标明了逻辑上它是&lt;strong&gt;通过”等待“另外一个协程完成&lt;/strong&gt;才继续往下执行的。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_echo_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_read_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;co_yield-可以直接挂起当前的协程执行并返回一个值&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_yield&lt;/code&gt; 可以直接挂起当前的协程执行并返回一个值&lt;/h5&gt;
&lt;p&gt;比如下面的循环中，每次到&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;操作的时候，当前的协程便被暂时中止执行并返回一个整数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;generator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iota&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;co_yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种用法在其它语言中也叫generator函数或者生成器。&lt;/p&gt;

&lt;h5 id=&quot;co_return用于直接返回&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;用于直接返回&lt;/h5&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;lazy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;co_return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;返回类型要求&quot;&gt;返回类型要求&lt;/h5&gt;
&lt;p&gt;因为协程的返回值并不是普通的值而是一个可以和另外一个协程相互协作的对象，因此C++标准对协程的返回值有如下要求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能使用可变参数&lt;/li&gt;
  &lt;li&gt;不能使用普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句&lt;/li&gt;
  &lt;li&gt;不能返回自动推导的类型，如&lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;concept&lt;/code&gt;类型等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时如下的函数也不能是协程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt;函数因为需要在编译器运算，不能是协程&lt;/li&gt;
  &lt;li&gt;构造函数和析构函数用于普通对象的构造，也不能被延迟执行进而不能是协程&lt;/li&gt;
  &lt;li&gt;主函数不能是协程，否则操作系统无从启动程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;协程的执行&quot;&gt;协程的执行&lt;/h3&gt;

&lt;p&gt;任何一个协程其实由如下这些要素构成&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;promise&lt;/code&gt;对象需要充当一个桥梁&lt;/strong&gt;，由协程内部改变其状态，将值提交给另外一方等待该promise的协程&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;外部协程操控另外一个协作协程的句柄&lt;/strong&gt;，外部协程需要借助该句柄来决定是否挂起对方的协程或者将其协程帧销毁&lt;/li&gt;
  &lt;li&gt;隐式的&lt;strong&gt;协程状态对象&lt;/strong&gt;，该对象需要能够
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;保存内嵌的promise对象&lt;/li&gt;
        &lt;li&gt;用值拷贝方法传递的参数值对象 - 显然出于内存安全的考虑不能由引用或者指针&lt;/li&gt;
        &lt;li&gt;当前执行到哪个阶段的状态标识，从而外部协程知道下一步是否应该迁移状态还是需要销毁帧数据&lt;/li&gt;
        &lt;li&gt;其它一些生存期超越当前挂起点的局部变量&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;协程执行的流程&quot;&gt;协程执行的流程&lt;/h4&gt;
&lt;p&gt;当一个协程执行的时候，它的实际运行顺序如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来分配上述的状态对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拷贝所有的函数参数&lt;/strong&gt;到这个对象中（因为协程本身也是个函数），值类型直接拷贝，如果由&lt;strong&gt;引用或者指针类型，其安全性需要程序员自己保证有效性&lt;/strong&gt;，因为在协程中他们同样使引用和指针&lt;/li&gt;
  &lt;li&gt;构造promise对象，这里先查找它&lt;strong&gt;是否支持对应协程所有传入参数为参数签名的构造函数&lt;/strong&gt;并调用，如果没有则调用默认构造函数来构造&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.get_return_object&lt;/code&gt;函数，将结果放在一个局部变量中；这样&lt;strong&gt;第一次协程被挂起的时候，该局部变量就可以被返回给调用者&lt;/strong&gt;。如果在第一次执行到挂起之前发生了异常，对应的结果都不会放置在promise中，而是通过该局部变量返回&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.initial_suspsed&lt;/code&gt;函数，并使用&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await&lt;/code&gt;等待它的结果。通常情况下，promise类型要么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_always&lt;/code&gt;,要么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_never&lt;/code&gt;;前者对应的使延迟启动的协程，后者则对应提前启动的协程&lt;/li&gt;
  &lt;li&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;co_await promise.initial_suspend&lt;/code&gt;恢复的时候，协程的函数体才开始别执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当该协程函数执行到一个挂起点，返回对象将会通过必要的类型转换返回给外部协程的等待方。&lt;/p&gt;

&lt;h5 id=&quot;返回&quot;&gt;返回&lt;/h5&gt;
&lt;p&gt;如果协程函数执行到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;语句，则执行如下的操作&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果返回类型是如下的几种，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.return_void&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return;&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return expr;&lt;/code&gt; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;expr&lt;/code&gt;的类型其实是void&lt;/li&gt;
        &lt;li&gt;直接跳过了可能的&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;语句而执行到了函数的结果；如果promise对象恰好定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise::return_void()&lt;/code&gt;函数，那么&lt;strong&gt;行为就是未定义&lt;/strong&gt;的，需要格外留意！&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;否则将调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.return_value(expr)&lt;/code&gt;返回需要的类型&lt;/li&gt;
  &lt;li&gt;销毁协程开始阶段创建的所有的局部自由变量，销毁的顺序和构造顺序相反&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.final_suspend&lt;/code&gt;函数，并等待其&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;结果&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;协程异常处理&quot;&gt;协程异常处理&lt;/h5&gt;
&lt;p&gt;如果协程中抛出了&lt;strong&gt;未捕获异常&lt;/strong&gt;，它的行为如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;捕获异常，并调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.unhandled_exception&lt;/code&gt;函数&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;promise.final_suspend&lt;/code&gt;函数，并等待其&lt;code class=&quot;highlighter-rouge&quot;&gt;co_awit&lt;/code&gt;结果&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;状态对象的销毁&quot;&gt;状态对象的销毁&lt;/h5&gt;
&lt;p&gt;当协程状态对象因为&lt;code class=&quot;highlighter-rouge&quot;&gt;co_return&lt;/code&gt;或者异常情况需要销毁的时候，其执行过程如下&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用promise对象本身的析构函数&lt;/li&gt;
  &lt;li&gt;调用协程参数对象的析构函数&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator delete&lt;/code&gt;来完成对状态对象本身的销毁&lt;/li&gt;
  &lt;li&gt;将执行权交回外部调用者&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;堆内存分配&quot;&gt;堆内存分配&lt;/h3&gt;
&lt;p&gt;协程的状态&lt;strong&gt;必须要通过&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来分配，因为标准要求这里必须是无栈协程。分配过程遵循如下两条规则&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型定义了一个类级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;，则&lt;strong&gt;优先选择此分配方法&lt;/strong&gt;，否则会调用全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;来完成内存分配&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型定义了自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;operator new&lt;/code&gt;，并且&lt;strong&gt;其函数签名和协程的函数参数签名一致，这些参数将会被一并传递&lt;/strong&gt;给该函数，这样的目的是为了和leading allocator convention的行为保持一致，即签名一致的分配器有优先权&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;可能的分配优化&quot;&gt;可能的分配优化&lt;/h4&gt;
&lt;p&gt;如果有办法事先确认协程状态对象的生存周期一定比调用方的生存周期短，并且该协程的帧大小在调用的时候可以明确得到。
该优化即使对用户自定义的内存分配器也可以使用。
这种情况下，&lt;strong&gt;被调用的协程的栈帧其实是内嵌在了调用方的函数栈帧&lt;/strong&gt;中，就像一个迷你的内联函数调用一样。&lt;/p&gt;

&lt;h3 id=&quot;promise类型&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;类型&lt;/h3&gt;
&lt;p&gt;实际的promise类型则由&lt;strong&gt;编译器根据实际协程声明中的签名类型&lt;/strong&gt;结合&lt;code class=&quot;highlighter-rouge&quot;&gt;std::corountine_traits&lt;/code&gt;模板推到得出。&lt;/p&gt;

&lt;p&gt;比如当一个协程的类型被定义为 &lt;code class=&quot;highlighter-rouge&quot;&gt;task&amp;lt;float&amp;gt; foo(std::string x, bool flag)&lt;/code&gt;，那么编译器推导出来的类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果协程被定义为非static的成员函数，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const&lt;/code&gt;,对应的推导出来的Promise类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;,同时对象类型会被放置在第一个参数模板了行中。&lt;/p&gt;

&lt;h3 id=&quot;编译器支持情况&quot;&gt;编译器支持情况&lt;/h3&gt;

&lt;p&gt;Visual Studio是这个提案的主推者之一，所以早在2013年MSVC就提供了自己的协程实现；并且在&lt;a href=&quot;https://devblogs.microsoft.com/cppblog/yield-keyword-to-become-co_yield-in-vs-2017/&quot;&gt;VS2017中正式将关键字向标准提案靠拢&lt;/a&gt;。
Clang也提供了支持，尽管&lt;a href=&quot;https://clang.llvm.org/cxx_status.html&quot;&gt;其C++ Status页面&lt;/a&gt;显示的还是partial支持。
遗憾的是GCC的corountine支持还处于比较早期的阶段，目前仍然在一个&lt;a href=&quot;https://gcc.gnu.org/wiki/cxx-coroutines&quot;&gt;分支上开发&lt;/a&gt;。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="engineering" /><category term="language" /><category term="cpp" /><summary type="html">C++20的功能特性已经于3月份冻结，显然这次终于来了一波大的改进，而不再是像之前C++14/C++17那般小打小闹的做小步快跑，尤其是三个讨论很久的大feature终于被合入主干；并且这些feature终将会极大地影响后续C++代码的书写方式。</summary></entry><entry><title type="html">C++正则表达式比Python慢？</title><link href="https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize/" rel="alternate" type="text/html" title="C++正则表达式比Python慢？" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize</id><content type="html" xml:base="https://skyscribe.github.io/post/2019/06/22/regular-expression-optimize/">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B17&quot;&gt;C++17&lt;/a&gt; 推出已经有将近3年的时间，速度快一些的公司才慢慢采纳了6年前的C++14进入正式的生产环境。
程序员们的一个大福利就是终于不用外挂第三方库（无论是准标准的boost还是其它形形色色的其它第三方库）就可以直接方便地使用标准库自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;来写代码；
这显然比直接使用原始而笨拙的&lt;code class=&quot;highlighter-rouge&quot;&gt;string::find_first_of&lt;/code&gt;外加一堆边界检查和判断&lt;strong&gt;要轻松和干净&lt;/strong&gt;很多。&lt;/p&gt;

&lt;p&gt;然而&lt;a href=&quot;https://stackoverflow.com/questions/14205096/c11-regex-slower-than-python&quot;&gt;stackoverflow上&lt;/a&gt;的一位&lt;strong&gt;注重性能&lt;/strong&gt;的&lt;a href=&quot;https://stackoverflow.com/users/239007/locojay&quot;&gt;程序员&lt;/a&gt;**很快就发现有些地方不对：好像这个新的regex标准库API是长的漂亮了不少，但是性能似乎和C++的“零成本的抽象”格格不入？&lt;/p&gt;

&lt;h2 id=&quot;python版本比c快很多&quot;&gt;Python版本比C++快很多？&lt;/h2&gt;

&lt;p&gt;locojay给出来一个非常简单的使用正则表达式来分隔字符串的代码，并且比较了C++版本和Python版本的运行时间（自然Python语言在C++社区特别受欢迎不是空穴来风），发现C++版本慢的不可理喻。&lt;/p&gt;

&lt;p&gt;C++代码比较简单：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;刨去&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数种的调用，实现的代码是典型的使用迭代器来生成新的split子迭代器，并构造为&lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;返回。&lt;/p&gt;

&lt;p&gt;对应的python版本如下&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' +'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'a b c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行的结果却让人大跌眼镜，即使在使用了最大可能的优化选项-O3（C/C++&lt;strong&gt;性能很好的重要来源之一就是几十年间积累的形形色色的编译器后端优化能力&lt;/strong&gt;）之后，两者居然&lt;strong&gt;相差了50%之多并且是C++版本慢&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;注：下面的结果是我自己虚拟机里面跑出来的结果，&lt;strong&gt;原问题回答者的结果似乎还要慢了不少几乎是Python版本的运行时间的两倍&lt;/strong&gt;，也许是因为我的机器里面的GCC版本已经比较新了的原因。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;python3 test.py  
real	0m2.194s
user	0m2.117s
sys	    0m0.004s

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./test
real	0m3.179s
user	0m3.152s
sys	    0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一反应当然会质疑这个结果，但是计算机又不会撒谎，所以一定是代码实现的问题，要么是标准库的regex实现有问题，要么是代码写的有问题？&lt;/p&gt;

&lt;h2 id=&quot;优化掉无意义的临时对象构造和析构&quot;&gt;优化掉无意义的临时对象构造和析构&lt;/h2&gt;
&lt;p&gt;显然这里有一个&lt;strong&gt;无意义的临时string/vector对象的构造和析构&lt;/strong&gt;，这些过程都会伴随着内存的分配和释放，而Python版本由于其内在的string优化压根就没有这些开销。&lt;/p&gt;

&lt;p&gt;去掉这个构造并尽力复用对象而不改变程序的语义后，代码会成为这样&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过将需要使用的字符串和vector挪到循环的外部，运行之后，性能提高了一倍多！稍微麻烦一点的时候，内部的代码因为需要清理容器的内容而变得不太干净了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;real    0m1.254s
user    0m1.238s
sys     0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原答题者的版本里，他的结果还是比Python版本要慢，而我本地机器的运行结果已经超出了python版本不少了！一个自然而然的想法是我们释放可以做的更好？&lt;/p&gt;

&lt;h2 id=&quot;彻底去掉源字符串的内存分配和释放&quot;&gt;彻底去掉源字符串的内存分配和释放&lt;/h2&gt;

&lt;p&gt;注意到这里的第一个参数每次都是同一个，我们根本就不需要将一个&lt;code class=&quot;highlighter-rouge&quot;&gt;const char*&lt;/code&gt;在传递参数的时候构造出来一个新的string对象，直接传递这个指针就可以，代码几乎不需要改动&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不幸的是这样做的结果并不比前一个版本的更快，显然这里的无效字符串已经被编译器给优化掉了。&lt;/p&gt;

&lt;h2 id=&quot;使用string_view&quot;&gt;使用string_view&lt;/h2&gt;
&lt;p&gt;由于注意到这里的结果里面并不需要分配新的字符串，如果我们可以使用C++17,标准库里面已经有一个新的速度更快的&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;类，不会引起任何的内存分配和释放。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;版本的代码如下&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;regex&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;string_view&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cregex_token_iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; +&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a b c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可惜这个版本的性能和&lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt;的前面版本并没有太大的差异。显然性能问题从来就没有想当然而然的部分，必须依照测试情况是实验结果来分析。
另外一个显然的教训是，&lt;strong&gt;内存分配的代价在很多时候比想象的要大很多&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;当然这是一个过分简化了的例子，实际的代码往往比这个要复杂很多，这里的性能结果和结论往往不能适用实际的复杂场景，因为每一个程序的运行环境和执行情况可能都是独一无二的，必须一句实际情况来分析。&lt;/p&gt;

&lt;p&gt;更复杂的情况，这里的计算时间的方法显然也太过原始了；可以借助强大的profile工具，生成perf可以解析的数据，从而进一步生成&lt;a href=&quot;https://github.com/brendangregg/FlameGraphhttps://github.com/brendangregg/FlameGraph&quot;&gt;火焰图&lt;/a&gt;或者直接查看&lt;code class=&quot;highlighter-rouge&quot;&gt;perf report&lt;/code&gt;的命令行界面来分析性能的热点在哪里。&lt;/p&gt;</content><author><name>Fei Yan</name><email>skyscribe.yf@gmail.com</email></author><category term="programming" /><category term="engineering" /><category term="performance" /><category term="cpp" /><category term="python" /><category term="regex" /><summary type="html">C++17 推出已经有将近3年的时间，速度快一些的公司才慢慢采纳了6年前的C++14进入正式的生产环境。 程序员们的一个大福利就是终于不用外挂第三方库（无论是准标准的boost还是其它形形色色的其它第三方库）就可以直接方便地使用标准库自带的&amp;lt;regex&amp;gt;来写代码； 这显然比直接使用原始而笨拙的string::find_first_of外加一堆边界检查和判断要轻松和干净很多。</summary></entry></feed>